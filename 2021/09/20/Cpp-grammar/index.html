<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0-rc2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiaxiyang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="NOTE:basic concept 程序(内存中完全链接): 算法(函数， 代码) + 数据(变量) 编译(未完全链接)：引用 + 定义 (变量和函数) 注意内存分布(代码 + 数据) 编译期，链接期，加载期， 运行期 语句， 表达式 作用域， 生命周期， 所有权 对象何时构造(编译期，运行期)及构造顺序  参考代码 perf-ninja 性能比较 google abseil abseil do">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp grammar">
<meta property="og:url" content="https://jiaxiyang.github.io/2021/09/20/Cpp-grammar/index.html">
<meta property="og:site_name" content="Xiyang">
<meta property="og:description" content="NOTE:basic concept 程序(内存中完全链接): 算法(函数， 代码) + 数据(变量) 编译(未完全链接)：引用 + 定义 (变量和函数) 注意内存分布(代码 + 数据) 编译期，链接期，加载期， 运行期 语句， 表达式 作用域， 生命周期， 所有权 对象何时构造(编译期，运行期)及构造顺序  参考代码 perf-ninja 性能比较 google abseil abseil do">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-20T06:28:44.000Z">
<meta property="article:modified_time" content="2023-09-24T04:05:11.592Z">
<meta property="article:author" content="贾夕阳">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiaxiyang.github.io/2021/09/20/Cpp-grammar/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp grammar | Xiyang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xiyang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Think twice, code once!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">47</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">147</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiaxiyang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiaxiyang.github.io/2021/09/20/Cpp-grammar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/coder2.jpg">
      <meta itemprop="name" content="贾夕阳">
      <meta itemprop="description" content="深度学习/自动驾驶/C++/性能优化">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiyang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp grammar
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-20 14:28:44" itemprop="dateCreated datePublished" datetime="2021-09-20T14:28:44+08:00">2021-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-24 12:05:11" itemprop="dateModified" datetime="2023-09-24T12:05:11+08:00">2023-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Program/" itemprop="url" rel="index"><span itemprop="name">Program</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Program/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/20/Cpp-grammar/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/20/Cpp-grammar/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE:"></a>NOTE:</h2><h3 id="basic-concept"><a href="#basic-concept" class="headerlink" title="basic concept"></a>basic concept</h3><ol>
<li>程序(内存中完全链接): 算法(函数， 代码) + 数据(变量)</li>
<li>编译(未完全链接)：引用 + 定义 (变量和函数)</li>
<li>注意内存分布(代码 + 数据)</li>
<li>编译期，链接期，加载期， 运行期</li>
<li>语句， 表达式</li>
<li>作用域， 生命周期， 所有权</li>
<li>对象何时构造(编译期，运行期)及构造顺序</li>
</ol>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/dendibakh/perf-ninja/blob/main/GetStarted.md">perf-ninja 性能比较</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp">google abseil</a></li>
<li><a target="_blank" rel="noopener" href="https://abseil.io/">abseil doc</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/folly">facebook folly</a></li>
<li><a target="_blank" rel="noopener" href="https://abseil.io/resources/swe-book">Software Engineering at Google</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/qiangmzsx/Software-Engineering-at-Google">Software-Engineering-at-Google 中文版本</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI/blob/2.0/tools/Vitis-AI-Library/benchmark/include/vitis/ai/benchmark.hpp">Vitis-AI</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI/blob/c26eae36f034d5a2f9b2a7bfe816b8c43311a4f8/src/Vitis-AI-Library/benchmark/include/vitis/ai/demo4.hpp">Vitis AI demo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/stbrumme/hash-library">hash-library</a></li>
</ol>
<span id="more"></span>

<h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64493524">attribute</a></h2><ol>
<li><code>[[maybe_unused]]</code></li>
<li><code>__attribute__((visibility(&quot;default&quot;)))</code> 函数符号不隐藏</li>
<li><code>[[deprecated]]/[[deprecated(&quot;reason&quot;)]]</code></li>
</ol>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol>
<li>std::array 编译期需要确定大小；在栈上分配内存，std::vector 在堆上;在栈上申请内存比堆快 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/481687008">link</a>;</li>
<li><code>类型擦除</code>指将原有类型消除或者隐藏，因为很多时候我们并不关心具体类型是什么，我们只需要去使用就可以了，提高提高代码的简洁性。是不是很耳熟，对，抽象继承的多态其实就是比较传统、常见及简单的类型擦除。我们使用的只是抽象接口，而不关心具体实现类的类型。类型擦除常用做法是<code>多态、模板、通用类型（C++17 std::any|std::variant）、闭包</code></li>
<li>注意区分#ifdef 在头文件和.cpp 中的表现，在头文件中，不同的库也要定义才能生效，如果在.cpp 中，只需要相应 lib 定义就好</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sksukai/article/details/105612235">头文件中定义问题</a>&#x2F;</li>
</ol>
<h2 id="性能测试-chrono-link"><a href="#性能测试-chrono-link" class="headerlink" title="性能测试 chrono link"></a>性能测试 chrono <a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI/blob/master/tools/Vitis-AI-Runtime/VART/vart/util/include/vitis/ai/profiling.hpp">link</a></h2><ol>
<li>计时用 steady_clock, timestamp 用 system_clock</li>
<li>steady_clock 是单调的时钟，相当于教练手中的秒表；只会增长，适合用于记录程序耗时；</li>
<li>system_clock 是系统的时钟；因为系统的时钟可以修改；甚至可以网络对时； 所以用系统时间计算时间差可能不准。</li>
<li>high_resolution_clock, 不建议使用</li>
<li>可以和 glog 与 get_env 结合(性能与 Debug 结合) <a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI/blob/master/tools/Vitis-AI-Runtime/VART/vart/util/include/vitis/ai/env_config.hpp">link</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1861a844a2fb">CLOCK_MONOTONIC 与 CLOCK_REALTIME 区别</a></li>
<li>C++11 中的 system_clock::now() 使用 gettimeofday()或者 std::time()，而 steady_clock::now()则使用 clock_gettime(CLOCK_MONOTONIC,*);</li>
</ol>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">using Clock = std::chrono::steady_clock;</span><br><span class="line">#define __TIC__(tag) auto __##tag##_start_time = Clock::now();</span><br><span class="line"></span><br><span class="line">#define __TOC__(tag)                                                  \</span><br><span class="line">  auto __##tag##_end_time = Clock::now();                             \</span><br><span class="line">  std::cout &lt;&lt; #tag &lt;&lt; <span class="string">&quot; : &quot;</span>                                          \</span><br><span class="line">            &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( \</span><br><span class="line">                   __##tag##_end_time - __##tag##_start_time)         \</span><br><span class="line">                   .count()                                           \</span><br><span class="line">            &lt;&lt; <span class="string">&quot;us&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ns</li>
</ol>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">using Clock = std::chrono::steady_clock;</span><br><span class="line">#define __TIC__(tag) auto __##tag##_start_time = Clock::now();</span><br><span class="line"></span><br><span class="line">#define __TOC__(tag)                                                  \</span><br><span class="line">  auto __##tag##_end_time = Clock::now();                             \</span><br><span class="line">  std::cout &lt;&lt; #tag &lt;&lt; <span class="string">&quot; : &quot;</span>                                          \</span><br><span class="line">            &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;( \</span><br><span class="line">                   __##tag##_end_time - __##tag##_start_time)         \</span><br><span class="line">                   .count()                                           \</span><br><span class="line">            &lt;&lt; <span class="string">&quot;ns&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="数式编程"><a href="#数式编程" class="headerlink" title="数式编程"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45750387">数式编程</a></h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ol>
<li>transform</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10000</span>, <span class="number">1.111</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">10000</span>, <span class="number">2.111</span>)</span></span>;</span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; result;</span><br><span class="line"><span class="comment">// 操作一个vector</span></span><br><span class="line">std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result),</span><br><span class="line">               [](<span class="type">const</span> <span class="keyword">auto</span> item) -&gt; <span class="type">float</span> &#123; <span class="keyword">return</span> item + <span class="number">100</span>; &#125;);</span><br><span class="line"><span class="comment">// for_each(vec.begin(), vec.end(), [](auto &amp;item) &#123; item += 100; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作两个vector <span class="doctag">NOTE:</span> 使用前需要检查vec, vec1 size是否匹配。</span></span><br><span class="line"><span class="comment">// 性能好 797us 13us(-O3)</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">result1</span><span class="params">(<span class="number">10</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec1.<span class="built_in">begin</span>(), result1.<span class="built_in">begin</span>(),</span><br><span class="line">               [](<span class="type">const</span> <span class="keyword">auto</span> &amp;item1, <span class="type">const</span> <span class="keyword">auto</span> &amp;item2) -&gt; <span class="type">float</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> item1 + item2;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能差 2605us 173us(-O3)</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; result2;</span><br><span class="line">std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec1.<span class="built_in">begin</span>(),</span><br><span class="line">               std::<span class="built_in">back_inserter</span>(result2),</span><br><span class="line">               [](<span class="type">const</span> <span class="keyword">auto</span> &amp;item1, <span class="type">const</span> <span class="keyword">auto</span> &amp;item2) -&gt; <span class="type">float</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> item1 + item2;</span><br><span class="line">               &#125;);</span><br><span class="line"><span class="comment">// for 463us 70us(-O3)</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">result3</span><span class="params">(vec.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>; i &lt; result3.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  result[i] = vec[i] + vec1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ol>
<li>copy_if</li>
<li>remove_if</li>
</ol>
<h3 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h3><ol>
<li>accumulate <code>float sum = std::accumulate(vec.begin(), vec.end(), 0.0, std::plus&lt;float&gt;());</code></li>
</ol>
<h3 id="func-函数名"><a href="#func-函数名" class="headerlink" title="__func__函数名"></a>__func__函数名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RVO-返回值优化-effective-modern-c-166-页"><a href="#RVO-返回值优化-effective-modern-c-166-页" class="headerlink" title="RVO 返回值优化 effective modern c++ 166 页"></a>RVO 返回值优化 effective modern c++ 166 页</h2><ol>
<li>返回值也是函数参数，RVO 直接在位函数返回值分配的内存上创建局部变量来避免复制</li>
<li>两个条件：<ul>
<li>局部对象类型和返回值类型相同</li>
<li>返回的就是局部对象本身</li>
</ul>
</li>
</ol>
<h2 id="gcc-O0-O1-O2-O3-四级优化选项及每级分别做什么优化"><a href="#gcc-O0-O1-O2-O3-四级优化选项及每级分别做什么优化" class="headerlink" title="gcc -O0 -O1 -O2 -O3 四级优化选项及每级分别做什么优化"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31108501/article/details/51842166">gcc -O0 -O1 -O2 -O3 四级优化选项及每级分别做什么优化</a></h2><h2 id="GDB-使用"><a href="#GDB-使用" class="headerlink" title="GDB 使用"></a><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html">GDB 使用</a></h2><ol>
<li>.gdbinit gdp 配置文件</li>
<li>编译要加 -g <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74897601">link</a></li>
<li>readelf -S xxx|grep debug 查看有没有 debug 段</li>
<li>file xxx 查看有没有 stripped (编译不能加 -s)</li>
<li>-fkeep-inline-functions 调试内联，编译的程序会变大很多</li>
<li>set logging file log.txt, set logging on, set logging overwrite on 记录执行 log</li>
<li>gdb -q 启动时不显示版本等信息</li>
<li>gdb –args xxx … &amp;&amp; r 或 gdb xxx &amp;&amp; set args … &amp;&amp; r 或 gdb xxx &amp;&amp; r …</li>
<li>show env xxx 显示环境变量</li>
<li>bt 或 i s(info stack) 显示程序栈 backtrace</li>
<li>l 或 l + 向下显示源码， l - 向上显示源码，l 1,100 打印 1 到 100 行， l xxx:10 显示文件 xxx 第 10 行, l funciton 显示函数，</li>
<li>bt 可以显示运行到哪一行, l -1 或 l +1 显示当前行前后代码</li>
<li>step&#x2F;finish 进入&#x2F;返回函数 <a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/finish-and-return.html">link</a></li>
<li>tb 如果想让断点只生效一次，可以使用“tbreak”命令</li>
<li>source script 执行脚本中的命令</li>
<li>p&#x2F;x c 十六进制打印</li>
<li>d 删除所有断点</li>
<li>watch expr</li>
<li>info functions add 列出 add 函数</li>
<li>在程序入口处打断点, 先 readelf -h xxx 读入口地址，然后 b * 设置断点 <a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-entry.html">link</a></li>
<li>set print array-indexes on 打印数组下标</li>
<li>i args 显示函数参数</li>
<li>i locals 打印局部变量</li>
<li>i sharedlibrary 显示共享链接库</li>
<li>whatis xxx 打印变量类型， ptype xxx 打印详细信息，</li>
<li>set history filename ~&#x2F;.gdb_history， set history save on 保存历史</li>
<li>shell ls 或 !ls 在 gdb 中执行 shell 命令</li>
<li>可以直接执行 cd 和 pwd</li>
<li>远程调试：</li>
<li>emacs gdb-many-window, gdb 多窗口调试</li>
</ol>
<h2 id="input-and-output"><a href="#input-and-output" class="headerlink" title="input and output"></a>input and output</h2><ol>
<li><code>std::flush</code> 立即输出， Without std::flush, the output would be the same, but may not appear in real time.</li>
</ol>
<h2 id="标准函数-和-库"><a href="#标准函数-和-库" class="headerlink" title="标准函数 和 库"></a>标准函数 和 库</h2><ol>
<li>std::filesystem 库 create_directoriesfile_size, exists, current_path,</li>
<li>std::numeric_limits<float>::max()最大浮点数， std::numeric_limits<float>::lowest() 最小浮点数，注意不是 min。 #include<limits></li>
<li>std::round()四舍五入 #include&lt;math.h&gt;</li>
<li>std::floor()向下取整 #include&lt;math.h&gt;</li>
<li>std::ceil() 向上取整 #include&lt;math.h&gt;</li>
<li>std::memcmp() 按位比较是否完全相等，解决 if(-0 &#x3D;&#x3D; 0)问题</li>
<li>std::memset() 只能用于设置连续内存，不能用于 vector <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/408799127">link</a></li>
<li>int mi &#x3D; std::min({x1, x2, x3, x4});</li>
<li>std::max_element <code>auto max_value = *std::max_element(vec0.begin(), vec0.end()); </code></li>
<li>std::min_element <code>auto min_value = *std::min_element(vec0.begin(), vec0.end());</code></li>
<li>std::minmax_element <code>const auto [min, max] = std::minmax_element(vec0.begin(), vec0.end()); std::cout &lt;&lt; &quot;min = &quot; &lt;&lt; *min &lt;&lt; &quot;, max = &quot; &lt;&lt; *max &lt;&lt; &#39;\n&#39;;</code></li>
</ol>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.json.org/json-en.html">json 库集合</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/nlohmann/json">json for modern c++</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/miloyip/nativejson-benchmark#parsing-time">jeson benchmark</a></li>
</ol>
<h2 id="ideas"><a href="#ideas" class="headerlink" title="ideas"></a>ideas</h2><ol>
<li>记录语法时最好能举个例子</li>
<li><code>why?</code>。模块<code>存在的目的？解决了什么问题？特点特性？优缺点？适用范围？概念？架构？设计思路？具体实现方式？</code>等方面学习？</li>
<li>模块的存在的目的，功能作用，实现方式</li>
<li>按照 Bjarny Stroustrup 列的特性重新进行分类。</li>
</ol>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol>
<li><code>开闭原则</code> 软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</li>
<li><code>单一职责原则</code> 一个类只做一件事</li>
<li><code>里氏替换原则</code> 子类应该可以完全替代父类，也就是说在使用继承时，只扩展新功能，不要破坏父类原有的功能。</li>
<li><code>依赖倒置原则</code> 细节应该依赖与抽象，抽象不应该依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。</li>
<li><code>迪米特法则/最少知道原则</code> 一个类不应该知道自己操作类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li>
<li><code>接口隔离原则</code> 客户端不应该依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将该接口拆分，让实现类只依赖自己需要的接口。</li>
</ol>
<h2 id="struct-对齐和补齐"><a href="#struct-对齐和补齐" class="headerlink" title="struct 对齐和补齐"></a><a target="_blank" rel="noopener" href="http://www.lingjun.online/2020/07/21/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%82%A3%E7%82%B9%E4%BA%8B/">struct 对齐和补齐</a></h2><p>结构体的对齐和补齐的规则：<br>对齐：假定从零地址开始，每成员的起始地址编号，必须是它本身字节数的整数倍。<br>补齐：结构的总字节数必须是它最大成员的整数倍。</p>
<h2 id="C-language-features"><a href="#C-language-features" class="headerlink" title="C++ language features"></a>C++ language features</h2><h2 id="Concurrency-Parallelism-and-Async"><a href="#Concurrency-Parallelism-and-Async" class="headerlink" title="Concurrency, Parallelism and Async"></a>Concurrency, Parallelism and Async</h2><ol>
<li>Concurrency(并发): Less freedom for the scheduler(usually because of missing information)</li>
<li>Parallelism(并行): More information provided to the scheduler(thus more freedom)</li>
<li>Serial(串行：单线程) is between concurrency and parallelism.</li>
<li></li>
</ol>
<h3 id="C-concurrency-development"><a href="#C-concurrency-development" class="headerlink" title="C++ concurrency development"></a>C++ concurrency development</h3><ol>
<li>C++11: Memory model, Threads, Mutexes and locks, Thread local data, Condition vaviables, Tasks</li>
<li>C++14: Reader-writer locks</li>
<li>C++17: Parallel STL</li>
<li>C++20: std::jthread, Atomic smart pointers, Latches and barriers, Semaphores, Coroutines</li>
<li>C++23: Executors, std::future, extensions, Transactional memory, Task blocks, Data-parallel vector, library</li>
<li>多线程要统计各个函数的运行时间，根据时间进行线程数比例划分，例如，预处理函数 1s，处理函数 2s，那么给预处理分配 1 个线程，处理分配两个线程，</li>
</ol>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ol>
<li>Object-Oriented Programming</li>
<li>base class: defines the API</li>
<li>derived classes: provide different implementaions</li>
</ol>
<h2 id="Generic-Programming"><a href="#Generic-Programming" class="headerlink" title="Generic Programming"></a>Generic Programming</h2><ol>
<li>泛型编程主要是为算法流程编写的，不是为数据结构，使算法通用化，可以适应不同的数据结构。</li>
<li>可以先写一个具体的例子，抽象出算法，屏蔽数据结构（类型）。</li>
<li><code>A type: specifies the set of operations that can be applied to an object and specifies how an object is laid out in memory</code> 类型不仅规定对象的操作集合，还规定对象在内存中的排布</li>
<li><code>A concept: Specifies the set of operations that can be applied to an object and says nothing about the layout of the object</code> Concept 只规定对象的操作集合，不规定对象在内存中的排布。</li>
<li>模板类是比参数类型 T 更高一级的抽象。模板类实现高一级别的抽象，而不用关心低一级抽象的不同。</li>
</ol>
<h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><ol>
<li>typename 关键字用于引入一个模板参数</li>
<li>使用 typename 标识嵌套类型名称。</li>
<li>使用从属类型时要加 typename。比如：<code>typename T::const_iterator iter()</code>不加 typename 会报错，因为编译器并不知道 T::const_iterator 是一个类型的名字还是摸个变量的名字。</li>
<li>可变参数模板(c++11 之前参数个数固定不可变)：<code>template&lt;typename... Args&gt; class test</code>表示 Args 个数不固定，使用时<code>void f(Args... args)</code></li>
<li><code>template &lt;typename T&gt; using xxx = T</code></li>
</ol>
<h3 id="模板嵌套"><a href="#模板嵌套" class="headerlink" title="模板嵌套"></a>模板嵌套</h3><h2 id="RAII-Resource-Acquisition-Is-Initalization"><a href="#RAII-Resource-Acquisition-Is-Initalization" class="headerlink" title="RAII Resource Acquisition Is Initalization"></a>RAII Resource Acquisition Is Initalization</h2><ol>
<li>资源获取初始化：<code>使用局部对象来管理资源的技术</code>被称为资源获取初始化。<code>局部对象</code>(有生命周期)是指存储在<code>栈</code>上的对象，它的生命周期由操作系统管理，无需人工介入。</li>
<li>利用： C++保证了所有栈对象在生命周期结束时会被销毁(调用析构函数)。<ul>
<li><code>A a;</code> 在栈上分配 a</li>
<li><code>A* a = new A()</code> 在堆上分配 a，并在栈上保存 a 的指针，生命周期结束后只释放栈上的指针变量，需要 delete 释放资源。。</li>
<li><code>unique_ptr&lt;A&gt; a = make_unique&lt;A&gt;(new A())</code> 在栈上分配 a，在堆上分配 A 的对象，a 中保存了 A 对象的指针，a 用来管理 A 对象，当 a 生命周期结束，会调用 a 的析构函数，释放 A 对象资源。</li>
</ul>
</li>
<li>RAII 用来自动管理对象，例如 smart pointers，用栈来管理资源。</li>
<li>RAII 流程：设计一个类封装资源，构造函数初始化，析构函数释放资源。</li>
<li>RAII 可以极大地简化资源管理，并有效的保证程序的正确和代码的简洁。</li>
<li>The slogan is about initialization, but its meaning is ready about cleanup.</li>
<li><code>resource</code>: anything that requires specail(manual) management.<ul>
<li>Allocated memory(molloc&#x2F;free, new&#x2F;delete)</li>
<li>POSIX file handles(open&#x2F;close)</li>
<li>C FILE handles(fopen&#x2F;fclose)</li>
<li>Mutex locks(pthread_mutex_lock&#x2F;pthread_mutex_unlock)</li>
<li>C++ threads(spawn&#x2F;join)</li>
<li>objective-c resource-counted objects(retain&#x2F;release)</li>
</ul>
</li>
<li>resource 管理涉及到的操作： 资源释放（destructor)，资源复制(copy constructor)，释放原来资源并复制其他资源(copy assignement operator)，资源所有权转移(move operator)，释放原来资源并转移其他资源(move assignment operator)。</li>
<li>RRID(Resource Release Is Destruction)</li>
</ol>
<h3 id="构造函数，析构函数，copy-构造函数，copy-赋值构造函数，move-构造函数，move-赋值构造函数"><a href="#构造函数，析构函数，copy-构造函数，copy-赋值构造函数，move-构造函数，move-赋值构造函数" class="headerlink" title="构造函数，析构函数，copy 构造函数，copy 赋值构造函数，move 构造函数，move 赋值构造函数"></a>构造函数，析构函数，copy 构造函数，copy 赋值构造函数，move 构造函数，move 赋值构造函数</h3><ol>
<li>全局对象的构造函数在程序进入 main() 函数之前执行</li>
<li>Initialization is not assignment.</li>
<li><code>T w = v;</code> This is an initialization(construction) of a new object. It calls a copy constructor.</li>
<li><code>T w; w = v;</code> This is an assignment to the existing object w. It calls an assignment operator.</li>
<li>使得函数 default 可能提醒他人调用 default 是可以正常工作的。</li>
<li>资源释放应该放到析构函数中，避免资源泄露。</li>
<li>赋值构造函数最好使用 copy-and-swap.这样可以解决 self-copy 等问题。</li>
<li>析构函数的调用与构造函数反序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy assignment constructor</span></span><br><span class="line">T&amp; T::<span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs) &#123;</span><br><span class="line">    T <span class="built_in">copy</span>(rhs);  <span class="comment">// 调用copy构造函数</span></span><br><span class="line">    copy.<span class="built_in">swap</span>(*<span class="keyword">this</span>);  <span class="comment">// good</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;  <span class="comment">// copy will be destruct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment constructor</span></span><br><span class="line">T&amp; T::operatr=(T&amp;&amp; rhs) &#123;</span><br><span class="line">    T <span class="built_in">copy</span>(std::<span class="built_in">move</span>(rhs));  <span class="comment">// rhs现在是左值？</span></span><br><span class="line">    copy.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类对象内存分布"><a href="#类对象内存分布" class="headerlink" title="类对象内存分布"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/dxpqxb/article/details/102794132">类对象内存分布</a></h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chuncanL/article/details/70306740">带基类</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34955591">sizeof(vector&lt;&gt;)大小固定</a></li>
<li><a target="_blank" rel="noopener" href="https://tangocc.github.io/2018/03/20/cpp-class-memory-struct/">虚函数</a></li>
<li><code>p/x *(long *)&amp;T</code> gdb 打印虚表地址 (64 位机器), 对象起始地址前 8 字节</li>
<li><code>p/x *(long *)(*(long *)&amp;T + 8)</code> 打印第 2 个虚函数地址</li>
</ol>
<h3 id="虚析构函数的作用"><a href="#虚析构函数的作用" class="headerlink" title="虚析构函数的作用"></a>虚析构函数的作用</h3><ol>
<li>子类对象析构时一定会调用到子类的析构函数，这可以保证对象的正确析构。（多态时，例如工厂模式，基类需要定义虚析构函数）</li>
<li>多态发生在父类指针或引用指向子类对象时。此时如果没有虚析构，编译器默认调用父类的析构函数，无法通过父类的指针或引用析构子类对象的空间，此时就有可能发生内存泄漏。当父类析构和子类析构定义为 virtual 虚函数时，就可以顺利通过父类的指针或引用析构子类对象的内存空间。</li>
</ol>
<h3 id="构造析构顺序"><a href="#构造析构顺序" class="headerlink" title="构造析构顺序"></a>构造析构顺序</h3><ol>
<li>构造顺序<ul>
<li>如果某个类具有基类，执行基类的构造函数。</li>
<li>类的非静态数据成员，按照声明的顺序创建。</li>
<li>执行该类的构造函数。</li>
</ul>
</li>
<li>析构顺序：相反<ul>
<li>调用类的析构函数。</li>
<li>销毁数据成员，与创建的顺序相反。</li>
<li>如果有父类，调用父类的析构函数。</li>
</ul>
</li>
</ol>
<h3 id="The-Rule-of-Three-or-Five-after-c-11"><a href="#The-Rule-of-Three-or-Five-after-c-11" class="headerlink" title="The Rule of Three or Five(after c++11)"></a>The Rule of Three or Five(after c++11)</h3><ol>
<li>含义：如果类里面需要管理 resource，例如 rall pointer，那么你需要手写 3 个 functions.否则会调用默认函数，可能会出现多个指针副本，引起悬垂指针等问题。（可以 delete 这些函数，使 non-copyalble)<ul>
<li>A destructor to free the resource</li>
<li>A copy constructor to copy the resource</li>
<li>A copy assignment operator to free the left-hand resource and copy the right-hand one.</li>
<li>A move constructor to transfer owenership of resource (after c++11)</li>
<li>A move assignment operator to free the left-hand resource and transfer ownership of the right-hand one(after c++11)</li>
</ul>
</li>
</ol>
<h3 id="The-Rule-of-Zero"><a href="#The-Rule-of-Zero" class="headerlink" title="The Rule of Zero"></a>The Rule of Zero</h3><ol>
<li>含义：如果你的类没有管理任何资源，但是使用了库中的 vector，string 等，那么你应该避免写特殊的函数，使用默认函数。<ul>
<li>Let the compiler implicitly generate a default destructor</li>
<li>Let the compiler generate the copy constructor</li>
<li>Let the compiler generate the copy assignment operator</li>
<li>(But your own swap might improve performance)</li>
</ul>
</li>
</ol>
<h3 id="两种设计良好的-value-semantic-C-类"><a href="#两种设计良好的-value-semantic-C-类" class="headerlink" title="两种设计良好的 value-semantic C++类"></a>两种设计良好的 value-semantic C++类</h3><ol>
<li>Bussiness-logic classes: 不管理资源，follow the Rule of Zero</li>
<li>Resource-management classes(small, single purpose)： 管理资源(最好使用 RAII)，follow the Rule of Three or Five.</li>
</ol>
<h3 id="std-ref-与-reference-wrapper"><a href="#std-ref-与-reference-wrapper" class="headerlink" title="std::ref 与 reference_wrapper"></a>std::ref 与 reference_wrapper</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014645632/article/details/78966340">浅析 std::ref 与 reference_wrapper</a></li>
</ol>
<h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><ol>
<li>move does not move anything. （只是所有权移动，为物理移动任何东西）</li>
<li>move unconditionally casts its input into an rvalue reference(无变量保存的数据)，会将输入变为右值。</li>
<li>move constructor <code>ClassXX(ClassXX&amp;&amp; w) = default</code> w 是右值引用</li>
<li>move assignment operator <code>ClassXX&amp; operator=(ClassXX&amp;&amp; w) = default</code></li>
<li>类成员最好用智能指针。原始指针不能使用默认 move 构造函数。需要自己写 move 构造函数， 分两步： member-wise move and reset。</li>
<li>move asignment operator 分 3 步： cleanup, member-wise move and reset</li>
<li>make move operations(constructor) noexcept</li>
<li>Don’t return a T&amp;&amp;.</li>
<li>使用 move 后，原来的变量不再进行资源释放，它已经将所有权转移给新的变量，由新变量进行资源管理。</li>
</ol>
<h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><ol>
<li><code>&amp; &amp; = &amp;</code>, <code>&amp; &amp;&amp; = &amp;</code>, <code>&amp;&amp; &amp; = &amp;</code>, <code>&amp;&amp; &amp;&amp; = &amp;&amp;</code> 变量，是 lvalue</li>
<li><code>void f(T&amp;&amp; x); auto&amp;&amp; var = var1;</code> 其中 T&amp;&amp;和 auto&amp;&amp;是 forward reference(T 类型不确定，T&amp;&amp;类型要通过推导（模板），如果 T 是确定的，那么是右值引用，如类的 move 构造函数 T 就是类名称)。转发引用。被称为 universal reference.</li>
<li>forward reference 作为参数能接受左值也能接受右值。</li>
<li>应用: <code>make_unique</code>可以传左值和右值。<code>auto i = make_unique&lt;int&gt;(1); auto s1_ptr = make_unique&lt;string&gt;(s1)</code></li>
<li>std::forward（不是 forward reference, 是标准库函数）作用： 如果输入是 lvalue，将其转化为 lvalue reference，如果是 rvalue，将其转化为 rvalue reference。使用原因：当一个函数输入参数是右值，并且需要用到该参数调用其他函数，调用时会将右值转化为左值，因为有了名字。在调用的函数中被当做左值来处理。如果希望是右值，则实现不了。在调用其他函数时，将参数通过 std::forward 转化一下</li>
<li>std::forward does not forward anything。</li>
<li>问题：forward reference 作为模板的参数时能接收任何参数，容易与其他函数冲突。</li>
</ol>
<h3 id="左值-lvalue-右值-rvalue"><a href="#左值-lvalue-右值-rvalue" class="headerlink" title="左值(lvalue) 右值(rvalue)"></a>左值(lvalue) 右值(rvalue)</h3><ol>
<li>左值：占据内存中某个可识别位置（有变量保存）的对象</li>
<li>右值：临时存储，没有变量标识。</li>
<li>如果表达式的结果是一个暂时的对象，那么这个表达式就是右值。</li>
<li>如果函数能直接返回，不要起名字。return 右值，否则要使用 move。(RVO)</li>
</ol>
<h3 id="rvalue-reference-右值引用"><a href="#rvalue-reference-右值引用" class="headerlink" title="&amp;&amp; rvalue reference 右值引用"></a>&amp;&amp; rvalue reference 右值引用</h3><ol>
<li>只有左值才能给引用<code>int nine = 9; int&amp; ref = nine;</code> 不能<code>int&amp; ref = 9;</code>，也不能<code>int&amp; ref = get_value()</code></li>
<li>右值引用用法：<code>int&amp;&amp; ref = 9</code>或<code>int&amp;&amp; ref = get_value()</code></li>
</ol>
<h2 id="Lifetime-and-Allocation-Deallocation"><a href="#Lifetime-and-Allocation-Deallocation" class="headerlink" title="Lifetime and Allocation Deallocation"></a>Lifetime and Allocation Deallocation</h2><ol>
<li>指的是 object lifetime，不是类。</li>
<li>对象涉及到生命周期和内存分配销毁两方面问题。一般生命周期起始分配内存，生命周期结束释放内存。但生命周期可能小于内存分配释放时间，比如 option.</li>
<li>reference 能够延长临时变量生命周期。 <code>string &amp; s = get_string();</code>无问题 <code>char *s = get_string().c_str();</code>有问题，get_string 返回右值，s 只接受了指针，右值内容被释放。</li>
</ol>
<h2 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h2><ol>
<li>用来管理 raw pointer，属于资源管理类。</li>
</ol>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ol>
<li>防止内存泄露，使所有权清晰。</li>
<li>唯一所有权， 不能复制，只能 move</li>
<li>有一个 Deleter 成员变量</li>
<li>有两个参数，Deleter 有默认</li>
<li>智能指针传参和返回值应该<code>按值传递</code>，这样更简单，而且只会消耗很小的资源(8 字节)，栈上传递，很快.</li>
<li>不要通过引用传递指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Deleter</span> = std::default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr &#123;</span><br><span class="line">    T* p_= <span class="literal">nullptr</span>;</span><br><span class="line">    Deleter d_;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (p_) <span class="built_in">d_</span>(p_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>需要调用 free, close 等地方，可以封装为 unique_ptr, sample:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FileClose</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(File *fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(fp != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File *fp = <span class="built_in">fopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="function">std::unique_ptr&lt;File, FileClose&gt; <span class="title">uptr</span><span class="params">(fp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ol>
<li>避免悬垂指针。</li>
<li>shared mean reference counting 引用计数</li>
<li>“Will the last person out of the room please turn out the lights.” 最后一个离开房间的人请关灯，人数就相当于引用计数，灯相当于共享的资源。最后一个释放资源。如果房间里还有人就把灯关了，剩下的人就相当于悬垂指针。</li>
<li>栈上有两部分 ptr to T and ptr to control block。分别指向堆上数据。</li>
<li>uniqe_ptr 可以转化为 shared_ptr，反之不成立。</li>
</ol>
<h3 id="make-shared-and-make-unique"><a href="#make-shared-and-make-unique" class="headerlink" title="make_shared and make_unique"></a>make_shared and make_unique</h3><ol>
<li>现代的 c++应该避免使用 raw new and delete，智能指针可以避免使用 delete，我们也应该避免使用 new，工厂函数能够避免 new。</li>
<li>make_shared and make_unique 都是<code>工厂函数</code>。make_shared 能够产生一个 shared_ptr，make_unique 能够产生一个 unique_ptr</li>
<li><code>最好不要使用rall pointer</code>，。如果不用 rall pointer，就不用担心内存泄露。</li>
</ol>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ol start="2">
<li>weak_ptr 可以告诉你 xuan</li>
<li>weak_ptr has the same physical layout ad shared_ptr</li>
<li>weak_ptr 不是智能指针。不能对 weak_ptr 解引用</li>
<li>weak_ptr 可以看作是获取 shared_ptr 的 ticket，如果拥有 weak_ptr 就有权获得 shared_ptr。</li>
<li></li>
</ol>
<h3 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h3><h2 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h2><h3 id="四种关键字-const-cast-常量性转除-dynamic-cast-向下安全转型-reinterpret-cast-重新解释转型-static-cast-静态转型"><a href="#四种关键字-const-cast-常量性转除-dynamic-cast-向下安全转型-reinterpret-cast-重新解释转型-static-cast-静态转型" class="headerlink" title="四种关键字: const_cast, 常量性转除;dynamic_cast, 向下安全转型;reinterpret_cast, 重新解释转型; static_cast, 静态转型;"></a>四种关键字: const_cast, 常量性转除;dynamic_cast, 向下安全转型;reinterpret_cast, 重新解释转型; static_cast, 静态转型;</h3><ol>
<li>const_cast, 常量性转除:</li>
</ol>
<p>主要对变量的常量性(const)进行操作, 移除变量的常量性, 即可以被非常量指向和引用, 详见代码;</p>
<ol start="2">
<li>dynamic_cast, 向下安全转型:</li>
</ol>
<p>主要应用于继承体系, 可以由 “指向派生类的基类部分的指针”, 转换”指向派生类”或”指向兄弟类”;</p>
<p>static_cast 只能转换为”指向派生类”;</p>
<ol start="3">
<li>reinterpret_cast, 重新解释转型:</li>
</ol>
<p>主要是对 2 进制数据进行重新解释(re-interpret),不改变格式, 而 static_cast 会改变格式进行解释;</p>
<p>如由派生类转换基类, 则重新解释转换, 不改变地址, 静态转换改变地址;</p>
<ol start="4">
<li>static_cast, 静态转型:</li>
</ol>
<p>主要是数据类型的转换, 还可以用于继承;</p>
<h2 id="Zero-Cost-Abstract"><a href="#Zero-Cost-Abstract" class="headerlink" title="Zero Cost Abstract"></a>Zero Cost Abstract</h2><h2 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h2><ol>
<li>用于定义和创建匿名函数。</li>
<li>语法： <code>[capture list] (params list) mutable exception -&gt; return type &#123; function body&#125;</code></li>
</ol>
<h2 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22660775/article/details/89255286">C++宏（Macro）的各种玩法</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/31609246">thread local 来解决 macro 不同线程 static 变量相同问题</a></li>
</ol>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><ol>
<li><code>#if __cplusplus &lt; 201703L</code> 可用宏来兼容 c++11 和 c++17</li>
</ol>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><ol>
<li>内存分为 host 内存和 device 内存。需要管理 device 上需要大空间的对象，比如 tensor，还需要在 host 和 device 内存中传输数据。输入的数据在 host 端处理后需要发送到 device 上使用，device 上输出结果或 dump 的数据需要在 host 端显示或者保存。不同的设备管理方式不同，当设备段是直接通过物理地址管理内存的，可以在 host 端创建一个对象来管理设备端的内存。</li>
</ol>
<h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><ol>
<li><code>栈</code> 函数参数，局部变量</li>
<li><code>堆</code> malloc 和 free。堆上操作系统维护的一块内存</li>
<li><code>自由存储区</code> new 和 delete。自由存储区是 C++中通过 new 和 delete 动态分配和释放对象的抽象概念。有些编译器使用 malloc 和 free 实现 new 和 delete。</li>
<li><code>全局/静态存储区</code> 全局变量和 static 变量。</li>
<li><code>常量存储区</code> 存放的是常量，不允许修改。</li>
</ol>
<h3 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h3><ol>
<li><code>自动存储</code></li>
<li><code>静态存储</code></li>
<li><code>动态存储</code></li>
<li><code>线程存储</code></li>
</ol>
<h2 id="Multi-Thread"><a href="#Multi-Thread" class="headerlink" title="Multi Thread"></a>Multi Thread</h2><h2 id="Small-Module"><a href="#Small-Module" class="headerlink" title="Small Module"></a>Small Module</h2><h3 id="值语义与引用语义"><a href="#值语义与引用语义" class="headerlink" title="值语义与引用语义"></a>值语义与引用语义</h3><ol>
<li>值语义(value sematics)指的是对象的拷贝与原对象无关，就像拷贝 int 一样，拷贝之后与原对象脱离关系。</li>
<li>引用语义(reference sematics)或者对象语义(object sematics)是指面向对象意义下的对象，对象是禁止拷贝的。因为拷贝对象是无意义的，如拷贝一个雇员不会变成两个雇员。</li>
<li>值语义：复制（赋值操作）以后，两个数据对象拥有的存储空间是独立的，相互之间互不影响。</li>
<li>引用语义：复制（赋值操作）以后，两个数据对象互为别名。操作其中一个会影响另一个。</li>
<li>引用语义赋值操作是按位复制，有可能只复制了栈上的数据，为复制堆</li>
<li>值语义的好处： 生命周期管理很简单，不用担心生命周期。</li>
<li>引用语义的 object 由于不能拷贝，我们只能通过指针或引用来使用它。需要考虑生命周期来释放资源，避免悬垂指着等。</li>
<li>使用指针和引用之后所有的赋值代表将有多个变量指向同一个对象，一旦其中一个变量释放了对象的资源，其他的变量的使用将是一个问题。</li>
<li>(zero abstract cost) C++的 class 的 layout 与 C struct 一样，没有额外开销。定义一个只包含一个 int 的 class 的对象和定义一个 int 一样。</li>
<li>默认拷贝构造函数是最简单的浅拷贝。</li>
<li>智能指针实际上是将对象语义转化为值语义。</li>
</ol>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/static">cppreference static members</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/31609246">thread local 来解决 macro 不同线程 static 变量相同问题</a></li>
<li><a target="_blank" rel="noopener" href="https://caloud.tencent.com/developer/article/1858485">类 static 成员变量头文件初始化问题</a></li>
<li>C++17 中可以用 inline 来在头文件中定义类的 static 成员变量 <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/54994044">link</a></li>
<li>局部 static 变量只被初始化一次，生命周期是从创建到程序结束。相比全局 static 变量只是作用域不是全局。</li>
<li>如果全局变量仅在单个函数中使用，则可以将这个变量改为该函数的静态局部变量。</li>
<li>全局变量，静态局部变量，静态全局变量都存在全局静态存储区。</li>
<li>函数中必须要使用 statci 变量的情况：当某个函数返回值为指针类型时，则必须是 static 的局部变量的地址作为返回值，因为他的生命周期是整个程序运行期间。</li>
<li>static 全局变量限定作用范围为定义该变量的文件。</li>
<li>子类访问父类定义的 static 成员变量或函数<code>Son::Parent::xxx()</code></li>
<li>static 存储在全局静态存储区，因此父类中定义的 static 变量由所有子类父类对象共享。</li>
<li>作用<ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ul>
</li>
<li>伪单例： 共享一个变量，但多线程不安全</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::vector&lt;<span class="type">bool</span>&gt;&amp; <span class="title">is_file</span><span class="params">()</span> </span>&#123;                                                                                                                                                                                <span class="type">static</span> std::vector&lt;<span class="type">bool</span>&gt; ftype;                                                                                                                                                                                    <span class="keyword">return</span> ftype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">is_file</span>() = &#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>fps control</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __FPS_CONTROL__(fps)                                                   \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    static thread_local auto start_time = std::chrono::steady_clock::now();    \</span></span><br><span class="line"><span class="meta">    auto end_time = std::chrono::steady_clock::now();                          \</span></span><br><span class="line"><span class="meta">    auto time_us = std::chrono::duration_cast<span class="string">&lt;std::chrono::microseconds&gt;</span>(      \</span></span><br><span class="line"><span class="meta">                       end_time - start_time)                                  \</span></span><br><span class="line"><span class="meta">                       .count();                                               \</span></span><br><span class="line"><span class="meta">    int sleep_us = static_cast<span class="string">&lt;int&gt;</span>(1000.0 * 1000.0 / fps) - time_us;          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (sleep_us &gt; 0) &#123;                                                        \</span></span><br><span class="line"><span class="meta">      std::this_thread::sleep_for(std::chrono::microseconds(sleep_us));        \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    start_time = std::chrono::steady_clock::now();                             \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol>
<li><code>全局作用域</code></li>
<li><code>局部作用域</code></li>
<li><code>语句作用域</code></li>
<li><code>类作用域</code></li>
<li><code>命名空间作用域</code></li>
<li><code>文件作用域</code></li>
</ol>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><ol>
<li>声明</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// prototype</span></span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);   <span class="comment">// 指针pf指向的函数， 输入参数为int,返回值为double</span></span><br><span class="line">pf = cal;    <span class="comment">// 指针赋值</span></span><br></pre></td></tr></table></figure>

<ol>
<li>作为函数参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span>;  <span class="comment">// 函数指针作为参数传递</span></span><br><span class="line"><span class="type">double</span> y = (*pf)(<span class="number">5</span>);   <span class="comment">// 通过指针调用， 推荐的写法</span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">pf</span>(<span class="number">5</span>);     <span class="comment">// 这样也对， 但是不推荐这样写</span></span><br></pre></td></tr></table></figure>

<h3 id="typedef-传统"><a href="#typedef-传统" class="headerlink" title="typedef(传统)"></a>typedef(传统)</h3><ol>
<li>任何声明变量的语句前面加上 typedef 之后，原来是变量的都变成一种类型。不管这个声明中的标识符号出现在中间还是最后。</li>
<li>作用：<ul>
<li>促进跨平台开发</li>
<li>定义易于记忆的类型名</li>
</ul>
</li>
<li>使用：<ul>
<li><code>typedef int* IntPtr; int x = 5; IntPtr = &amp;x; *IntPtr = 1;</code></li>
<li><code>typedef void (*call_back)(int)； void add_one(int i) &#123;return i+1&#125;; call_back = add_one; call_back(2);</code> call_back 声明为函数指针</li>
</ul>
</li>
</ol>
<h3 id="using-新标准"><a href="#using-新标准" class="headerlink" title="using(新标准)"></a>using(新标准)</h3><ol>
<li><code>using IntPtr = int*;int x = 5; IntPtr = &amp;x; *IntPtr = 1;</code></li>
<li><code>using V1F = std::vector&lt;float&gt;; using V2F = std::vector&lt;V1F&gt;;</code></li>
<li><code>using CallBack = void (*)(int)；// using CallBack = decltype((add_one)); void add_one(int i) &#123;return i+1&#125;; CallBack call_back = add_one; call_back(2);</code></li>
</ol>
<h3 id="overload-重载-and-override-or-overwrite（覆盖或重写）-link"><a href="#overload-重载-and-override-or-overwrite（覆盖或重写）-link" class="headerlink" title="overload (重载)and override or overwrite（覆盖或重写） link"></a>overload (重载)and override or overwrite（覆盖或重写） <a target="_blank" rel="noopener" href="https://blog.csdn.net/Zeno_wrj/article/details/110478916">link</a></h3><ol>
<li>类内：Overloading occurs when two or more methods in one class have the same method name but different parameters.</li>
<li>类间：Overriding or overwrite means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class.</li>
</ol>
<h3 id="class-和-struct-区别"><a href="#class-和-struct-区别" class="headerlink" title="class 和 struct 区别"></a>class 和 struct 区别</h3><ol>
<li>C++中的 struct 对 C 中的 struct 进行了扩充，可以有成员函数，可以被继承，可以有多态。</li>
<li>struct 和 class 最大的区别是访问权限，struct 成员默认是 public 的，class 默认是 private，struct 继承默认是 public，class 默认是 private。</li>
<li>class 可以定义模板参数，就像 typename，而 struct 不行。</li>
</ol>
<h3 id="template-定义时的-typename-和-class-区别"><a href="#template-定义时的-typename-和-class-区别" class="headerlink" title="template 定义时的 typename 和 class 区别"></a>template 定义时的 typename 和 class 区别</h3><ol>
<li>最早使用的 class 可能会造成概念上的混淆，后面加上了 typename 替代 class。</li>
</ol>
<h3 id="new-delete-和-malloc-free-区别"><a href="#new-delete-和-malloc-free-区别" class="headerlink" title="new&#x2F;delete 和 malloc&#x2F;free 区别"></a>new&#x2F;delete 和 malloc&#x2F;free 区别</h3><ol>
<li>malloc&#x2F;free 是 c++&#x2F;c 标准库函数，new&#x2F;delete 是 C++运算符，都可以用于动态内存申请和内存释放。</li>
<li>new 一个对象时会调用构造函数，delete 一个对象时会调用析构函数。</li>
<li>对于非内部累来说，malloc&#x2F;free 无法满足在对象创建时执行构造函数，在对象销毁时调用析构函数。</li>
<li>由于内部数据类型的对象没有构造和析构的过程，对他们而言 malloc&#x2F;free 和 new&#x2F;delete 是等价的。</li>
<li>为什么需要 malloc 和 free，因为 C++中经常调用 c 函数，而 c 只能用 malloc 和 free 管理动态内存（堆上）。</li>
</ol>
<h3 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h3><h3 id="for-each-any-of"><a href="#for-each-any-of" class="headerlink" title="for each any_of"></a>for each any_of</h3><h3 id="rang-based-for-loop"><a href="#rang-based-for-loop" class="headerlink" title="rang-based for loop"></a>rang-based for loop</h3><h3 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h3><ol>
<li><code>std::get&lt;0&gt;(std::make_tuple(3.8, &#39;A&#39;, &quot;Lisa Simpson&quot;)) </code></li>
<li><code>float a; char b; string c; std::tie(a, b, c) = (std::make_tuple(3.8, &#39;A&#39;, &quot;Lisa Simpson&quot;);</code></li>
<li><code>auto [a, b ,c] = (std::make_tuple(3.8, &#39;A&#39;, &quot;Lisa Simpson&quot;);</code></li>
</ol>
<h3 id="std-tie"><a href="#std-tie" class="headerlink" title="std::tie"></a>std::tie</h3><ol>
<li>创建 tuple 的左值引用</li>
<li>可以用来解 tuple</li>
<li>c++17 之后可以被 structured bindings 替代</li>
</ol>
<h3 id="Structured-Bindings-c-17"><a href="#Structured-Bindings-c-17" class="headerlink" title="Structured Bindings c++17"></a>Structured Bindings c++17</h3><ol>
<li><code>const auto &amp;[elem1, elme2] = some_thing;</code></li>
<li><code>auto [ gpa2, grade2, name2 ] = return std::make_tuple(3.8, &#39;A&#39;, &quot;Lisa Simpson&quot;);</code></li>
<li>类似引用，结构化绑定是既存对象的别名。不同于引用的是，结构化绑定的类型不必为引用类型。</li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/structured_binding">reference</a></li>
</ol>
<h3 id="concepts-c-20"><a href="#concepts-c-20" class="headerlink" title="concepts c++20"></a>concepts c++20</h3><h3 id="modules-c-20"><a href="#modules-c-20" class="headerlink" title="modules c++20"></a>modules c++20</h3><h3 id="string-view-c-17"><a href="#string-view-c-17" class="headerlink" title="string_view c++17"></a>string_view c++17</h3><h3 id="std-format-c-20"><a href="#std-format-c-20" class="headerlink" title="std::format c++20"></a>std::format c++20</h3><h3 id="ranges-c-20"><a href="#ranges-c-20" class="headerlink" title="ranges c++20"></a>ranges c++20</h3><h3 id="fold-expressions"><a href="#fold-expressions" class="headerlink" title="fold expressions"></a>fold expressions</h3><h3 id="std-exchange"><a href="#std-exchange" class="headerlink" title="std::exchange()"></a>std::exchange()</h3><h3 id="deprecated-attribute"><a href="#deprecated-attribute" class="headerlink" title="[[deprecated]] attribute"></a>[[deprecated]] attribute</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[deprecated]]</span></span><br><span class="line">void old_method();</span><br><span class="line"><span class="string">[[deprecated(&quot;Use new_method instead&quot;)]]</span></span><br><span class="line">void legacy_method();</span><br></pre></td></tr></table></figure>

<h3 id="c-中的-const-和-c-中的-const-区别"><a href="#c-中的-const-和-c-中的-const-区别" class="headerlink" title="c 中的 const 和 c++中的 const 区别"></a>c 中的 const 和 c++中的 const 区别</h3><ol>
<li>c 语言中只有 enum 能实现真正的常量</li>
</ol>
<h3 id="macro-和-inline"><a href="#macro-和-inline" class="headerlink" title="macro 和 inline"></a>macro 和 inline</h3><h3 id="const-关键字作用"><a href="#const-关键字作用" class="headerlink" title="const 关键字作用"></a>const 关键字作用</h3><h3 id="default，-delete，override，final，noexcept"><a href="#default，-delete，override，final，noexcept" class="headerlink" title="default， delete，override，final，noexcept"></a>default， delete，override，final，noexcept</h3><ol>
<li><code>final</code>在基类中指定无法在派生类中重写的虚函数。还可以指定无法继承的类。</li>
<li>当使用 default 或者 delete 定义构造，析构，复制构造，赋值，move…其中一个时，也需要定义其他的。</li>
</ol>
<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><ol>
<li>explicit 只能用来修饰类构造函数。作用是声明类构造函数是显示调用的，不能隐式调用。</li>
<li>只能显示使用<code>ClassXX a(args)</code>来创建对象，不能使用<code>ClassXX a = args</code>来隐士调用构造函数。</li>
<li>作为函数参数也必须使用<code>ClassXX(args)</code>，不能使用<code>args</code>隐式调用构造函数。</li>
<li>能用就用。</li>
</ol>
<h3 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h3><ol>
<li>接口类(基类)的析构函数需要为 virtual,这样才能正常调用子类的析构函数，如果不为 virtual，那么只会调用基类的析构函数，不会调用子类的。</li>
</ol>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ol>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ol>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><ol>
<li>获取变量的类型。<code>int x; decltype(x) y; // y is int</code></li>
<li>可以用于匿名结构体。</li>
</ol>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><ol>
<li>常量表达式是指<code>值不会改变</code>并且在<code>编译过程中就能计算结果</code>的表达式</li>
<li>const int sz &#x3D; get_size(); sz 不是常量表达式，sz 只是常量，因为值在编译期才确定</li>
<li>声明为 constexpr 的变量一定是个常量，并且必须用常量表达式初始化。</li>
</ol>
<h3 id="add-pointer-and-is-pointer-remove-pointer"><a href="#add-pointer-and-is-pointer-remove-pointer" class="headerlink" title="add pointer and is pointer remove_pointer"></a>add pointer and is pointer remove_pointer</h3><ol>
<li>都是类模板，定义在 std 中</li>
<li><code>add_pointer&lt;T&gt;</code>：T 可以是具体类型也可以是类型引用。获取类型的指针，保存在 type 成员变量里。一般和 typede 一起使用<code>typedef std::add_pointer&lt;x&gt;::type IntPtr; IntPtr i;</code></li>
</ol>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><ol>
<li>std::function 是通用多态函数封装器。</li>
<li>定义：<code>template &lt; class R, class... Args&gt; class function&lt;R(Args...)</code> R 为返回类型，Args 为参数。</li>
<li>例子：<code>void p(int i) &#123; cout &lt;&lt; i;&#125;; std::fuction&lt;void&lt;int&gt;&gt; f = p; f(i);</code></li>
<li>可用来实现函数回调</li>
</ol>
<h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h3><h2 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a>Design Patterns</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ol>
<li>目的：将对象的创建与对象的使用解耦。</li>
<li><code>简单工厂函数</code> 将对象的创建放入到统一工厂函数中，根据类型判断具体创建哪一种类型对象。相当于将耦合问题从使用中转移到工厂函数。扩展性差，每增加一个产品就要修改工厂函数。</li>
<li><code>工厂方法模式</code> 每个产品都有一个工厂函数，相当于将耦合从总的工厂函数中转移到各个产品的工厂函数中，问题：使用时需要包含各个工厂头文件。</li>
<li><code>抽象工厂模式</code> 同工厂方法模式，只不过每一个具体工厂可以可以调不同接口（不是同一个接口传参数）创建不同的产品。</li>
<li><code>反射，依赖注入</code> 由类名来创建对象。相当于工厂方法模式+单例模式。全局有一个总的工厂，工厂里有保存产品类型及其工厂函数的 map 表(使用到函数指针)，每个产品都要有一个工厂，并且需要注册（依赖注入）到总的工厂 map 表中。解决了工厂方法模式中使用问题。map 可以使用全局变量，注册函数写成类的静态函数，就不需要专门设计一个总的工厂类。总工厂生产的产品不由总工厂控制，而是交给子工厂控制，这叫<code>控制反转</code>，将子工厂通过注册接口传入到总工厂中，这叫<code>依赖注入</code></li>
<li><code>模板工厂模式</code></li>
</ol>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/11524401.html">factory method</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/K346K346/article/details/51698184">reflection</a></li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol>
<li>目的： 保证一个类只有一个实例，并且提供一个访问它的全局访问点，该实例被所有程序模块共享</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37469260">reference</a></li>
<li>code</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() &#123; &#125;;  <span class="comment">// 私有构造函数，拷贝构造函数和赋值函数，防止创建对象。</span></span><br><span class="line">	~<span class="built_in">Singleton</span>() &#123; &#125;;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton&amp; <span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton instance;  <span class="comment">// 使用local static对象，只在第一次访问get_instance才创建</span></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h2 id="Program-with-C"><a href="#Program-with-C" class="headerlink" title="Program with C"></a>Program with C</h2><h2 id="接口实现分离"><a href="#接口实现分离" class="headerlink" title="接口实现分离"></a>接口实现分离</h2><ol>
<li><code>Pimplldiom</code>(防火墙技术，代理模式？(未提供一个抽象接口)) 将实现细节隐藏于指针背后，比如：分成两个类，一个负责提供接口，一个负责提供实现。负责提供实现的类的对象作为负责提供接口类的私有成员。这种方式只能不能像工厂函数一样由多种实现，因为类中写死了一种实现方式。</li>
<li><code>Object Inerface</code> 将接口定义为抽象类，派生类实现这些借口。类似工厂函数(创建型设计模式)。</li>
</ol>
<h2 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a>命令行参数解析</h2><ol>
<li>glib <a target="_blank" rel="noopener" href="https://github.com/kiwibrowser/src/blob/master/third_party/wds/src/mirac_network/gst-test.cpp#L67">usage</a><a target="_blank" rel="noopener" href="https://gstreamer.freedesktop.org/documentation/application-development/basics/init.html?gi-language=c#the-goption-interface">link1</a> <a target="_blank" rel="noopener" href="https://people.gnome.org/~ryanl/glib-docs/glib-Commandline-option-parser.html">link2</a></li>
<li>getopt: see how to use with emacs woman; <a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI/blob/master/tools/Vitis-AI-Library/usefultools/src/xir2elf.cpp#L38">link1</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jarro2783/cxxopts">cxxopts</a>: only include header</li>
</ol>
<h3 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TAOKONG1017/article/details/79561856">reference</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/AnthonyCalandra/modern-cpp-features">modern-cpp-features</a></li>
</ol>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2022/04/02/gtest/" rel="bookmark">gtest</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/09/13/Plugin-System/" rel="bookmark">plugins</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/07/20/Cpp-concurrency-in-action/" rel="bookmark">Cpp-concurrency-in-action</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/10/06/Eclipse-Cpp-IDE-on-Windows10/" rel="bookmark">Eclipse Cpp</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/08/18/Bjarny-Stroustrup-Cpp/" rel="bookmark">Bjarny Stroustrup cpp</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>贾夕阳
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jiaxiyang.github.io/2021/09/20/Cpp-grammar/" title="Cpp grammar">https://jiaxiyang.github.io/2021/09/20/Cpp-grammar/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Cpp/" rel="tag"><i class="fa fa-tag"></i> Cpp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/13/Plugin-System/" rel="prev" title="plugins">
      <i class="fa fa-chevron-left"></i> plugins
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/30/Amazing-emacs/" rel="next" title="Amazing emacs">
      Amazing emacs <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NOTE"><span class="nav-text">NOTE:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#basic-concept"><span class="nav-text">basic concept</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="nav-text">参考代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute"><span class="nav-text">attribute</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Note"><span class="nav-text">Note</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-chrono-link"><span class="nav-text">性能测试 chrono link</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-text">数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fold"><span class="nav-text">fold</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#func-%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-text">__func__函数名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RVO-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96-effective-modern-c-166-%E9%A1%B5"><span class="nav-text">RVO 返回值优化 effective modern c++ 166 页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcc-O0-O1-O2-O3-%E5%9B%9B%E7%BA%A7%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9%E5%8F%8A%E6%AF%8F%E7%BA%A7%E5%88%86%E5%88%AB%E5%81%9A%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96"><span class="nav-text">gcc -O0 -O1 -O2 -O3 四级优化选项及每级分别做什么优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GDB-%E4%BD%BF%E7%94%A8"><span class="nav-text">GDB 使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input-and-output"><span class="nav-text">input and output</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0-%E5%92%8C-%E5%BA%93"><span class="nav-text">标准函数 和 库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-text">第三方库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ideas"><span class="nav-text">ideas</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%88%99"><span class="nav-text">原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-%E5%AF%B9%E9%BD%90%E5%92%8C%E8%A1%A5%E9%BD%90"><span class="nav-text">struct 对齐和补齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-language-features"><span class="nav-text">C++ language features</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency-Parallelism-and-Async"><span class="nav-text">Concurrency, Parallelism and Async</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-concurrency-development"><span class="nav-text">C++ concurrency development</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOP"><span class="nav-text">OOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generic-Programming"><span class="nav-text">Generic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Template"><span class="nav-text">Template</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%B5%8C%E5%A5%97"><span class="nav-text">模板嵌套</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RAII-Resource-Acquisition-Is-Initalization"><span class="nav-text">RAII Resource Acquisition Is Initalization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8Ccopy-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Ccopy-%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cmove-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cmove-%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数，析构函数，copy 构造函数，copy 赋值构造函数，move 构造函数，move 赋值构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="nav-text">类对象内存分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">虚析构函数的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">构造析构顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Rule-of-Three-or-Five-after-c-11"><span class="nav-text">The Rule of Three or Five(after c++11)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Rule-of-Zero"><span class="nav-text">The Rule of Zero</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BD%E7%9A%84-value-semantic-C-%E7%B1%BB"><span class="nav-text">两种设计良好的 value-semantic C++类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-ref-%E4%B8%8E-reference-wrapper"><span class="nav-text">std::ref 与 reference_wrapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#move"><span class="nav-text">move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward"><span class="nav-text">forward</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC-lvalue-%E5%8F%B3%E5%80%BC-rvalue"><span class="nav-text">左值(lvalue) 右值(rvalue)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rvalue-reference-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">&amp;&amp; rvalue reference 右值引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lifetime-and-Allocation-Deallocation"><span class="nav-text">Lifetime and Allocation Deallocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Smart-Pointers"><span class="nav-text">Smart Pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-ptr"><span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr"><span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make-shared-and-make-unique"><span class="nav-text">make_shared and make_unique</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak-ptr"><span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-enable-shared-from-this"><span class="nav-text">std::enable_shared_from_this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cast"><span class="nav-text">Cast</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97-const-cast-%E5%B8%B8%E9%87%8F%E6%80%A7%E8%BD%AC%E9%99%A4-dynamic-cast-%E5%90%91%E4%B8%8B%E5%AE%89%E5%85%A8%E8%BD%AC%E5%9E%8B-reinterpret-cast-%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E8%BD%AC%E5%9E%8B-static-cast-%E9%9D%99%E6%80%81%E8%BD%AC%E5%9E%8B"><span class="nav-text">四种关键字: const_cast, 常量性转除;dynamic_cast, 向下安全转型;reinterpret_cast, 重新解释转型; static_cast, 静态转型;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zero-Cost-Abstract"><span class="nav-text">Zero Cost Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambdas"><span class="nav-text">Lambdas</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Macros"><span class="nav-text">Macros</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#define"><span class="nav-text">#define</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory"><span class="nav-text">Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">内存分配方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">内存管理方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multi-Thread"><span class="nav-text">Multi Thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Small-Module"><span class="nav-text">Small Module</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89"><span class="nav-text">值语义与引用语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">操作符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef-%E4%BC%A0%E7%BB%9F"><span class="nav-text">typedef(传统)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-%E6%96%B0%E6%A0%87%E5%87%86"><span class="nav-text">using(新标准)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overload-%E9%87%8D%E8%BD%BD-and-override-or-overwrite%EF%BC%88%E8%A6%86%E7%9B%96%E6%88%96%E9%87%8D%E5%86%99%EF%BC%89-link"><span class="nav-text">overload (重载)and override or overwrite（覆盖或重写） link</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-%E5%92%8C-struct-%E5%8C%BA%E5%88%AB"><span class="nav-text">class 和 struct 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#template-%E5%AE%9A%E4%B9%89%E6%97%B6%E7%9A%84-typename-%E5%92%8C-class-%E5%8C%BA%E5%88%AB"><span class="nav-text">template 定义时的 typename 和 class 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-delete-%E5%92%8C-malloc-free-%E5%8C%BA%E5%88%AB"><span class="nav-text">new&#x2F;delete 和 malloc&#x2F;free 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">函数调用的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each-any-of"><span class="nav-text">for each any_of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rang-based-for-loop"><span class="nav-text">rang-based for loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-tuple"><span class="nav-text">std::tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-tie"><span class="nav-text">std::tie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Structured-Bindings-c-17"><span class="nav-text">Structured Bindings c++17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concepts-c-20"><span class="nav-text">concepts c++20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#modules-c-20"><span class="nav-text">modules c++20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-view-c-17"><span class="nav-text">string_view c++17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-format-c-20"><span class="nav-text">std::format c++20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ranges-c-20"><span class="nav-text">ranges c++20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fold-expressions"><span class="nav-text">fold expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-exchange"><span class="nav-text">std::exchange()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deprecated-attribute"><span class="nav-text">[[deprecated]] attribute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E4%B8%AD%E7%9A%84-const-%E5%92%8C-c-%E4%B8%AD%E7%9A%84-const-%E5%8C%BA%E5%88%AB"><span class="nav-text">c 中的 const 和 c++中的 const 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#macro-%E5%92%8C-inline"><span class="nav-text">macro 和 inline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="nav-text">const 关键字作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default%EF%BC%8C-delete%EF%BC%8Coverride%EF%BC%8Cfinal%EF%BC%8Cnoexcept"><span class="nav-text">default， delete，override，final，noexcept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit"><span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual"><span class="nav-text">virtual</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-text">友元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype"><span class="nav-text">decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr"><span class="nav-text">constexpr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-pointer-and-is-pointer-remove-pointer"><span class="nav-text">add pointer and is pointer remove_pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-function"><span class="nav-text">std::function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-atomic"><span class="nav-text">std::atomic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Design-Patterns"><span class="nav-text">Design Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Reference"><span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-text">代理模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Program-with-C"><span class="nav-text">Program with C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="nav-text">接口实现分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-text">命令行参数解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference-1"><span class="nav-text">Reference</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="贾夕阳"
      src="/images/coder2.jpg">
  <p class="site-author-name" itemprop="name">贾夕阳</p>
  <div class="site-description" itemprop="description">深度学习/自动驾驶/C++/性能优化</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jiaxiyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiaxiyang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/2023/09/21/test/" title="2023&#x2F;09&#x2F;21&#x2F;test&#x2F;">test</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/09/21/assembly/" title="2023&#x2F;09&#x2F;21&#x2F;assembly&#x2F;">assembly</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/09/20/QEMU/" title="2023&#x2F;09&#x2F;20&#x2F;QEMU&#x2F;">QEMU</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/09/13/Reverse-Engineering/" title="2023&#x2F;09&#x2F;13&#x2F;Reverse-Engineering&#x2F;">Reverse-Engineering</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/09/04/go/" title="2023&#x2F;09&#x2F;04&#x2F;go&#x2F;">go</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贾夕阳</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">347k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:16</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://jiaxiyang.github.io/2021/09/20/Cpp-grammar/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'hbdf2zNhxCCzlSuodiOKirnE-gzGzoHsz',
      appKey     : 'gJuRc9Mu4JIB0czCtRefSodC',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
