<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0-rc2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiaxiyang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="顶层概念">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust grammar">
<meta property="og:url" content="https://jiaxiyang.github.io/2021/07/11/Rust-grammar/index.html">
<meta property="og:site_name" content="Xiyang">
<meta property="og:description" content="顶层概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/2d/91/2d36b45f6905a13a310e6447778ca391.jpg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/SER9L29WQ0icrEMnzjvMNTzSZbaPboUnMUFBia3wHebkuX9e6Ah70g3CKC9v8bVicGeGJEq0Dd38AnesVU5ffXmdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="article:published_time" content="2021-07-11T10:34:03.000Z">
<meta property="article:modified_time" content="2023-09-24T04:15:43.209Z">
<meta property="article:author" content="贾夕阳">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.infoq.cn/resource/image/2d/91/2d36b45f6905a13a310e6447778ca391.jpg">

<link rel="canonical" href="https://jiaxiyang.github.io/2021/07/11/Rust-grammar/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Rust grammar | Xiyang</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WGS6S6YFJ6"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-WGS6S6YFJ6');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xiyang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Think twice, code once!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">167</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">44</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">55</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiaxiyang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiaxiyang.github.io/2021/07/11/Rust-grammar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/coder2.jpg">
      <meta itemprop="name" content="贾夕阳">
      <meta itemprop="description" content="深度学习/自动驾驶/C++/性能优化">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiyang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust grammar
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-11 18:34:03" itemprop="dateCreated datePublished" datetime="2021-07-11T18:34:03+08:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-24 12:15:43" itemprop="dateModified" datetime="2023-09-24T12:15:43+08:00">2023-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Program/" itemprop="url" rel="index"><span itemprop="name">Program</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Program/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/11/Rust-grammar/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/11/Rust-grammar/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="顶层概念"><a href="#顶层概念" class="headerlink" title="顶层概念"></a><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM">顶层概念</a></h2><p><img src="https://static001.infoq.cn/resource/image/2d/91/2d36b45f6905a13a310e6447778ca391.jpg" alt="概念层次图"></p>
<span id="more"></span>

<h2 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h2><ol>
<li>unimplemented! and todo!来表明函数未实现，先跳过</li>
<li>indent with four spaces, not a tab</li>
<li>Most lines of Rust code end with a semicolon(;)</li>
<li><code>println!()</code> ! means call macro, not a function</li>
<li>Cargo is Rust’s build system and package manager.</li>
<li>Cargo expects your source files to live inside the src directory. The top-level project directory is just for README files, license information, configuration files, and anything else not related to your code.</li>
<li><code>cargo run</code> Compile the code and then run the resulting executable all in one command.</li>
<li><code>cargo check</code> is much faster than <code>cargo build</code></li>
<li><code>cargo build --release</code> compile the project with optimizations. Run faster but compile slower.</li>
<li>The <code>main</code> function is the entry point into the program.</li>
<li>The <code>fn</code> syntax declares a new function, the parentheses, <code>()</code>, indicate there are no parameters, and the curly bracket, <code>&#123;</code>, starts the body of the function.</li>
<li><code>let</code> is used to create a variable. In Rust, variables are immutable by default.</li>
<li><code>String::new()</code> An associated function is implemented on a type, in this case String, rather than on a particular instance of a String. Some languages call this a static method. This new function creates a new, empty string. You’ll find a new function on many types, because it’s a common name for a function that makes a new value of some kind.</li>
<li><code>&#123;&#125;</code> is a place holder when using <code>println!</code></li>
<li>Crate is a coleection of Rust source code files.</li>
<li>Cargo.toml dependencies rand &#x3D; “0.5.5”; In this case, we’ll specify the rand crate with the semantic version specifier 0.5.5. Cargo understands Semantic Versioning (sometimes called SemVer), which is a standard for writing version numbers. The number 0.5.5 is actually shorthand for ^0.5.5, which means “any version that has a public API compatible with version 0.5.5.”</li>
<li><code>cargo doc --open</code> It will build documentation provided by all of your dependencies locally and open it in your browser.</li>
<li><code>match</code> is like <code>switch</code> in C++</li>
<li>shallow copy, deep copy(clone), move(let s2 &#x3D; s1; &#x2F;&#x2F; s1 is invailid)</li>
<li>Differences Between Immutable Variables and Constants:<ul>
<li>You declare constants using the const keyword instead of the let keyword, and the type of the value must be annotated.</li>
<li>Constants can be declared in any scope, including the global scope</li>
<li>Constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</li>
</ul>
</li>
<li>trait can add some useful functions for user’s own struct.</li>
<li>trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。</li>
<li>Rust 编译时会将泛型代码单态化(monomorphization)来保证效率，单态化是指编译时用具体类型来填充泛型。</li>
<li>用户会将重复代码泛化（抽象），编译器会将泛化代码具体化。</li>
<li>trait 类似其他语言中接口(interfaces)功能，虽然有些不同。</li>
<li>只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。</li>
<li>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。当在 debug 模式编译时，Rust 检查这类问题并使程序 panic</li>
<li>Rust 的浮点数默认类型是 f64。数字类型默认是 i32。</li>
<li>Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。</li>
<li>Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</li>
<li><code>tuple:</code> <code>let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; //结构 let five_hundred = tup.0;</code></li>
<li><code>struct:</code></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>), <span class="comment">//实例中字段的顺序不需要和它们在结构体中声明的顺序一致</span></span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）因为它们类似于 ()，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。</li>
<li>方法与函数类似：它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>impl 块的另一个有用的功能是：允许在 impl 块中定义 不 以 <code>self</code> 作为参数的函数。这被称为 <code>关联函数（associated functions）</code>，因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 String::from 关联函数了。使用结构体名和 <code>::</code> 语法来调用关联函数。</li>
</ol>
<h2 id="Project-Manage"><a href="#Project-Manage" class="headerlink" title="Project Manage"></a>Project Manage</h2><ol>
<li>包<code>packages</code>: Cargo 的一个功能，允许你构建、测试和分享 crate</li>
<li><code>crates</code>: 一个模块的<code>树形</code>结构，它形成了库或二进制项目。</li>
<li>模块<code>modules and use</code>: 允许你控制作用域和路径的私有性。</li>
<li>路径<code>path</code>: 一个命名机结构体、函数或模块等项的方式。</li>
<li>在 Rust 中，代码包也被称为 crates</li>
<li>一个包中可以包含多个二进制 crate 和一个可选的 crate 库。</li>
<li>包中至少包含一个 crate，无论是库还是二进制，至多包含一个库 crate</li>
<li><code>cargo new</code>会创建一个包。</li>
<li>Cargo 准守一个约定： <code>src/main.rs</code>就是一个与包同名的二进制 crate 的 crate 根。同理，<code>src/lib.rs</code>是库 crate 的 crate 根。如果同时包含，则它有两个 crate。</li>
<li>通过将文件放在<code>src/bin</code>目录下，一个包可以拥有多个二进制 crate：每个<code>src/bin</code>下的文件都会被编译成一个独立的二进制 crate。</li>
<li>模块让我们可以将一个 crate 中的代码进行分组，以提高重用性。</li>
<li><code>模块的定义</code>是以<code>mod</code>(module)关键字为起始，然后指定模块的名字，并且用或花括号包围模块的主题。</li>
<li><code>模块的声明</code>是以<code>mod</code>为起始，指定模块名字，以<code>;</code>结尾，不带有花括号。在与模块名同名的.rs 文件中定义该模块。</li>
<li>模块一般是在上一级文件声明，不是在本文件中声明，如可以在 lib.rs 中声明模块，然后在相应.rs 文件中定义该模块。</li>
<li>crate 的组织结构类似于文件系统的目录，被称为模块树(module tree)。</li>
<li>Rust 通过路径来查找一个项的位置。</li>
<li><code>绝对路径(absolute path)</code> 从 crate 根开始，以 crate 名或者字面值<code>crate</code>开头。</li>
<li><code>相对路径(relative path)</code> 从当前模块开始，以<code>self</code>、<code>super</code>或当前模块的表示符开头。</li>
<li>只有在同一 crate 中才能使用<code>crate::</code>关键字为起始的绝对路径。</li>
<li>模块不仅对你组织代码很有用。它们还定义了 Rust 的私有性边界：这条界限不允许外部代码了解、调用和依赖被封装的实现细节。</li>
<li>Rust 中默认所有项(函数、方法、结构体、枚举、模块、和常量）都是私有的。</li>
<li>项是指：函数、方法、结构体、枚举、模块和常量。</li>
<li>父模块中的项不能使用子模块中的私有项，但是子模块可以使用它们父模块中的项。</li>
<li>Rust 通过这种方式来实现模块系统功能，因此隐藏内部实现细节，这样你就知道可以更改内部代码的哪部分而不会破坏外部代码。</li>
<li>可以使用<code>super</code>开头来构建父模块开始的相对路径。类似于文件系统的<code>..</code>语法。</li>
<li>如果请偶们将枚举设置为公有，则它的所有成员都将变为共有。</li>
<li>在作用域中增加<code>use</code>类似于在文件系统中创建软连接。</li>
<li>使用<code>use</code>引入结构体、枚举和其他项时，习惯是指定它们的完整路径。</li>
<li>使用<code>use</code>将两个同名类型引入同意作用域的一个解决办法：在类型后面使用<code>as</code>指定一个新的本地名称或者别名。</li>
<li><code>use std::&#123;cmp::Ordering, io&#125;;</code>使用嵌套路径减少 use 的使用。</li>
<li><code>use std::io:*</code> 将<code>std::io</code>中定义的所有公有项引入当前作用域。使用时要多加小心，常用于测试模块<code>tests</code>中。</li>
<li>Rust 将 package 分成多个 crate，将 crate 分成模块，通过绝对或相对路径从一个模块引用另一个模块。</li>
<li>Cargo 提供了叫工作空间<code>workspaces</code>的功能，它可以帮助我们管理多个相关的协同开发的包。</li>
<li>工作空间是一系列共享同样的 cargo.lock 和输出目录的包。</li>
<li>工作空间顶级目录中的 Cargo.toml 中不包含<code>[package]</code>等信息，相反，它以<code>[workspace]</code>部分作为开始。</li>
<li>工作空间在顶级目录有一个<code>target</code>目录，<code>member</code>并没有自己的 target 目录。通过共享的 target 目录，工作空间可以避免其他 crate 多余的重复构建。</li>
<li>cargo 不假定工作空间中的 crates 包会相互依赖，所以需要明确表明工作空间中 crate 包的依赖关系。一个包用到了其他包，需要在该包的 Cargo.toml 文件<code>[dependencies]</code>域中加入依赖</li>
<li>工作空间只在根目录有一个 Cargo.lock，而不是在每一个 crate（就当是 packge)目录都有 Cargo.lock。这确保了所有的 crate 都使用完全相同版本的依赖。也节省了空间，避免多个拷贝。</li>
<li>Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。</li>
</ol>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21820917">类型大小</a></li>
<li>Rust 中有一个重要的 trait Sized，可以用于区分一个类型是不是 DST。所有的 DST 类型都不满足 Sized 约束。我们可以在泛型约束中使用 Sized、!Sized、?Sized 三种写法。</li>
<li>Rust 还支持 0 大小类型（Zero Sized Type）。 () 类型和空结构体类型，都是 0 大小类型。</li>
</ol>
<h2 id="Ownership-所有权"><a href="#Ownership-所有权" class="headerlink" title="Ownership 所有权"></a>Ownership 所有权</h2><ol>
<li>区分值(内存)和变量。</li>
<li>所有权是指： 每一个值都只有一个所有者（变量）, 当变量离开作用于时，值被丢弃。</li>
<li>当变量离开作用域，Rust 为我们调用一个特殊的函数 drop。在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）。</li>
<li><code>move:</code> <code>let s1 = String::from(&quot;hello&quot;); let s2 = s1;</code> 这个操作被称为移动（move），而不是浅拷贝。Rust 则认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。</li>
<li>Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。</li>
<li><code>clone:</code> 当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源</li>
<li><code>copy:</code> <code>let x = 5; let y = x;</code> x 在栈上，copy 操作。Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。</li>
<li>如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用。如 String 没有实现 Copy trait, i32 实现了。</li>
<li>Copy and Clone: Copy 是隐性调用，Clone 显性。 Copies happen implicitly, for example as part of an assignment y &#x3D; x. The behavior of Copy is not overloadable; it is always a simple bit-wise copy. Cloning is an explicit action, x.clone()</li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/beta/std/marker/trait.Copy.html">link</a> Clone is a supertrait of Copy, so everything which is Copy must also implement Clone. If a type is Copy then its Clone implementation only needs to return *self</li>
<li>Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。</li>
<li>任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line">&#125; <span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></span><br></pre></td></tr></table></figure>

<ol>
<li>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</li>
<li>将获取引用作为函数参数称为 借用（borrowing）。</li>
<li>可变引用有一个很大的限制：在特定作用域中的特定数据只能有一个可变引用。</li>
<li>也不能在拥有不可变引用的同时拥有可变引用。</li>
<li>Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</li>
<li>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。</li>
<li><code>另一个没有所有权的数据类型是 slice(部分引用 &amp;[T])。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合</code>。</li>
<li>“字符串 slice” 的类型声明写作 &amp;str, 字符串字面值就是 slice</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76945648">胖指针</a></li>
</ol>
<h2 id="Enums-枚举-and-模式匹配"><a href="#Enums-枚举-and-模式匹配" class="headerlink" title="Enums 枚举 and 模式匹配"></a>Enums 枚举 and 模式匹配</h2><ol>
<li>枚举允许你通过列举可能的 成员（variants） 来定义一个类型</li>
<li>用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li>结构体和枚举还有另一个相似点：就像可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法</li>
<li><code>Option</code> 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。</li>
<li>Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 Option<T>，而且它定义于标准库中，如下:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Option<T> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要 Option:: 前缀来直接使用 Some 和 None。即便如此 Option<T> 也仍是常规的枚举，Some(T) 和 None 仍是 Option<T> 的成员。</li>
<li>只要一个值不是 Option<T> 类型，你就可以安全的认定它的值不为空。</li>
<li>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于 if, 表达式必须返回一个布尔值，而 match 可以是任何类型的。</li>
<li>一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 Coin::Penny 而之后的 &#x3D;&gt; 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 1。每一个分支之间使用逗号<code>,</code>分隔。</li>
<li>如果想要在分支中运行多行代码，可以使用大括号<code>&#123;&#125;</code>。</li>
<li>匹配 Option<T>:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>Rust 中的匹配是 穷尽的（exhaustive）：必须穷举到最后的可能性来使代码有效。</li>
<li><code>_</code>通配符：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_u8_value</span> = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_u8_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 if let 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 match 强制要求的穷尽性检查。match 和 if let 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。</li>
<li>可以在 if let 中包含一个 else。else 块中的代码与 match 表达式中的 _ 分支块中的代码相同</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果你的程序遇到一个使用 match 表达起来过于啰嗦的逻辑，记住 if let 也在你的 Rust 工具箱中。</li>
</ol>
<h2 id="常见集合-collections"><a href="#常见集合-collections" class="headerlink" title="常见集合 collections"></a>常见集合 collections</h2><ol>
<li>不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。</li>
<li>vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。</li>
<li><code>let v: Vec&lt;i32&gt; = Vec::new();</code> 创建空的 vector</li>
<li>为了方便 Rust 提供了 vec! 宏。这个宏会根据我们提供的值来创建一个新的 Vec。<code>let v = vec![1, 2, 3];</code></li>
<li>对于新建一个 vector 并向其增加元素，可以使用 push 方法</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>访问 vector 中一个值的两种方式，索引语法或者 get 方法：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 &amp; 和 [] 返回一个引用；或者使用 get 方法以索引作为参数来返回一个 Option&lt;&amp;T&gt;。</li>
</ol>
<h2 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling 错误处理"></a>Error Handling 错误处理</h2><ol>
<li>当函数返回为 Result 时: <code>?</code>运算符放在 Result 之后的含义：如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序继续执行，如果是 Err，Err 中的值将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传递给调用者。</li>
<li><code>cargo clippy</code> 报更多的错误</li>
<li>Rust 将错误组合成两个主要类别，可恢复错误和不可恢复错误。</li>
<li>可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件。</li>
<li>不可恢复错误通常是 Bug 的同义词，比如访问超过数组结尾的位置。</li>
<li>大部分语言并不区分这两类错误，并采用类似异常这样方式统一处理他们。</li>
<li>Rust 没有异常，但是有可恢复错误<code>Result&lt;T, E&gt;</code>和不可恢复错误<code>panic!</code></li>
<li>执行 Rust 的<code>panic!</code>宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。</li>
<li>出现 panic 时，程序默认是<code>展开(unwinding)</code>，这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据。另一种选择是<code>终止(abort)</code>，这回不清理数据就退出程序。可以在 Cargo.toml 的[profile]部分增加<code>panic = &#39;abort&#39;</code>，可以由展开切换为终止。</li>
<li>使用<code>RUST_BACKTRACE</code>环境变量运行程序会得到一个 backtrace，backtrace 是一个执行到目前位置所有被调用的函数的列表。</li>
<li>Rust 的 backtrace 跟其他语言一样：阅读 backtrace 的<code>关键</code>是<code>从头开始读直到发现你自己编写的代码</code>，这就是问题的根源。<code>这一行往上是你的代码所调用的代码，往下则是调用你的代码的代码(栈)</code></li>
<li>为了获取带有详细信息的 backtrace，<code>必须是debug模式</code></li>
<li>Result 枚举的定义。<code>enum Result&lt;T, E&gt; &#123; Ok(T), Err(E), &#125;</code>，其中<code>T</code>代表返回的<code>Ok</code>成员中的<code>数据类型</code>，而<code>E</code>代表失败是返回<code>Err</code>成员中的错误的类型。</li>
<li>Result 常与 match 进行联合使用</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>); <span class="comment">// f值是Ok(file)或者是Err(error)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>unwrap</code>函数作用于 Result，如果 Result 的值是成员 OK，unwrap 会返回 Ok 中的值，如果是成员 Err，unwrap 会为我们调用<code>panic!</code></li>
<li><code>expect</code>与<code>unwrap</code>使用方式一样，<code>expect</code>用来调用<code>panic!</code>的错误信息将会作为参数传递给<code>expect</code>，而不像<code>unwrap</code>那样使用默认的<code>panic!</code>信息。<code>expect</code>更容易查找错误信息位置。</li>
<li>每一个 Result 都需要被处理，否则会出现警告。</li>
</ol>
<h2 id="Lifetimes-生命周期"><a href="#Lifetimes-生命周期" class="headerlink" title="Lifetimes 生命周期"></a>Lifetimes 生命周期</h2><ol>
<li><a target="_blank" rel="noopener" href="https://skyline75489.github.io/post/2017-7-27_rust_mm.html">link</a> rust 生命周期包含变量和引用，C++ RAII 主要是变量的生命周期管理，引用除了 smart pointer C++不负责检查引用的对象是否存在</li>
<li>生命周期的目的是<strong>避免悬垂指针</strong>. 生命周期帮助编译器执行一个简单的规则：引用不应该活得比所指对象长(no reference should outlive its referent)。</li>
<li>生命周期之所以如此令人困惑，其部分原因在于 Rust 的很多写作中，生命周期这个词被宽泛地用来指代三种不同的东西——<code>变量真实的生命周期、生命周期约束和生命周期标注</code>。 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6862976475860041741">link</a></li>
<li>只是用来检查生命周期关系，不影响生命周期</li>
<li>Lifetime annotations don’t change how long any of the references live. Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</li>
<li>One lifetime annotation by itself doesn’t have much meaning,</li>
<li><code>longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt;&amp;&#39;a str</code> 它的实际含义是 longest 函数保证返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致（x 作用域和 y 作用域重叠的那一部分）。并没有改变传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。</li>
<li><code>struct Test&lt;&#39;a&gt; &#123; part: &amp;&#39;a str, &#125;</code> Test 的实例不能比 part 字段中的引用存在的更久，Test 实例应先离开作用域。（后定义的存在的应更短）</li>
<li>每一个<code>引用</code>都有一个生命周期，我们需要为那些使用了引用的函数或者结构体指定生命周期。</li>
<li>只有引用才需要指定生命周期。</li>
<li>函数或方法的参数的生命周期被称为输入生命周期，二返回的生命周期被成为输出生命周期。</li>
<li>函数或方法生命周期省略规则，需满足下面三条且无冲突</li>
</ol>
<ul>
<li>每一个输入参数都有自己的生命周期参数</li>
<li>如果只有一个输入周期，那么它将被赋予所有的输出生命周期参数</li>
<li>如果有多个输入生命周期且其中一个是<code>&amp;self</code>或者<code>&amp;mut self</code>(说明是个对象的方法）；那么所有的输出生命周期参数将被赋予<code>self</code>的生命周期。</li>
</ul>
<ol start="12">
<li>生命周期省略简记：</li>
</ol>
<ul>
<li>只有一个输入参数</li>
<li>有多个输入且其中一个是<code>&amp;self</code></li>
</ul>
<ol start="13">
<li>Rust 中 struct 和其方法未封装到一起，C++相当于将 struct 和方法封装到类中。C 也有 struct 和函数，但不具有 trait 或接口功能。</li>
<li>方法签名中，<code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>，因为该方法位于<code>impl Rectangle</code>上下文中，所以 Rust 知道<code>self</code>类型是<code>Rectangle</code></li>
<li><code>impl</code>不以<code>self</code>作为参数的函数，被称为关联函数。是函数不是方法。(类似 C++的静态函数）)</li>
<li><code>self</code>是 keyword. 方法中如果想改名字，可以这样传参<code>self1: &amp;Rectangle</code></li>
<li>方法定义中的生命周期注解应用于关联函数，方法（含有<code>&amp;self</code>)可省略。</li>
<li>静态生命周期： <code>&#39;static</code>，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有<code>&#39;static</code>生命周期。</li>
<li>生命周期也是泛型<code>test&lt;&#39;a, T&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str, ann: T) -&gt; &amp;&#39;a str where T: Display</code> 因为生命周期也是泛型，所以<code>&#39;a</code>和泛型参数<code>T</code>都位于函数名后的同一尖括号列表中。</li>
<li>PhantomData Zero-sized type used to mark things that “act like” they own a T. 用在 ffi 封装指针上。</li>
<li><code>fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str </code> 当具体的引用被传递给 longest 时，被 ‘a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。</li>
</ol>
<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><ol>
<li>trait object 用来实现泛型函数里动他分发</li>
<li>Trait Object，表现为 &amp;dyn Trait (无所有权） 或者 Box<dyn Trait>（有所有权）。</li>
<li>在 Rust 里，类型的行为是通过 Trait 来赋予的，几乎所有的数据结构都实现了一个到多个 Trait。泛型编程时只有指定 trait bound(限制)才能使用接口。</li>
<li>Rust 可以同时支持“静态分派(static dispatch)”和“动态分派(dynamic dispatch)”</li>
<li>利用泛型：编译器会根据实际调用参数的类型不同，直接生成不同的函数版本，类似 C++ 的 template 一样。通过泛型函数实现的“多态”，是在编译阶段就已经确定好了调用哪个版本的函数，因此被称为“静态分派”。</li>
<li>Rust 中的“动态分派”靠 Trait Object 来完成。</li>
<li>指向 trait 的指针就是 Trait Object。如 Box<dyn Bird>.</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23791817">Object Safe</a>: 以下条件下 Trait Object 是无法构造出来：<ul>
<li>当 trait 有 Self:Sized 约束时</li>
<li>当函数中有 Self 类型作为参数或者返回类型时</li>
<li>当函数第一个参数不是 self 时</li>
<li>当函数有泛型参数时</li>
</ul>
</li>
<li>使用工厂模式时， 如果 trait 返回 Self，例如：fn get(&amp;self) -&gt; Self; <code>fn get(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn InfoManager&gt;; </code> <a target="_blank" rel="noopener" href="https://users.rust-lang.org/t/boxed-self-in-a-trait-method/1742/2">link</a></li>
<li>Rust 的动态分派，和 C++的动态分派，内存布局有所不同。在 C++里，如果一个类型里面有虚函数，那么每一个这种类型的变量，内部都包含一个指向虚函数表的地址。而在 Rust 里面，对象本身不包含指向虚函数表的指针，这个指针是存在于 trait object 指针里面。<code>如果一个类型实现了多个 trait，那么不同的 trait object 指向的虚函数表也不一样</code>。</li>
<li>You can implement traits for types you didn’t define, whereas interfaces can only be implemented for your own classes.</li>
<li><code>孤儿规则</code>(orphan rule)，简称 OR：”当你为某类型实现某 trait 的时候，必须要求类型或者 trait 至少有一个是在当前 crate 中定义的。 你不能为第三方的类型实现第三方的 trait 。</li>
<li>Trait Object 的底层逻辑不过就是胖指针（fat pointer） —— 一个包含两个指针的数据结构。其中，一个指针指向数据本身，另一个则指向虚函数表（vtable）。在这张表里，包含具体类型的一些信息，如 size，aligment 以及一系列函数指针：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=2649829038&idx=1&sn=b9459537ff93d2aee56b822d09d6a80a&chksm=8704acb2b07325a4a9c46f0bbac3df2db2fadeb2b7928e3949072f01df0d975eaecb36a6e8dd&scene=178&cur_album_id=1701598373151047686#rd">link</a></li>
</ol>
<h2 id="Generic-Types-泛型"><a href="#Generic-Types-泛型" class="headerlink" title="Generic Types 泛型"></a>Generic Types 泛型</h2><ol start="3">
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=2649829038&idx=1&sn=b9459537ff93d2aee56b822d09d6a80a&chksm=8704acb2b07325a4a9c46f0bbac3df2db2fadeb2b7928e3949072f01df0d975eaecb36a6e8dd&scene=178&cur_album_id=1701598373151047686#rd">透过 Rust 探索系统的本原：泛型</a></li>
<li>泛型编程，与其说是一种技术，不如说是一种思想。它不仅仅是类型参数化，函数泛型化那么简单，背后体现的是程序员的抽象思维能力。抽象思维的能力，和语言无关，和工具无关，它是一种在实践中不断探索，不断学习，不断历练得出的能力。支持泛型的语言并不能帮助你更好地做泛型编程，就好比给我一台斯坦威钢琴，并不意味着我就具备了演奏李斯特《钟》的能力。</li>
<li>定义数据结构时： 参数化类型（Parameterized Type）</li>
<li>定义函数时： 泛型函数（Generic Function）</li>
<li>泛型函数: 静态分派（static dispatch 泛型为具体类型 T）和动态分派（dynamic dispatching 泛型为 trait object）</li>
<li>编译器在编译时就能捕获到使用的类型，从而进行对应的处理，这被称之为静态分派（static dispatch）。</li>
<li><img src="https://mmbiz.qpic.cn/mmbiz_png/SER9L29WQ0icrEMnzjvMNTzSZbaPboUnMUFBia3wHebkuX9e6Ah70g3CKC9v8bVicGeGJEq0Dd38AnesVU5ffXmdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="静态分派和动态分派"></li>
</ol>
<h2 id="Iterators-and-Closures-迭代器与闭包"><a href="#Iterators-and-Closures-迭代器与闭包" class="headerlink" title="Iterators and Closures 迭代器与闭包"></a>Iterators and Closures 迭代器与闭包</h2><ol>
<li>函数式编程：包含将函数作为参数值或其他函数的返回值，将函数赋值给变量以供之后执行等等。</li>
<li>闭包：一个可以储存在变量里的类似函数的结构</li>
<li>迭代器：一种处理元素序列的方式。</li>
<li>Rust 的闭包是可以保存进变量或作为参数传递给其他函数的匿名函数（可以捕获环境的匿名函数）。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。</li>
<li>不同于函数，闭包允许捕获调用者作用域的值。</li>
<li>在程序的一个位置指定某些代码，并只在程序的某处实际需要结果的时候执行这些代码。这正式闭包的用武之地。</li>
<li>闭包通常很短，并只关联于小范围的上下文而非任意情境。在有限的上下文中，编译器能可靠的推断参数和返回值的类型。</li>
<li>闭包语法：<code>let test = |num1, num2| &#123; println(&quot;num1: &#123;&#125;&quot;,num1); num2 + 1 &#125;;</code> <code>|num1, num2|</code>是参数，<code>num2+1</code>是返回值。<code>let</code>表明<code>tet</code>是一个匿名函数的定义。不是调用匿名函数的返回值。<code>test</code>存储的是代码。</li>
<li>带类型注解的闭包 <code>let test = |num1: u32, num2: u32| -&gt; u32 &#123; println(&quot;num1: &#123;&#125;&quot;,num1); num2 + 1 &#125;;</code></li>
<li>如果闭包体只有一行则大括号可以省略。例如： <code>let add_one = |x| x+1;</code></li>
<li>如果调用多次闭包，编译器会根据第一次使用时的参数类型，如果对同一闭包使用不同类型会得到类型错误。</li>
<li>…</li>
<li></li>
<li></li>
<li>迭代器负责遍历序列中的灭一项和决定序列何时结束的逻辑。</li>
<li>迭代器是惰性的，在调用方法使用之前它都不会有效果。</li>
<li>迭代器的实现方式提供了对多种不同的序列使用相同逻辑的灵活性，减少了重复代码并消除了潜在的混乱。</li>
<li>迭代器都实现了定义于标准库的 trait <code>Iterator</code>。包含<code>next</code>方法。</li>
<li>迭代器的<code>sum</code>方法返回迭代的次数，会消费适配器。迭代器调用<code>sum</code>方法后不再允许使用迭代器，因为<code>sum</code>会获取迭代器所有权。</li>
<li>迭代器的方法：<code>迭代器适配器(iterator adaptors)</code> 允许将迭代器变为不同类型的迭代器。</li>
<li><code>v1.iter().map(|x| x+1);</code>迭代器适配器方法<code>map</code>使用闭包来调用每个元素以生成新的迭代器。这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。因为迭代器适配器是惰性的，这里需要消费迭代器。</li>
<li><code>collect</code>方法会消费迭代器并将结果收集到一个数据结构中。</li>
<li>下面例子会调用<code>map</code>方法创建一个新的迭代器，接着调用<code>collect</code>方法消费新迭代器并创建一个 vector。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="Smart-Pointers-智能指针"><a href="#Smart-Pointers-智能指针" class="headerlink" title="Smart Pointers 智能指针"></a>Smart Pointers 智能指针</h2><ol>
<li>指针是一个包含内存地址的变量的通用概念，这个地址指向一些其他数据。</li>
<li>Rust 最常见的指针是引用，他们没有任何额外的开销，所以应用的最多。</li>
<li><code>智能指针(smart pointers)</code>是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。</li>
<li><code>引用计数(reference counting)</code> 是智能指针类型，其允许数据有多个所有者。引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。</li>
<li>在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有他们指向的数据。</li>
<li>智能指针通常使用结构体实现。</li>
<li>智能指针区别于常规结构体的显著特性在于其实现了<code>Deref</code>和<code>Drop</code>trait。</li>
<li><code>Deref</code> trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用，又用于智能指针的代码。</li>
<li><code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码。</li>
<li>很多库都拥有自己的智能指针而你也可以编写属于你的智能指针。</li>
<li><code>Box&lt;T&gt;</code>用于在堆上分配值。</li>
<li><code>Rc&lt;T&gt;</code>一个引用计数类型，其数据可以有多个所有者。</li>
<li><code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code>通过<code>RefCell&lt;T&gt;</code>访问。</li>
<li>最简单直接的智能指针是<code>box</code>，其类型是<code>Box&lt;T&gt;</code>，box 允许你将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针。</li>
<li>除了数据被存储在堆上而不是栈上之外，box 没有性能损失，不过也没有很多额外的功能。多用于<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候。（box 作为链表的指针实现链表）</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候。</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是具体类型的时候</li>
</ul>
</li>
<li><code>Box&lt;T&gt;</code>类型是一个只能智能指针，因为它实现了<code>Deref</code>trait，它允许<code>Box&lt;T&gt;</code>的值被当做引用对待。</li>
<li>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</li>
<li>&amp; 符号就是 引用，允许你使用值但不获取其所有权。</li>
<li>我们将获取引用作为函数参数称为 借用（borrowing）。</li>
</ol>
<h2 id="AsRef-and-Deref"><a href="#AsRef-and-Deref" class="headerlink" title="AsRef and Deref"></a>AsRef and Deref</h2><ol>
<li>Deref is different from the other two: one type can only be derefed to one target type, and *d always has the same type.</li>
<li>Borrow and AsRef both give a reference to the underlying data, but Borrow requires that the original type and the borrowed type have the same behavior, while AsRef does not have the same requirement.</li>
<li>当我们在示例中输入 _y 时，Rust 事实上在底层运行了如下代码：<code>_(y.deref()) </code> Rust 将 * 运算符替换为先调用 deref 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 deref 方法了。Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 Deref 的类型。</li>
<li>解引用强制多态（deref coercions）是 Rust 在函数或方法传参上的一种便利。其将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，解引用强制多态将自动发生。这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。</li>
<li>解引用强制多态的加入使得 Rust 程序员编写<code>函数和方法</code>调用时无需增加过多显式使用 &amp; 和 * 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。</li>
<li><a target="_blank" rel="noopener" href="https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/deref.html">deref</a></li>
</ol>
<h2 id="Concurrency-并发"><a href="#Concurrency-并发" class="headerlink" title="Concurrency 并发"></a>Concurrency 并发</h2><h2 id="Asynchronous-Programming"><a href="#Asynchronous-Programming" class="headerlink" title="Asynchronous Programming"></a>Asynchronous Programming</h2><ol>
<li>async function 是一种 promise(sender). promise 调用 await 时，执行并返回 future(reciever).</li>
</ol>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><ol>
<li>主要作用： makes it possible for a thread to continue doing useful work while it waits for the value to become available. 例如：IO DMA</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107820568">深入浅出 Tokio</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mhq-martin/p/9035640.html">同步异步，阻塞非阻塞区别</a></li>
<li>同步异步区别是在调用一个功能时，没得到<code>结果</code>之前，是否继续后续操作</li>
<li>阻塞非阻塞区别是<code>线程/程序</code>在等待调用结果时，是否一直等待（挂起当前线程）</li>
<li>阻塞和非阻塞关注的是程序在<code>等待调用结果</code>（消息，返回值）时的<code>状态</code>.</li>
<li>进程线程锁是用来同步的，lock()函数是阻塞式，不拿到锁不返回，线程被阻塞。try_lock()是非阻塞式的，如果拿不到锁也返回。</li>
<li>异步是目的，而多线程是实现这个目的的方法</li>
<li>Async&#x2F;Await is a paradigm that is orthogonal to threading, which means that it has the potential to run tasks on a single thread OR on multiple threads depending on the executor that is used.</li>
<li>async&#x2F;await 与多线程 <a target="_blank" rel="noopener" href="https://qvault.io/rust/concurrency-in-rust-can-it-stack-up-against-gos-goroutines/">link</a></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">use</span> futures::executor::block_on;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">future</span> = <span class="title function_ invoke__">async_main</span>();</span><br><span class="line">    <span class="title function_ invoke__">block_on</span>(future); <span class="comment">// 执行器单线程执行，总共需要15秒，多线程可能就快很多</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_for_five</span>(<span class="string">&quot;await&quot;</span>).<span class="keyword">await</span>; <span class="comment">// await: function 阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">async_one</span> = <span class="title function_ invoke__">print_for_five</span>(<span class="string">&quot;async 1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">async_two</span> = <span class="title function_ invoke__">print_for_five</span>(<span class="string">&quot;async 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    futures::join!(async_one, async_two);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">print_for_five</span>(msg: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="comment">// task::sleep(Duration::from_secs(1)).await; //async 1, 2 循环执行，task await会异步阻塞</span></span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)); <span class="comment">//执行器单线程时顺序执行，因为不会阻塞</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;one second has passed: &#123;&#125;&quot;</span>, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object-Oriented-面向对象"><a href="#Object-Oriented-面向对象" class="headerlink" title="Object Oriented 面向对象"></a>Object Oriented 面向对象</h2><h2 id="Macros-宏"><a href="#Macros-宏" class="headerlink" title="Macros 宏"></a>Macros 宏</h2><ol>
<li>从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）</li>
<li>元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数扮演的角色。但宏有一些函数所没有的附加能力。</li>
<li>derive 属性，其生成各种 trait 的实现</li>
<li>一个函数标签必须声明函数参数个数和类型。相比之下，宏能够接受不同数量的参数：用一个参数调用 println!(“hello”) 或用两个参数调用 println!(“hello {}”, name) 。</li>
<li>宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现。</li>
<li>实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。</li>
<li>hello_macro(不是宏) 中定义的 trait(可包含多个接口）， hello_macro_derive 中实现的过程式宏。在一个类型上指定 #[derive(HelloMacro)] 时，hello_macro_derive 函数将会被调用。</li>
</ol>
<h2 id="Program-with-C-C"><a href="#Program-with-C-C" class="headerlink" title="Program with C&#x2F;C++"></a>Program with C&#x2F;C++</h2><ol>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/index.html">Rustonomicon</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust-bindgen">rust bindgen</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/embedded-book/interoperability/index.html">rust with C</a></li>
</ol>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.rs/env_logger/0.8.3/env_logger/">env_logger</a></li>
<li>actix_web 使用了 env_logger <a target="_blank" rel="noopener" href="https://github.com/actix/actix-web/blob/master/src/middleware/logger.rs#L51">actix_web::middleware::Logger</a></li>
</ol>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/03/22/Actix/" rel="bookmark">Actix</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/08/05/Cargo/" rel="bookmark">Cargo</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/07/26/Memory-concept-and-issues/" rel="bookmark">Memory concept and issues</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/07/10/Why-Rust/" rel="bookmark">Why Rust</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/07/09/Rust-start/" rel="bookmark">Rust start</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>贾夕阳
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jiaxiyang.github.io/2021/07/11/Rust-grammar/" title="Rust grammar">https://jiaxiyang.github.io/2021/07/11/Rust-grammar/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Rust/" rel="tag"><i class="fa fa-tag"></i> Rust</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/29/Bash-usage/" rel="prev" title="Tools and Linux Command">
      <i class="fa fa-chevron-left"></i> Tools and Linux Command
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/20/Cpp-concurrency-in-action/" rel="next" title="Cpp-concurrency-in-action">
      Cpp-concurrency-in-action <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">顶层概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Grammar"><span class="nav-number">2.</span> <span class="nav-text">Grammar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Project-Manage"><span class="nav-number">3.</span> <span class="nav-text">Project Manage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">类型系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ownership-%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">5.</span> <span class="nav-text">Ownership 所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enums-%E6%9E%9A%E4%B8%BE-and-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">6.</span> <span class="nav-text">Enums 枚举 and 模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88-collections"><span class="nav-number">7.</span> <span class="nav-text">常见集合 collections</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-Handling-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">Error Handling 错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lifetimes-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">9.</span> <span class="nav-text">Lifetimes 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traits"><span class="nav-number">10.</span> <span class="nav-text">Traits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generic-Types-%E6%B3%9B%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">Generic Types 泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterators-and-Closures-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">12.</span> <span class="nav-text">Iterators and Closures 迭代器与闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Smart-Pointers-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">13.</span> <span class="nav-text">Smart Pointers 智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsRef-and-Deref"><span class="nav-number">14.</span> <span class="nav-text">AsRef and Deref</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency-%E5%B9%B6%E5%8F%91"><span class="nav-number">15.</span> <span class="nav-text">Concurrency 并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Asynchronous-Programming"><span class="nav-number">16.</span> <span class="nav-text">Asynchronous Programming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">17.</span> <span class="nav-text">异步编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-Oriented-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">18.</span> <span class="nav-text">Object Oriented 面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Macros-%E5%AE%8F"><span class="nav-number">19.</span> <span class="nav-text">Macros 宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Program-with-C-C"><span class="nav-number">20.</span> <span class="nav-text">Program with C&#x2F;C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">21.</span> <span class="nav-text">日志</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="贾夕阳"
      src="/images/coder2.jpg">
  <p class="site-author-name" itemprop="name">贾夕阳</p>
  <div class="site-description" itemprop="description">深度学习/自动驾驶/C++/性能优化</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">167</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jiaxiyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiaxiyang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/2024/01/04/huggingface/" title="2024&#x2F;01&#x2F;04&#x2F;huggingface&#x2F;">huggingface</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2024/01/01/tensorrt-llm/" title="2024&#x2F;01&#x2F;01&#x2F;tensorrt-llm&#x2F;">tensorrt-llm</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/12/30/gpt/" title="2023&#x2F;12&#x2F;30&#x2F;gpt&#x2F;">gpt</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/12/26/jupyter/" title="2023&#x2F;12&#x2F;26&#x2F;jupyter&#x2F;">jupyter</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2023/12/24/llama2-c/" title="2023&#x2F;12&#x2F;24&#x2F;llama2-c&#x2F;">llama2</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贾夕阳</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">410k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:13</span>
</div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("06/26/2020 14:52:10");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://jiaxiyang.github.io/2021/07/11/Rust-grammar/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'g32ipLmEye1u5l6wBGRJt03S-gzGzoHsz',
      appKey     : 'zHgLkAICsZUl9Mf8LfdoVigP',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  

  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>





 
</body>
</html>

