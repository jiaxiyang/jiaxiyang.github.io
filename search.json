[{"title":"transformer","url":"/2023/11/21/transformer/","content":"\n## links\n\n1. [huggingface/transformers](https://github.com/huggingface/transformers)\n"},{"title":"LLM","url":"/2023/11/21/LLM/","content":"\n## concept\n\n1. 大模型（Large Language Model，LLM）\n   ![示意](https://storage.googleapis.com/gweb-uniblog-publish-prod/original_images/1_Welcome_GenerativeMeena_CL_V02_150521_v2_720_25fps.gif)\n1. 模型大小 7B(billion), 7B 表示 70 亿个可训练参数。吉比（gigabyte）是一个信息技术单位，。十亿（billion）是一个计数单位， 参数类型(float, int8)和数量(billion)决定模型的大小(gigabyte)\n1. Bard 是由 Google 开发的生成式人工智能聊天机器人，最初基于大型语言模型的 LaMDA 系列，后来基于 PaLM2。\n1. 基础架构 transformer\n1. [claude](https://claude.ai/chats) chatgpt 主要竞争对手\n\n## 排名\n\n1. [SuperCLUE 中文通用大模型综合性基准](https://github.com/CLUEbenchmark/SuperCLUE)\n1. [open_llm_leaderboard](https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard)\n1. [UC 伯克利发布大模型排行榜 需要查看 leaderboard](https://arena.lmsys.org/)\n\n## huggine face\n\n1. [models](https://huggingface.co/models)\n1. [open_llm_leaderboard](https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard)\n\n## sota models\n\n1. [gpt-4](https://openai.com/gpt-4)\n1. [llama](https://ai.meta.com/llama/)\n1. [palm2](https://ai.google/discover/palm2/)\n1. [claude-2](https://www.anthropic.com/index/claude-2)\n\n## [llama](https://github.com/facebookresearch/llama)\n\n1. 读音： 拉马（西班牙语通话的意思)\n1. clone 之后执行 download.sh, 需要官网申请的 url\n1. [demo_apps](https://github.com/facebookresearch/llama-recipes/tree/main/demo_apps)\n"},{"title":"shareX","url":"/2023/11/15/shareX/","content":"\n## base\n\n1. 设置上传 url\n   ![设置上传url](https://i.ibb.co/3C66vgd/UQTv-UKxj-Vi.png)\n\n## 设置自定义服务器\n\n1. [imagebb 生成 key](https://api.imgbb.com/)\n   ![生成key](https://i.ibb.co/Dz3Xkyn/Jf4m-Fd-WXg-F.png)\n1. [自定义目标设置贴入，修改 key](https://github.com/ShareX/CustomUploaders/blob/master/imgbb.com.sxcu)\n   ![修改key](https://i.ibb.co/MM2mLg5/2z4l9e-PS2x.png)\n   ![key](https://i.ibb.co/TwmGMk8/BUHj-Zwd0ke.png)\n\n## links\n\n1. [shareX](https://getsharex.com/)\n1. [图片共享](https://imgbb.com/)\n1. [imgur](https://imgur.com/)\n"},{"title":"nvidia","url":"/2023/11/10/nvidia/","content":"\n## [vpi](https://docs.nvidia.com/vpi/algorithms.html)\n\n1. 支持多种硬件做前处理, 如 resize, convert color, remap (VIC 都支持，可以释放 GPU 资源)\n"},{"title":"package manager","url":"/2023/11/05/package-manager/","content":"\n## C++\n\n### [CPM](https://github.com/cpm-cmake/CPM.cmake)\n\n## python\n\n### [miniconda](https://docs.conda.io/en/latest/miniconda.html#linux-installers) 选择对应 python 版本, install 时可以选路径\n\n### [anaconda](https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/)\n\n### [mamba](https://github.com/mamba-org/mamba)\n\n## rust\n\n### cargo\n\n## multi\n\n### [pixi](https://github.com/prefix-dev/pixi)\n\n1. pixi is a cross-platform, multi-language package manager and workflow tool built on the foundation of the conda ecosystem. It provides developers with an exceptional experience similar to popular package managers like cargo or yarn, but for any language.\n"},{"title":"pixi","url":"/2023/11/03/pixi/","content":"\n## base\n\n1. 不同工程可以用软连接共享.pixi 文件夹\n1. cfonts 使得 task 更清楚\n1. `curl -fsSL https://pixi.sh/install.sh | bash` install\n1. 工程目录下`.pixi`包含各种环境依赖\n1. pixi is a cross-platform, multi-language package manager and workflow tool built on the foundation of the conda ecosystem. It provides developers with an exceptional experience similar to popular package managers like cargo or yarn, but for any language.\n1. Supports multiple languages including Python, C++, and R using Conda packages.\n1. 可用于 github actions, 只需要配置 pixi，不用手动安装各种环境\n1. 参考写 task [example](https://github.com/prefix-dev/pixi/blob/main/examples/cpp-sdl/pixi.toml)\n1. 如果下载不了 package， 可以删除~/.cache/rattler/cache/repodata 试试\n1. 执行命令在 repo 下都行\n1. `pixi global install <cmake>`在机器上安装 cmake; 安装到~/.pixi/bin， 需要需改.zshrc `export PATH=~/.pixi/bin:$PATH`\n1. `pixi shell`中可以用 pixi 安装的最新命令\n1. `pixi add gxx clangxx` install g++ and clang++； ++符号不允许\n1. 下载的时候 VPN 设置为 global， 用 rule 可能识别为本地， 下载出问题\n1. python 需要先安装 pip\n\n## [command](https://prefix.dev/docs/pixi/cli)\n\n1. `pixi init <name>` 初始化工程, 添加 pixi.toml 和 gitignore 信息\n1. `pixi add cmake ninja opencv glog`添加依赖库\n1. `pixi add \"clang-tools<=15.0.0,>13.0\"`\n1. `pixi run <task>` run task\n1. `pixi search glog` search package\n1. `pixi info` 查看各种信息， cache 位置：~/.cache/rattler/, task list\n1. `pixi global list` list global package\n1. `pixi shell` 进入 pixi shell， 执行/tmp/pixi_env_xxx.sh 脚本设置环境变量， 可以在配置文件 activate 脚本中使用\n\n## [config](https://prefix.dev/docs/pixi/configuration)\n\n1. pixi shell 可以查看环境变量\n1. channels = [\"conda-forge\", \"robostack\", \"bioconda\", \"nvidia\", \"pytorch\"]; 设置源 [link](https://prefix.dev/channels)\n1. env set, 可以设置 LD_LIBRARY_PATH\n\n```yaml\n[activation]\nscripts = [\"env_setup.sh\"]\n```\n\n## env\n\n1. `PIXI_PACKAGE_ROOT` repo 目录\n1. `CONDA_PREFIX` pixi env 目录 ${PIXI_PACKAGE_ROOT}/.pixi/env\n1. `PIXI_PACKAGE_PLATFORMS` platform 类型\n1. `PATH` 只有 PATH, 没有 LD_LIBRARY_PATH, 需要自己在配置文件 activate 脚本里设置\n\n```yaml\nexport LD_LIBRARY_PATH=${CONDA_PREFIX}/lib  # for run app\nexport CMAKE_PREFIX_PATH=${CONDA_PREFIX}/lib  # for cmake find_package\nexport PKG_CONFIG_PATH=${CONDA_PREFIX}/share/pkgconfig:${CONDA_PREFIX}/lib/pkgconfig  # for pkg-config\n```\n\n## links\n\n1. [pixi](https://github.com/prefix-dev/pixi)\n1. [What is the difference with conda, mamba, poetry, pip](https://github.com/prefix-dev/pixi/blob/main/docs/FAQ.md)\n1. [cpp using example](https://www.rerun.io/docs/howto/arrow-cpp-install)\n1. [rerun cpp-example-opencv-eigen pixi example](https://github.com/rerun-io/cpp-example-opencv-eigen/blob/main/pixi.toml)\n"},{"title":"IREE","url":"/2023/10/16/IREE/","content":"\n## links\n\n1. [iree](https://www.iree.dev/)\n","tags":["AI","IR","Compiler"],"categories":["AI","IR"]},{"title":"SPIR-V","url":"/2023/10/16/SPIR-V/","content":"\n## links\n\n1. [spir](https://www.khronos.org/spir/)\n","tags":["AI","IR","Compiler"],"categories":["AI","IR"]},{"title":"MLIR","url":"/2023/10/12/MLIR/","content":"\n## base\n\n1. MLIR 即 Multi-Level Intermediate Representation，多级的中间表示。\n1. mlir 只是个编译器框架，本身并没有什么完整功能。所以可以参考一些基于 MLIR 做的开源项目。\n","tags":["AI","IR","Compiler"],"categories":["AI","IR"]},{"title":"Mojo","url":"/2023/10/10/Mojo/","content":"\n## links\n\n1. [LLVM 之父 Chris Lattner：我的 AI 基础设施软件构建理念](https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247492618&idx=1&sn=a20f4828b9ab3e3cee3fedfd906e0eb2&chksm=fe426a3cc935e32a8312ce9efbb4f2640787508d3e811579bbffe918685cdb07a8bd8e3ffc4b&scene=132&exptype=timeline_recommend_article_extendread_samebiz#wechat_redirect)\n1. [未来的人工智能语言，是 Rust 还是 Mojo ？](https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA%3D%3D&mid=2247597850&idx=1&sn=679ccdcaf76e8b6ab97ca42687769da1)\n1. [github mojo](https://github.com/modularml/mojo)\n"},{"title":"rerun","url":"/2023/10/08/rerun/","content":"\n## base\n\n1. 日志重放工具 log-replay tools [link](https://www.rerun.io/blog/rosbag)\n1. 观察工具 [what-is-a-seeingtool](https://www.rerun.io/blog#what-is-a-seeingtool)\n1. [Seeing Spaces 它是 Figma、Webflow、Our World in Data 等许多项目的灵感来源](https://vimeo.com/97903574)\n1. 类似 rosbag\n1. rerun 可以纪录每帧对应的 latency，fps, 画图，平均值？方便分析哪一帧耗时\n1. 不链接 viewer 也不保存，相当于不操作？方便开启和关闭 log\n1. 使用 rerun 实时或回放监测的数据\n1. `rr.set_time_sequence(\"frame_nr\", x) # frame_nr为横坐标` 横坐标可以选择按帧或时间显示\n1. 测试程序可以关闭 viewer(init spawn false)， 将结果记录到 rrd 文件里（rr.save), 使用 online demo 回放\n1. 可以显示 log 和文档 [link](https://github.com/rerun-io/rerun/tree/main/examples/python/detect_and_track_objects)\n1. `pip install rerun-sdk && python3 -m rerun_demo`安装并运行 demo\n1. `python3 -m rerun`启动客户端\n1. `python3 -m rerun --web-viewer`启动 web, `http://{ip}:9090/` to open webserver\n1. `python3 -m rerun --web-viewer --web-viewer-port 5900` wsl docker\n1. `python3 -m rerun --web-viewer --web-viewer-port 5900 --save test.rrd` 保存接收到的 log, save 时不能打开 web\n1. [4 sdk-operating-modes](https://www.rerun.io/docs/reference/sdk-operating-modes) Connnect: Connects to a remote Rerun Viewer and streams all the data via TCP.\n1. good: docker web live data\n   - `python3 -m rerun --web-viewer --web-viewer-port 5900 --ws-server-port 6080` 注意--web-viewer-port 是打开 viewer 的端口， --ws-server-port 是用于连接 server 端口\n   - `examples/python/clock/main.py --connect --addr=127.0.0.1:9876` example 用到的代码`rr.connect(127.0.0.1:9876)`; 注意 viewer 默认监听的是 9876, --port 才能修改，注意和--web-viewer-port 的区别\n   - `http://localhost:10087/?url=ws://localhost:10089` (in docker -p10087:5900 -p10089:6080) or `http://10.31.2.47:9090/?url=ws://10.31.2.47:9877` 注意两个 localhost 和端口号都要替换\n1. 测试是否收到数据\n   - `python3 -m rerun --web-viewer --web-viewer-port 5900  --test-receive`\n   - `examples/python/clock/main.py --connect --addr=127.0.0.1:9876`\n1. [connect sample](https://github.com/rerun-io/rerun/blob/0a2a594b1f9527e91400a0b1d2dbb4943080f385/rerun_py/README.md?plain=1#L50)\n1. 多次链接有多次数据\n1. python connect code\n\n```python\nimport rerun as rr  # NOTE: `rerun`, not `rerun-sdk`!\nimport numpy as np\nrr.init(\"rerun_example_my_data\", spawn=True)\n\nrr.connect(\"192.168.1.3:9876\")\n\npositions = np.zeros((10, 3))\npositions[:,0] = np.linspace(-10,10,10)\ncolors = np.zeros((10,3), dtype=np.uint8)\ncolors[:,0] = np.linspace(0,255,10)\nrr.log(\"my_points\",rr.Points3D(positions, colors=colors, radii=0.5))\n```\n\n## c++\n\n1. [cpp-example-opencv-eigen](https://github.com/rerun-io/cpp-example-opencv-eigen)\n   - `pixi run example`\n1. 测试程序可去掉`rec.spawn`, 添加\n   - `rec.save(\"test.rrd\");` 保存结果到 test.rrd\n   - `rec.connect(\"127.0.0.1:9876\");` 连接本地的 viewer, 本地的 viewer(in docker -p10087:5900 -p10089:6080) `python3 -m rerun --web-viewer --web-viewer-port 5900 --ws-server-port 6080`; 本地浏览器`http://localhost:10087/?url=ws://localhost:10089`\n\n## 环境变量\n\n1. `export RERUN=off`环境变量控制是否输出 log\n1. `rerun --help`可以查看环境变量\n\n## install\n\n1. [troubleshooting](https://www.rerun.io/docs/getting-started/troubleshooting)\n\n## [logging](https://www.rerun.io/docs/reference/types/archetypes/text_log#textlogintegration)\n\n1. code\n\n```\nimport rerun as rr\nimport logging\n\ndef main() -> None:\n    rr.init(\"rerun_example_my_data\", spawn=False)\n    rr.save(\"recording.rrd\")\n    rr.set_time_sequence(\"frame\", 0)\n    logging.getLogger().addHandler(rr.LoggingHandler(\"logs/handler\"))\n    logging.getLogger().setLevel(-1)\n    logging.info(\"This INFO log got added through the standard logging interface\")\n    rr.set_time_sequence(\"frame\", 1)\n    logging.info(\"Test logging\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## samples\n\n1. 只记录数据不显示, 用于回放 w\n\n```python\nimport rerun as rr\nimport numpy as np\nimport random\nfrom math import cos, sin, tau\ndef log_trig() -> None:\n    # Log a time series\n    for t in range(0, int(tau * 2 * 100.0)):\n        rr.set_time_sequence(\"frame_nr\", t)\n\n        sin_of_t = sin(float(t) / 100.0)\n        rr.log(\"trig/sin\", rr.TimeSeriesScalar(sin_of_t, label=\"sin(0.01t)\", color=[255, 0, 0]))\n\n        cos_of_t = cos(float(t) / 100.0)\n        rr.log(\"trig/cos\", rr.TimeSeriesScalar(cos_of_t, label=\"cos(0.01t)\", color=[0, 255, 0]))\n\ndef log_linear() -> None:\n    for x in range(0, 1000):\n        rr.set_time_sequence(\"frame_nr\", x) # frame_nr为横坐标\n        y = x\n        rr.log(\"linear/x\", rr.TimeSeriesScalar(y, label=\"y=x\", color=[255, 0, 0]))\n\ndef main() -> None:\n    rr.init(\"rerun_example_my_data\", spawn=False) # spawn设置为False表示只记录数据， 不使用viewer显示\n    rr.save(\"recording.rrd\") # 保存为rrd\n    log_trig()\n    log_linear()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n2. cool\n\n```python\nimport rerun as rr\nimport numpy as np\n\nrr.init(\"rerun_example_my_data\", spawn=False)\nrr.save(\"recording.rrd\")\n\nSIZE = 10\n\npos_grid = np.meshgrid(*[np.linspace(-10, 10, SIZE)]*3)\npositions = np.vstack([d.reshape(-1) for d in pos_grid]).T\n\ncol_grid = np.meshgrid(*[np.linspace(0, 255, SIZE)]*3)\ncolors = np.vstack([c.reshape(-1) for c in col_grid]).astype(np.uint8).T\n\nrr.log(\n            \"my_points\",\n                rr.Points3D(positions, colors=colors, radii=0.5)\n                )\n```\n\n## demos\n\n1. [plots](https://github.com/rerun-io/rerun/tree/latest/examples/python/plots)\n1. [live-depth-sensor](https://github.com/rerun-io/rerun/tree/main/examples/python/live_depth_sensor)\n\n## links\n\n1. [rerun discord 在线信息 ](https://discord.com/invite/PXtCgFBSmH)\n1. [rerun-io/rerun](https://github.com/rerun-io/rerun)\n1. [docs 示意图](https://www.rerun.io/docs)\n1. [online demo](https://app.rerun.io/)\n1. [rerun/milestones](https://github.com/rerun-io/rerun/milestones)\n","tags":["Debug","DataView"],"categories":["Tools","Debug"]},{"title":"GPU","url":"/2023/10/07/GPU/","content":"\n## DLA (Deep Learning Accelerator)。\n\n1. NVIDIA DLA 是一个专门设计的硬件加速器，用于加速深度学习推断在边缘设备上的性能。DLA 被设计为与 NVIDIA 的 Jetson 平台（例如 Jetson AGX Xavier、Jetson Xavier NX 等）一同工作，这些平台主要用于嵌入式和边缘计算应用。\n1. `专为推断优化`：与训练深度学习模型的 GPU 不同，DLA 专门针对推断进行了优化，使其能够在功耗有限的边缘设备上高效运行。\n1. `集成与Jetson平台`：DLA 被集成到了某些 NVIDIA Jetson 模块中，提供了与 GPU 和 CPU 协同工作的能力，以实现多任务处理。\n1. `低功耗`：DLA 的设计重点是在保持低功耗的同时实现高效的推断处理，这对于需要长时间运行但电源有限的嵌入式应用非常重要。\n1. `支持多种网络`：DLA 支持多种流行的深度学习模型和框架，使开发者能够灵活地部署各种应用。\n1. `TensorRT兼容`：NVIDIA 的 TensorRT 是一个用于优化深度学习模型的推断的 SDK，它可以与 DLA 结合，进一步提高推断速度和效率。\n"},{"title":"test","url":"/2023/09/21/test/","content":"\n## 代码覆盖率检查\n\n### [gcovr](https://github.com/gcovr/gcovr)\n\n1. [doc](https://gcovr.com/en/stable/)\n1. `-DCMAKE_CXX_FLAGS=\"--coverage -g -O0\"` 需要 O0, 否则代码对不上\n1. [交叉编译](https://www.cnblogs.com/iamkun2005/p/16502967.html) [link](https://www.cnblogs.com/vaughnhuang/p/16224069.html)\n   - `export GCOV_PREFIX_STRIP=9`\n   - `export GCOV_PREFIX=$PWD`\n   - 运行程序，生成对应的.gcno, 将该目录拷贝回主机并覆盖同级目录（即 .gcda 文件与同名 .gcno 文件应该在同一目录）\n   - `mkdir out && gcovr --html-nested out/coverage.html`\n   - `gcovr --decisions --txt`\n   - `-f samples -e build` -f 包含， -e 排除\n\n<!-- more -->\n\n1. [config file](https://gcovr.com/en/stable/guide/configuration.html#configuration) [glog config](https://github.com/google/glog/blob/master/gcovr.cfg)\n1. `gcovr --gcov-executable /opt/ti-processor-sdk-rtos-j721e-evm/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcov` 交叉编译有时需要指定 gcov\n1. [原理](http://blog.chinaunix.net/uid-24709751-id-3612976.html)\n1. [Create a GitLab Pages deployment for a static site](https://docs.gitlab.com/ee/user/project/pages/getting_started/pages_ui.html)\n1. `pip install gcovr`\n1. [合并结果](https://gcovr.com/en/stable/guide/merging.html)\n\n```sh\ncp -r outs/build_tda4/* ./build_tda4\ngcovr --gcov-executable /opt/ti-processor-sdk-rtos-j721s2-evm/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcov -r . --filter src/ --filter include/ --xml-pretty --print-summary --json segment_height.json -o tmp\nfind build_tda4/ -name \"*.gcda\" |xargs rm\ncp -r outc/build_tda4/* ./build_tda4\ngcovr --gcov-executable /opt/ti-processor-sdk-rtos-j721s2-evm/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcov -r . --filter src/ --filter include/ --xml-pretty  --print-summary --json classify_roadtype.json -o tmp\ngcovr -a segment_height.json -a classify_roadtype.json --xml-pretty --print-summary -o coverage.xml\n```\n\n1. ctrl-c 不产生数据问题\n\n```c++\n#include <stdlib.h>\n#include <signal.h>\n\nextern \"C\" void __gcov_flush(void);\n\nvoid my_signal_handler(int signum) {\n    __gcov_flush();\n    // 结束程序或进行其他操作\n    exit(signum);\n}\n\n\nint main() {\n    signal(SIGINT, my_signal_handler);\n    // 其他代码...\n}\n\n```\n\n#### gitlab gcovr\n\n1. cmake\n\n```cmake\nif(COVERAGE_TEST)\n    set(CMAKE_BUILD_TYPE Debug)\n    add_compile_options(-ftest-coverage)\n    add_compile_options(-fprofile-arcs)\n    link_libraries(gcov)\nendif()\n\n```\n\n2. ci\n\n```sh\nCoverageTest::CPU:\n  stage: test\n  image: centos7\n  tags:\n    - phigent_runner_cpu\n  script:\n    - sh script/build_cpu.sh -DCOVERAGE_TEST=ON -DBUILD_TEST=ON\n    - gcovr -r . --filter src/ --filter include/\n  coverage: '/^TOTAL.*\\s+(\\d+\\%)$/'\n```\n\n3. [可视化](https://docs.gitlab.com/ee/ci/testing/test_coverage_visualization.html)\n\n### [(备选)gcov \\+ lcov](https://blog.csdn.net/u012247418/article/details/90137291)\n\n`gcov`是 GNU 编译器集合（GCC）中的一个代码覆盖测试工具。它可以分析程序的性能，并显示源代码的每一行执行了多少次。这在测试和调试中非常有用。\n`lcov`是一个图形前端，它基于`gcov`生成更容易理解和更详细的信息。它产生 HTML 页面，可以让你看到哪些行执行了多少次，哪些没有。\n\n```fish\ngcc -fprofile-arcs -ftest-coverage -o my_program my_program.c\n./my_program\ngcov my_program.c\n```\n\n这将在当前目录生成一个名为`my_program.c.gcov`的文件，其中包含每一行代码执行次数的统计信息。\n\n```fish\nsudo apt install lcov\nlcov --capture --directory . --output-file coverage.info\ngenhtml coverage.info --output-directory out\nfirefox out/index.html\n```\n\n这些只是基础; `gcov`和`lcov`都有许多其他选项和高级用法。在实际项目中，你可能还需要结合其他工具和方法，比如持续集成（CI）系统、测试框架等，以实现更全面的代码覆盖和测试。\n\n## [gitlab testing](https://docs.gitlab.com/ee/ci/testing/)\n","tags":["Test"],"categories":["Program","Test"]},{"title":"assembly","url":"/2023/09/21/assembly/","content":"\n## examples\n\n### hello world\n\n1. code\n\n```assembly test.s\n.section .data   # 指示汇编器开始一个数据段，通常用于存储变量和常量。\nhello_message:   # 定义了一个名为 hello_message 的标签，其内容是 \"Hello, World!\\n\" 字符串。.asciz 指令告诉汇编器创建一个以零结尾的 ASCII 字符串（即 C 字符串）。\n    .asciz \"Hello, World!\\n\"\n.section .text   # 指示汇编器开始一个代码段，通常用于存储程序代码。\n.globl _start    # 告诉链接器 _start 标签是一个全局符号，意味着它可以在其他文件中被引用。对于这个程序，_start 是程序的入口点。\n\n_start:\n    # Write hello_message to stdout\n    mov x8, #64            // syscall: write\n    mov x0, #1             // file descriptor: stdout\n    ldr x1, =hello_message // pointer to hello_message\n    mov x2, #13            // message length\n    svc #0                 // invoke syscall\n\n    # Exit the program\n    mov x8, #93            // syscall: exit\n    mov x0, #0             // exit status 0\n    svc #0                 // invoke syscall\n```\n\n1. compile command\n\n```sh\nas test.s -o test.o\nld test.o -o test\n./test\nobjdump -dw test #查看生成的汇编\n```\n\n### vector sample\n\n1. code\n\n```assembly test.s\n.global _start      // 声明全局标签，这是程序的起始点\n\n.section .data      // 开始数据段，用于定义初始化的变量\n.align 3            // 确保32位对齐\na:      .int 1, 2, 3, 4    // 定义整数数组a\nb:      .int 5, 6, 7, 8    // 定义整数数组b\nresult: .int 0, 0, 0, 0    // 定义整数数组result用于存储结果\nmsg:    .asciz \"Result: [%d, %d, %d, %d]\\n\"   // 定义用于打印的字符串格式\n\n.section .text      // 开始文本段，用于定义代码\n\nvector_add:\n    ld1 {v0.4s}, [x0]   // 从x0指向的地址加载向量到v0寄存器\n    ld1 {v1.4s}, [x1]   // 从x1指向的地址加载向量到v1寄存器\n    add v2.4s, v0.4s, v1.4s  // 将v0和v1的内容相加，结果存放在v2中\n    st1 {v2.4s}, [x2]   // 将v2的内容存储到x2指向的地址\n    ret                 // 返回到调用此函数的位置\n\n_start:\n    adr x0, a           // 将数组a的地址加载到x0寄存器\n    adr x1, b           // 将数组b的地址加载到x1寄存器\n    adr x2, result      // 将数组result的地址加载到x2寄存器\n    bl vector_add       // 调用vector_add函数\n\n    adr x0, msg         // 加载字符串格式的地址到x0寄存器\n    adr x5, result      // 将数组result的地址加载到x5寄存器\n    ldr w1, [x5]        // 加载result数组的第一个元素到x1寄存器\n    ldr w2, [x5, #4]    // 加载result数组的第二个元素到x2寄存器\n    ldr w3, [x5, #8]    // 加载result数组的第三个元素到x3寄存器\n    ldr w4, [x5, #12]   // 加载result数组的第四个元素到x4寄存器\n    bl printf           // 调用printf函数打印结果\n\n    mov x8, #93         // 加载系统调用号到x8寄存器，93是exit的调用号\n    mov x0, #0          // 设置退出状态为0\n    svc 0               // 进行系统调用\n```\n\n1. compile command\n\n```sh\nas -o test.o test.s\nld -o test test.o -lc # 需要链接C库\n./test\nobjdump -dw test #查看生成的汇编\n```\n\n1. [系统调用寄存器配置](https://arm64.syscall.sh/)\n\n## basic\n\n1. ARMv8-A：\n   - 前 8 个整数参数传递给函数时，使用寄存器 x0 到 x7。如果有更多的整数参数，它们会通过堆栈传递。前 8 个浮点参数使用浮点寄存器 v0 到 v7 传递。整数或指针返回值使用寄存器 x0（和 x1，如果需要返回更大的值，例如 128 位的值）。浮点数或向量返回值通过 v0 和 v1 返回。\n   - 系统调用主要使用 x0 到 x8 这 9 个寄存器，其中 x8 存储系统调用号，x0 到 x7 用于参数传递和返回值。\n1. 指令、伪指令、寄存器都可以全部是大写或者小写，GNU 风格是小写。\n\n## [伪指令](https://zhuanlan.zhihu.com/p/533821145)\n\n1. 伪指令就是对汇编器发出的指令。它在源程序汇编期间由汇编器处理。伪指令是由汇编器预处理的指令。它可以分解为几条指令的集合。\n1. 伪指令可以实现一下功能 - 符号定义 - 数据定义和对齐 - 汇编控制 - 汇编宏 - 段描述\n\n## [WebAssembly (abbreviated Wasm)](https://webassembly.org/)\n\n1. WebAssembly 是一种运行在现代网络浏览器中的新型代码，并且提供新的性能特性和效果。它设计的目的不是为了手写代码,而是为诸如 C、C++和 Rust 等低级源语言提供一个高效的编译目标。\n\n## links\n\n1. [ARMv8-aarch64 寄存器和指令集](https://winddoing.github.io/post/7190.html)\n1. [Armv8/armv9 架构入门指南](https://armv8-doc.readthedocs.io/en/latest/02.html)\n1. [Linux System Call Table 多个平台](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md)\n1. [不同平台系统调用寄存器配置](https://syscall.sh/)\n"},{"title":"QEMU","url":"/2023/09/20/QEMU/","content":"\n## arm simulation\n\n```sh\nsudo apt install qemu-system-aarch64\n\n## download image\n## https://cloud-images.ubuntu.com/releases/\n\n\n```\n\n## links\n\n1. [QEMU 入门指南](https://blog.csdn.net/FontThrone/article/details/104157859)\n"},{"title":"Reverse-Engineering","url":"/2023/09/13/Reverse-Engineering/","content":"\n## [radare2](https://github.com/radareorg/radare2)\n\n1. install\n\n```\nsudo pip install -U r2env\n\ngit clone https://github.com/radareorg/radare2\nradare2/sys/install.sh\n```\n\n1. <table> show help\n\n### usage\n\n1. `r2 ./test`\n1. `r2 -A ./test` analyse or `r2 ./test; aaa`\n1. `ia` show all info\n1. `il` libraries\n1. `is` show symbols\n1. `iS` show sections\n1. `iX` show used files\n1. `ic` show classes\n1. `iE | grep FUNC` show output functions\n\n## [ida](https://hex-rays.com/ida-pro/)\n\n1. [反编译工具集合](https://www.52pojie.cn/forum.php?mod=forumdisplay&fid=4&filter=typeid&typeid=123)\n1. [IDA Pro 权威指南（第二版）.pdf](https://github.com/Coldwave96/WebSecurity/blob/master/IDA%20Pro%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89.pdf)\n1. `Tab` jump to pseudocode\n1. `Esc` jump to previous position\n1. `Space` text view and graph view 切换\n1. `C-Enter` jump to next position\n1. `C-l` jump by name + `C-F` filter\n1. `C-p` jump to function\n1. `C-s` jump to segment\n1. `M-t` +`C-t` find\n1. `text view` and `graph view`\n1. 窗口拖出来后，可以点击窗口灰色线条来 reattach, If you click on the small gray bar just below the titlebar, you can drag it back to the main window.\n1. `view -> open subviews`看各种窗口\n1. `view -> toolbars -> debug` 显示 debug 按钮\n1. 分割窗口，diassembly 和 pseudocode， 右键 synchronize with；可以高亮同步代码\n1. 新窗口会在鼠标停留的窗口打开\n\n### debug\n\n1. 可以用 gdbserver 调试\n1. 可以实时看内存, bss, data, text\n1. 下方有`gdb`命令窗口， 可以`exit`来结束远程 gdbserver\n1. `debugger -> detach from process`\n1. `debugger -> debugger windows` 可以打开 stack trace(call stack), Locals 等调试窗口\n1. `debugger -> using source level debugging` 才可以在反编译的文件加断点\n\n### 修改二进制\n\n1. `Edit -> Pach program -> change byte/assemble` 修改二进制\n1. `Edit -> Pach program -> Apply patches to input file` 报错修改\n1. `File -> Produce file -> Create DIF file` 可以列出被修改的字节\n1. [Compiler on line wandbox](https://wandbox.org) 可对比结果\n1. [汇编指令和二进制互转](https://aarmconverter.com/)\n1. [汇编指令和二进制互转 1](https://disasm.czbix.com/)\n\n### 修改 PC 值\n\n1. 能临时跳到不同分支执行\n\n#### [gdb](https://wizardforcel.gitbooks.io/100-gdb-tips/content/patch-program.html)\n\n1. `b *main+12`函数偏移来打断点\n1. `disassemble` 显示汇编\n1. `p $pc`显示 PC 值\n1. `set var $pc=0x11111`设置 PC 值\n\n### [plugins](https://github.com/onethawt/idaplugins-list)\n\n1. [Virtuailor](https://github.com/0xgalz/Virtuailor) Virtuailor is an IDAPython tool that reconstructs vtables for C++ code written for intel architecture, both 32bit and 64bit code and AArch64 (New!).\n1. [lighthouse](https://github.com/gaasedelen/lighthouse)\n\n## [ghidra](https://github.com/NationalSecurityAgency/ghidra)\n\n1. [使用说明](https://www.secrss.com/articles/8829)\n1. 需要先安装 jdk, 使用 cmd 打开， powershell 不行\n1. 开始界面有 debugger\n\n## [binary.ninja](https://binary.ninja/)\n\n1. [破解](https://down.52pojie.cn/Tools/Disassemblers/)\n   - 需要替换安装路径下的动态库\n   - 还不支持 debugger\n1. 可以远程调试\n1. 可以从不同 level 查看各个 section 内容\n1. 查看各种 level 代码\n1. 窗口划分，可同时显示不同级别代码\n1. 图形化做的不错\n\n## [cutter](https://github.com/rizinorg/cutter)\n\n1. [官网](https://cutter.re/)\n\n## x64dbg\n\n1. 只试用 windows\n\n## [cheat-engine](https://github.com/cheat-engine/cheat-engine)\n\n## base\n\n1. 关键在读懂汇编\n1. [反编译工具集合](https://www.52pojie.cn/forum.php?mod=forumdisplay&fid=4&filter=typeid&typeid=123)\n1. [合集 2](https://down.52pojie.cn/Tools/Disassemblers/)\n1. 反编译器： 从二进制到代码\n"},{"title":"go","url":"/2023/09/04/go/","content":"\n## basic\n\n1. `sudo apt install golang`\n1. `go env -w GOPROXY=https://goproxy.cn`\n1. `export PATH=$PATH:$GOPATH/bin`\n1. `go install github.com/google/pprof@latest`\n"},{"title":"计算机原理","url":"/2023/08/24/计算机原理/","content":"\n## [netdata](https://github.com/netdata/netdata)\n\n1. [使用说明](https://getiot.tech/zh/foss/netdata)\n\n## [跑分软件](https://post.smzdm.com/p/aox560x7/)\n\n1. [windows aida64](https://www.aida64.com/downloads/YWY1MWUxM2E=)\n\n   - 工具 -> 内存缓存测试 -> 有内存类型\n   - 最下面有性能测试\n   - [破解](https://www.extremexbb.com/aida64-keys/) 使用: 6.85.6300 版本\n\n1. [aida64](https://www.aida64.com/downloads/OThhYjQxZDU=)\n\n## base\n\n1. top 出来的 core 数是逻辑内核，例如：windows 系统显示 4 个物理 core, 8 个逻辑 core， wsl 里 top 显示的 8core\n1. lscpu 可以看出逻辑 core 和物理 core\n\n## tools\n\n1. `likwid-topology`(good) 显示有关硬件拓扑的详细信息，例如 CPU、缓存、NUMA 域等\n1. [cpuid](https://zh.wikipedia.org/wiki/CPUID) CPUID 指令是一条 x86 架构中的的扩展指令（此处的扩展指相对 i80386），其操作码助记符缩写于“CPU 识别”（CPU Identification），其作用是返回特定的 CPU 信息\n1. [cpuid 另一个](https://github.com/klauspost/cpuid/releases)\n1. `lscpu`\n   - `-C` 显示详细 cache 信息\n   - cores 和 sockets 区别 [tutorial1](https://blog.rwth-aachen.de/hpc_import_20210107/attachments/20056127/24117298.pdf)\n1. [cpufreq](https://sunpma.com/115.html)\n   - `sudo apt-get install cpufrequtils`\n   - `cpufreq-info | grep \"current CPU\"`查看各 core cpu 频率\n   - `for (( i = 0; i<100; i++ )); do echo $i;  cpufreq-info | grep \"current CPU\"; sleep 1; done`\n   - `for (( i = 0; i<100; i++ )); do echo -n \"$i:    \";  cpufreq-info | grep \"current CPU\" | grep -o '[0-9.]* [a-zA-Z]*Hz' | awk '{printf \"%s,\\t  \", $0} END {print \"\"}'; sleep 1; done`\n   - `for (( i = 0; i<100; i++ )); do echo -n \"$i:    \";  cpufreq-info | grep \"current CPU\" | grep -o '[0-9.]* [a-zA-Z]*Hz' | awk '{printf \"%d:%s,\\t  \", NR, $0} END {print \"\"}'; sleep 1; done`\n   - `cpufreq-set -g performance` 保持最大频率\n\n## cpu 性能测试\n\n1. [各平台各性能指标计算方法](https://github.com/RRZE-HPC/likwid/tree/master/groups)\n1. 理论浮点运行峰值 = CPU 主频 × CPU 核心数 × 每周期浮点运算次数。\n1. `Linpack`：这是最著名的浮点性能测试之一。HPL（高性能 Linpack）版本用于排名全球 TOP500 的最强大超级计算机。您可以在单个机器上运行 Linpack 来获取其浮点性能。\n1. `Flops.c`：这是一个简单的 C 程序，用于测量机器的浮点性能。它执行加法、乘法、除法和平方根操作，并报告 GFLOPS 性能。\n1. `Geekbench`：这是一个流行的跨平台基准测试工具，它提供了浮点性能的测量。\n1. `Phoronix Test Suite`：这是一个开源的、综合的测试和基准测试框架，它包括许多专门针对浮点性能的测试。\n1. [各种 benchmark 及数据](https://github.com/kreier/benchmark/tree/main)\n1. [hpl 各种测试](https://www.netlib.org/benchmark/)\n1. pidstat 1 -----> `process usage`\n   - 可以看进程分配在哪一个 cpu 核上\n1. perf stat 可以查看 CPU 真实利用率： CPUs utilized, 不包括等待时间，自旋时间等。真实利用率比 top 查看的利用率要低很多。\n1. top 查看的利用率： 如果 CPU 没有运行在内核的 idle 线程，就认为 CPU 在被使用。当 cpu 阻塞并等待内存访问时，也可能显示较高的利用率。\n\n### 指标\n\n1. `flops`\n   - [nvidia 计算方法](https://www.jianshu.com/p/b1ceaa7effa8)\n1. `ops`\n1. `DMIPS`\n1. `DMIPS/MHz`\n1. `MAC`\n1. 指令性能\n\n### likwid\n\n1. [测 flops 性能](https://github.com/RRZE-HPC/likwid/wiki/Tutorial%3A-Empirical-Roofline-Model)\n\n### [flops.c](https://github.com/AMDmi3/flops)\n\n```sh\ngit clone https://github.com/AMDmi3/flops.git\ncd flops && make\n```\n\n1.  测试的是单核性能 flops\n\n### linpack\n\n1. [使用说明](https://github.com/UNINETTSigma2/documentation/blob/main/jobs/arm-perf/linpack.md)\n2. [src test](https://elinux.org/RPi_Performance)\n\n```sh\nhttps://www.netlib.org/benchmark/linpackc.new\ngcc -O3 -o linpack  linpack.c\n```\n\n### [dhrystone](https://github.com/kreier/benchmark/tree/main/dhrystone)\n\n1. 目前找到的达到最大 ops 和最大 IPC 的程序，使用自己写的 perf monitor 监控得到.\n1. [ARM 各内核系列整型运算能力对比---DMIPS / MHz](https://blog.csdn.net/qq_21475601/article/details/106564903)\n1. MIPS: 每秒执行了多少百万条指令。DMIPS：D 是 Dhrystone 的缩写，在 MIPS 前面加上 Dhrystone （整数运算），用于测整数计算能力。进程占用 DMIPS = 总的 DMIPS \\* 进程占用 CPU 百分比\n1. I got 2898550.8 Dhrystones per Second, and I divided by 1757 to get 1649 DMIPS/core. And then I divided by 1200 to get 1.37 DMIPS/MHz/core.\n1. A55 单核算力： 2.7DMIPS/MHz\\*1.2GHz=3.24 KDMIPS, 每核没时钟周期处理 2.7 指令\n1. KDMIPS 是算力表示， DMIPS/MHz 是密度表示\n1. perf stat -ddd 显示频率\n1. [Keith-S-Thompson/dhrystone](https://github.com/Keith-S-Thompson/dhrystone/tree/master)\n1. [sbc-bench/src/dhrystone](https://github.com/fm4dd/sbc-benchmarks/tree/master/sbc-bench/src/dhrystone)\n1. use\n\n```sh\nwget https://homepages.cwi.nl/~steven/dry.c\nsh dry.c\n```\n\n### [phoronix-test-suite](https://github.com/phoronix-test-suite/phoronix-test-suite)\n\n### [MegPeak](https://github.com/MegEngine/MegPeak)\n\n1. 可以测 memory`GOPS`, 各指令性能\n1. 可以测 roofline, cpu gflops\n1. [MegPeak——让你更懂你的处理器](https://zhuanlan.zhihu.com/p/522007924)\n\n### [clpeak](https://github.com/krrishnarraj/clpeak)\n\n1. 测试 opencl 设备性能\n\n## links\n\n1. [（good)各种动画](https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/)\n1. [(有动画)计算机组成原理（4）-中央处理器 CPU](https://blog.csdn.net/chen1083376511/article/details/81941318)\n1. [cpu](http://note.wcoder.com/computer/cpu.md)\n1. [plantegg.github.io/categories/CPU/](https://plantegg.github.io/categories/CPU/)\n1. [cpu_features](https://github.com/google/cpu_features) c++ 获取 cpu feature\n"},{"title":"pandas","url":"/2023/07/11/pandas/","content":"\n## [describe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html)\n\n1. 获取统计信息， 可配置\n"},{"title":"data_view","url":"/2023/07/09/data-view/","content":"\n## note\n\n1. openai 数据分析可视化\n\n## idea\n\n1. [可视化工具原则](https://www.rerun.io/blog#principles-for-a-computer-vision-focused-seeingtool)\n1. 使用 rerun 实时或回放监测的数据: 将可视化代码与算法代码分开\n1. 两二进制文件比较服务器(转成 float 对比)\n   - error 画图\n   - 三列, 数据 1， 数据 2， error， error 用色阶表示\n1. [pandas table 颜色设置（好用）](https://pandas.pydata.org/docs/user_guide/style.html), 类似 excel 表格色阶\n1. excel 中可以套用表格格式来美化表格, 利用好色阶，条件格式, 数据条\n1. 将 log 文件拖到浏览器中，生成报告(正则表达式先生成 pandas， 然后生成报告)\n1. csv server\n1. [提高数据可视化效果的五个原则](https://www.51cto.com/article/719697.html)\n1. [excel with python](https://techcommunity.microsoft.com/t5/excel-blog/announcing-python-in-excel-combining-the-power-of-python-and-the/ba-p/3893439)\n\n<!-- more -->\n\n## [apache/superset](https://github.com/apache/superset/tree/master)\n\n1. [online test](https://manage.app.preset.io/app/)\n\n## rerun\n\n1. 可以实时查看结果并回放，后续支持 c++;\n1. [python/plots](https://github.com/rerun-io/rerun/tree/latest/examples/python/plots)\n\n## [PlotNeuralNet](https://github.com/HarisIqbal88/PlotNeuralNet)\n\n## matplotlib\n\n1. [cheatsheets](https://github.com/matplotlib/cheatsheets)\n\n## [seaborn](https://seaborn.pydata.org/index.html)\n\n## [plotly.py](https://github.com/plotly/plotly.py)\n\n## [streamlit](https://github.com/streamlit/streamlit)\n\n1. [csv view server](https://jiaxiyang-streamlit-example-streamlit-app-t8698c.streamlit.app/)\n   - `grep \"diff time\" 1117.log | awk '{print $NF}' | awk 'BEGIN { print \"数据描述\" } { print $0 }' > test.csv` 搜索 log，创建 csv\n   - `paste $(ls *.csv)  -d \",\" > output.csv` 合并多个 csv 文件\n   - `paste $(ls *.csv)  -d \",\" > tmp.csv && tr -d '\\r' < tmp.csv > output.csv && rm tmp.csv` 处理回车符问题: ^M 符号通常表示回车符 (Carriage Return)\n1. [共享的 gallery](https://streamlit.io/gallery)\n1. [cheatsheet](https://daniellewisdl-streamlit-cheat-sheet-app-ytm9sg.streamlit.app/)\n1. [discuss.streamlit.io](https://discuss.streamlit.io/)\n1. [Streamlit-Authenticator](https://github.com/mkhorasani/Streamlit-Authenticator)\n1. NOTE: 测试文件名不能取名 steamlit.py, 否则会引起 circle import\n1. Streamlit 可让您在几分钟（而不是几周）内将数据脚本转变为可共享的 Web 应用程序。\n1. `pip install --upgrade streamlit`\n1. docker 注意端口号\n1. 网页中的 csv 数据点击表头可排序\n\n### 部署到服务器\n\n```\ndocker pull samdobson/streamlit:latest\npip install pip -U -i https://pypi.tuna.tsinghua.edu.cn/simple\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\npip install matplotlib openpyxl\nstreamlit run streamlit_csv_server.py  --server.port 12345\n```\n\n### chatgpt\n\nStreamlit 是一个开源的 Python 库，它使得创建和共享数据驱动的 web 应用程序变得非常简单和快速。它提供了一个直观的 API，可以方便地从数据生成丰富的交互式界面。\n以下是 Streamlit 的一些关键特性：\n\n1. **简单性**：Streamlit 的 API 非常简洁，只需要几行 Python 代码就可以构建一个应用程序。你可以将所有的精力集中在数据和模型上，而不是界面设计和 Web 开发。\n2. **交互性**：Streamlit 支持很多交互元素，例如滑动条、选择框、输入框等等。你可以用这些元素收集用户输入，并实时更新应用程序的输出。\n3. **快速迭代**：Streamlit 的设计哲学是\"先编码，再调整\"。你可以先构建一个基本的应用程序，然后再逐步增加新功能，或者修改现有功能。Streamlit 会自动跟踪你的代码变化，并实时更新应用程序。\n4. **灵活性**：Streamlit 支持 Python 的各种数据处理库（如 Pandas、NumPy）和可视化库（如 Matplotlib、Plotly）。你可以很容易地将这些库与 Streamlit 一起使用。\n5. **部署**：使用 Streamlit Share 或其他云服务（如 Heroku、AWS 等），你可以很容易地将你的应用程序部署到 Web 上，让其他人也可以访问和使用。\n   Streamlit 的工作流程基本上就是这样：首先，你会写一个 Python 脚本，其中包含了你的数据处理和可视化代码，然后你会添加一些 Streamlit 的特殊命令，以创建交互式的用户界面。然后，你可以运行这个脚本，Streamlit 会生成一个可交互的 Web 应用，并在本地打开一个 Web 浏览器窗口显示这个应用。你可以在这个窗口中与你的应用互动，查看不同输入条件下的结果。\n\n### compare\n\n1. Streamlit：如果你正在寻找一个轻量级的，可以快速原型设计和部署机器学习和数据科学应用的工具，Streamlit 是一个很好的选择。它的设计理念是“代码即应用”，并且有一个很直观的接口。\n2. Dash：如果你正在寻找一个更强大的工具，你的项目需要更复杂的交互和可视化，Dash 可能更适合你。Dash 为数据可视化提供了更多的控制权，但也可能需要编写更多的代码。\n3. Panel：Panel 是一个非常灵活的工具，它可以让你在 Jupyter notebook 中创建应用，然后将其转化为独立的 Web 应用。如果你已经习惯于使用 Jupyter 进行数据分析，那么 Panel 可能是一个很好的选择。\n4. Voila：如果你喜欢在 Jupyter notebook 环境中工作，并希望能够无缝地将你的工作转化为交互式 Web 应用，那么 Voila 可能是一个很好的选择。\n5. Shiny：如果你是 R 语言的用户，Shiny 是一个非常强大的工具，用于构建交互式 Web 应用。Shiny 是 R 社区中使用最广泛的工具之一。\n","tags":["DataView","CsvServer"],"categories":["DataView"]},{"title":"matplotlib","url":"/2023/07/05/matplotlib/","content":"\n## links\n\n1. [examples](https://matplotlib.org/stable/gallery/index.html)\n1. [tutorials](https://matplotlib.org/stable/tutorials/introductory/pyplot.html)\n"},{"title":"pip","url":"/2023/06/26/pip/","content":"\n## use\n\n1. `pip list`\n1. `pip3 install --upgrade`\n"},{"title":"conda","url":"/2023/06/26/conda/","content":"\n## NOTE\n\n1. gcc 版本有要求\n1. [清华源切换](https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/)\n1. `unset all_proxy` 不能使用代理，可能出现 install 错误 [link](https://blog.csdn.net/whatday/article/details/109287343)\n1. `conda config --append channels conda-forge`\n\n## basic use\n\n1. `conda config --set auto_activate_base false` 关闭自启动\n1. `conda info` 查看安装情况\n1. `conda env list` list env\n1. `conda list` list package in env\n1. `conda create --name ENVNAME` create env\n1. `conda activate ENVNAME` activate env\n1. `conda deactivate` deactivate env\n1. `conda install PKGNAME=3.1.4` install lib\n1. `conda uninstall PKGNAME` uninstall lib\n\n## .condarc\n\n```sh\nauto_activate_base: false\n\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n```\n\n## links\n\n1. [user-guide/install](https://docs.conda.io/projects/conda/en/latest/user-guide/install/linux.html)\n1. [miniconda](https://docs.conda.io/en/latest/miniconda.html#linux-installers) 选择对应 python 版本, install 时可以选路径\n1. [user-guide/configuration](https://docs.conda.io/projects/conda/en/latest/user-guide/configuration/index.html#)\n1. [cheatsheets/conda-4.14.pdf](https://github.com/conda/conda/blob/main/docs/source/user-guide/cheatsheets/conda-4.14.pdf)\n1. [build python from source](https://github.com/deadsnakes/docs/blob/main/Building-Deadsnakes-Packages-from-Git.rst) 编译之后需要前一级目录 `sudo dpkg -i *.deb`\n"},{"title":"VPN","url":"/2023/06/25/VPN/","content":"\n## NOTE\n\n1. `export all_proxy=\"socks5://${IP}:7890\"` linux 服务器可以设置 all_proxy 来翻墙， clash 鼠标悬浮 `Allow Lan` 可以看到对应 IP\n1. Proxies 选择 Rule，可以同时连接公司内网和外网，不要选 Global，不能连接内网\n\n## links\n\n1. [agentneo](https://agentneo.tech/) 使用 clash 客户端\n1. [WSL 2 配置代理 clash](https://solidspoon.xyz/2021/02/17/%E9%85%8D%E7%BD%AEWSL2%E4%BD%BF%E7%94%A8Windows%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/) 配置 WSL2 使用 Windows 代理上网 有用\n1. [docker build 以及 docker run 时使用 host 网络的方法](http://www.debugself.com/2018/01/17/docker_network/)\n1. [vscode proxy setting](https://device.harmonyos.com/cn/docs/documentation/guide/vscode_proxy-0000001074231144)\n"},{"title":"onnxruntime","url":"/2023/06/12/onnxruntime/","content":"\n## concept\n\n![ONNX 运行时高级架构](https://developer-blogs.nvidia.com/wp-content/uploads/2022/12/image3-2.png)\nONNX Runtime 是一个性能优秀的跨平台推理（inference）引擎，用于 ONNX（Open Neural Network Exchange）模型。它具有灵活的支持和高效的性能，可用于各种硬件设备（包括在边缘设备上）和操作系统。\n\n以下是关于 ONNX Runtime 的一些基本概念：\n\n1. **ONNX 模型执行**：ONNX Runtime 提供了执行 ONNX 模型的能力。你可以加载一个 ONNX 模型，然后使用 ONNX Runtime 来进行推理。\n2. **硬件优化**：ONNX Runtime 被设计为能够充分利用不同的硬件能力。它支持 CPU，GPU，以及更专用的硬件加速器（如 Microsoft 的 DirectML 和 NVIDIA 的 TensorRT）。\n3. **跨平台**：ONNX Runtime 可以在多种操作系统（包括 Windows，Linux，和 Mac OS）上运行，并且支持多种硬件设备，包括在边缘设备上。\n4. **语言绑定**：ONNX Runtime 提供了多种语言的 API，包括 C，C++，Python，C#，Java，和 JavaScript，使得开发者可以在他们选择的语言中使用 ONNX Runtime。\n5. **会话（Session）**：在 ONNX Runtime 中，一次模型的推理被称为一个会话。你可以创建一个会话，然后通过这个会话来执行模型。\n6. **提供者（Providers）**：ONNX Runtime 支持通过不同的“提供者”来执行模型。这些提供者可以是 CPU，CUDA（NVIDIA GPUs），TensorRT（NVIDIA GPUs），DirectML（Windows GPUs），OpenVINO（Intel GPUs）等。\n   通过 ONNX Runtime，开发者可以将 ONNX 模型部署到各种平台和设备上，同时保持良好的性能和灵活性。\n\n### [Providers](https://onnxruntime.ai/docs/execution-providers/)\n\nONNX Runtime 的\"提供者\"（Providers）是执行 ONNX 模型运算的后端引擎。每种提供者都是为特定的硬件或者软件平台优化的。使用正确的提供者可以大大提高模型的执行效率。\n以下是一些主要的 ONNX Runtime 提供者：\n\n1. **CPU Execution Provider**: CPU 提供者是 ONNX Runtime 的默认提供者，它在 CPU 上执行模型运算。CPU 提供者在所有系统上都可用，不需要任何额外的依赖。\n2. **CUDA Execution Provider**: CUDA 提供者是为 NVIDIA 的 GPU 优化的，它使用 CUDA 和 cuDNN 库来在 GPU 上执行模型运算。使用 CUDA 提供者需要安装 CUDA 和 cuDNN。\n3. **TensorRT Execution Provider**: TensorRT 提供者也是为 NVIDIA 的 GPU 优化的，但是它使用 NVIDIA 的 TensorRT 库来执行模型运算。TensorRT 提供者可以提供比 CUDA 提供者更高的性能，但是需要更复杂的设置。\n4. **DirectML Execution Provider**: DirectML 提供者是为 Windows 系统上的 GPU 优化的，它使用 Microsoft 的 DirectML 库来执行模型运算。DirectML 提供者可以在任何支持 DirectX 12 的 Windows 系统上使用。\n5. **OpenVINO Execution Provider**: OpenVINO 提供者是为 Intel 的硬件优化的，包括 CPU，GPU，VPU，和 FPGA。它使用 Intel 的 OpenVINO 库来执行模型运算。\n6. **Nuphar Execution Provider**: Nuphar 是一个为 CPU 优化的 JIT 编译器，主要用于对模型中的循环结构进行优化。\n7. **VitisAI Execution Provider**: VitisAI 提供者是为 Xilinx FPGA 硬件优化的，使用了 Xilinx 的 Vitis AI 库。\n   当你创建一个 ONNX Runtime 会话时，你可以指定用于执行模型运算的提供者。如果你没有指定提供者，ONNX Runtime 会使用默认的 CPU 提供者。如果你在一个支持 GPU 的系统上运行 ONNX Runtime，并且你已经安装了相应的依赖，你可以选择使用 CUDA，TensorRT，DirectML，或者 OpenVINO 提供者来提高模型的执行效率。\n   Note: provider 在 onnxruntime repo 里\n\n## TVM and onnxruntime\n\nTVM 是一个开源的机器学习编译器堆栈，它可以将机器学习模型从各种框架（例如 TensorFlow、PyTorch、ONNX、Keras 等）优化编译到各种硬件（例如 CPU、GPU、FPGA、ASIC 等）。\nONNX Runtime 是一个用于运行和推理 ONNX 模型的高性能跨平台推理引擎。然而，TVM 的关键优势在于它的自动调度程序和编译器栈，能够生成优化的计算内核，而 ONNX Runtime 的优势在于它对 ONNX 模型的广泛支持以及一系列优化技术。ONNX Runtime 支持多种硬件平台，包括 CPU、GPU 和专用加速器。它可以在不同硬件上运行，无需重新编译模型。\nTVM 和 ONNX Runtime 的结合可以在两者之间提供一个桥梁，使得开发者可以利用 TVM 的优化能力，同时使用 ONNX Runtime 的灵活性和易用性。\nONNX Runtime 和 TVM 结合的一种方式是使用 TVM 作为 ONNX Runtime 的一个执行提供者。TVM 有一个 ONNX 编译器，可以将 ONNX 模型编译成 TVM 模块，然后在 ONNX Runtime 中注册这个模块作为一个提供者，这样 ONNX Runtime 就可以使用 TVM 来执行模型。\n另一种方式是使用 TVM 来优化 ONNX 模型，然后在 ONNX Runtime 中执行优化后的模型。这种方法的优点是可以使用 TVM 的自动调度程序和编译器栈来优化模型，然后使用 ONNX Runtime 的高效运行时来执行优化后的模型。\n这两种方法都需要一些设置和配置，并且可能需要修改 ONNX Runtime 或者 TVM 的代码。然而，它们都可以提供更好的性能和更高的灵活性，使得开发者可以更好地利用他们的硬件资源。\n\nTVM 和 ONNX Runtime 都是用于机器学习模型推理的工具，但它们各自有着不同的优势和设计目标。\n**TVM**是一个开源的深度学习编译器和优化器，它的主要目标是提供一种灵活的方式来优化和部署深度学习模型到各种硬件平台，包括 CPU、GPU、FPGA 和 ASIC 等。TVM 的优势在于：\n\n1. **硬件无关的优化**：TVM 的自动调度功能可以生成针对特定硬件优化的代码，无论这个硬件是 CPU、GPU 还是其他类型的硬件。\n2. **端到端的编译优化**：TVM 包括了从高层图优化到底层代码生成的全流程优化。\n3. **支持多种深度学习框架**：TVM 可以接受多种框架的模型，包括 TensorFlow、PyTorch、MXNet、Keras、ONNX 等。\n   而**ONNX Runtime**是一个用于运行和推理 ONNX 模型的跨平台高性能推理引擎，它的主要目标是提供一种高效、灵活且易于使用的方式来部署和执行 ONNX 模型。ONNX Runtime 的优势在于：\n4. **广泛的 ONNX 模型支持**：ONNX Runtime 支持 ONNX 模型中的所有运算符和特性。\n5. **性能优化**：ONNX Runtime 包含了一系列优化技术，包括图优化、运算符融合、内存优化等，以提高模型的执行性能。\n6. **硬件加速**：通过不同的执行提供者（如 CUDA、TensorRT、DirectML 等），ONNX Runtime 可以利用硬件加速器来提高模型的执行速度。\n   两者之间并非完全的竞争关系，它们可以相互结合，例如使用 TVM 作为 ONNX Runtime 的一个执行提供者，使得 ONNX Runtime 能够利用 TVM 的优化能力。\n\n## install\n\n1. `pip install onnxruntime`\n1. [c++直接下载编译好的库](https://github.com/microsoft/onnxruntime/releases)\n\n## [sample](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/c_cxx)\n\n1. 测试\n\n```sh\ngit clone --depth=1 https://github.com/microsoft/onnxruntime-inference-examples.git\ncd onnxruntime-inference-examples/c_cxx/\nmake -p build\ncd build\ncmake -DONNXRUNTIME_ROOTDIR=/xxx/onnxruntime-linux-x64-1.15.1 ..\nmake -j4\ncurl https://media.githubusercontent.com/media/onnx/models/main/vision/classification/squeezenet/model/squeezenet1.0-7.onnx --output squeezenet.onnx\n./build/model-explorer/model-explorer squeezenet.onnx\n```\n\n1. [c\\+\\+ sample code](https://github.com/microsoft/onnxruntime-inference-examples/blob/main/c_cxx/model-explorer/model-explorer.cpp)\n\n```c++\n#include \"onnxruntime_cxx_api.h\"\n\n// Load the model and create InferenceSession\nOrt::Env env;\nstd::string model_path = \"path/to/your/onnx/model\";\nOrt::Session session(env, model_path, Ort::SessionOptions{ nullptr });\n\n// Load and preprocess the input image to\n// inputTensor, inputNames, and outputNames\n...\n\n// Run inference\nstd::vector outputTensors =\n session.Run(Ort::RunOptions{nullptr},\n \t\t\tinputNames.data(),\n\t\t\t&inputTensor,\n\t\t\tinputNames.size(),\n\t\t\toutputNames.data(),\n\t\t\toutputNames.size());\n\nconst float* outputDataPtr = outputTensors[0].GetTensorMutableData();\nstd::cout << outputDataPtr[0] << std::endl;\n```\n\n1. sample 解析\n   - Session 处理各种环境信息，比如模型信息， 环境变量等，同时也进行调度， 不负责管理模型输入输出数据\n   - 由 Ort::Value::CreateTensor 申请模型输入输出的内存， 所有权归上层应用\n\n## 模型优化\n\n### sample\n\n## links\n\n1. [支持的平台选择](https://onnxruntime.ai/index.html#getStartedTable)\n1. [onnxruntime.ai](https://onnxruntime.ai/docs/execution-providers/)\n1. [docs](https://onnxruntime.ai/docs/execution-providers/)\n1. [onnxruntime/core/providers](https://github.com/microsoft/onnxruntime/tree/eed02a3f782407e569c29a8a86c58a4d398d0b0e/onnxruntime/core/providers)\n1. [vitis ai onnxruntime samples](https://github.com/Xilinx/Vitis-AI/tree/c55b7565bde608dd65dda94abea154ad7db4d594/examples/vai_library/samples_onnx)\n1. [onnxruntime vitis support](https://github.com/search?q=repo%3Amicrosoft%2Fonnxruntime%20USE_VITISAI&type=code)\n1. [tda4 onnx runtime](https://software-dl.ti.com/jacinto7/esd/processor-sdk-rtos-jacinto7/07_03_00_07/exports/docs/tidl_j7_02_00_00_07/ti_dl/docs/user_guide_html/md_tidl_osr_onnxrt_tidl.html)\n1. [doxygen](https://onnxruntime.ai/docs/api/c/struct_ort_1_1_session.html)\n1. [推理模型部署(一)：ONNX runtime 实践](https://zhuanlan.zhihu.com/p/582974246)\n"},{"title":"Quantization","url":"/2023/06/12/Quantization/","content":"\n## 量化（定浮点转换）\n\n1. https://blog.csdn.net/niaolianjiulin/article/details/82764511\n\n## links\n\n1. [Pytorch 模型量化](https://www.cnblogs.com/LXP-Never/p/16822727.html)\n","tags":["AI","Quantization"]},{"title":"pytorch","url":"/2023/06/09/pytorch/","content":"\n## samples\n\n1. pytorch model to onnx\n\n```python\nimport torch\nimport torchvision.models as models\nimport torch.onnx as onnx\n\n# 加载预训练模型\nmodel = models.resnet18(pretrained=True)\n\n# 创建一个输入张量作为示例\ninput_data = torch.randn(1, 3, 224, 224)\n\n# 设置模型为推理模式\nmodel.eval()\n\n# 将模型和输入张量转换为ONNX格式\nonnx_path = \"model.onnx\"\nonnx.export(model, input_data, onnx_path)\n\nprint(\"模型已成功转换为ONNX格式并保存在:\", onnx_path)\n```\n\n2. 量化模型\n\n```python\n\n```\n"},{"title":"colab","url":"/2023/06/08/colab/","content":"\n## link\n\n1. [importing_libraries](https://colab.research.google.com/notebooks/snippets/importing_libraries.ipynb)\n"},{"title":"roadmap","url":"/2023/06/08/roadmap/","content":"\n## 如何成为资深 AI 推理软件工程师(chatgpt)\n\n成为资深 AI 推理软件工程师需要具备以下关键步骤和能力：\n\n1. 建立扎实的 AI 基础：首先，建立扎实的人工智能基础知识。深入了解机器学习和深度学习的基本概念、算法和原理，包括神经网络、优化算法、模型评估等。\n2. 学习推理引擎和框架：研究和学习不同的 AI 推理引擎和框架，如 TensorRT、OpenVINO、TVM 等。了解它们的特点、优化技术和部署方法，熟悉使用它们进行模型推理的流程和工具。\n3. 实践推理项目：通过实践推理项目来应用所学的知识。参与真实的 AI 推理项目，涉及模型优化、推理性能调优、模型部署等方面。通过实践，积累经验并提升自己在 AI 推理软件工程方面的能力。\n4. 熟悉硬件加速和优化技术：AI 推理软件工程师需要了解硬件加速和优化技术，如 GPU、FPGA 等。学习并熟悉如何利用硬件加速器进行模型推理的优化，包括模型转换、量化、融合等技术。\n5. 深入了解模型优化和压缩：掌握模型优化和压缩的技术，以减小模型的大小和计算量，提高推理性能。了解剪枝、量化、知识蒸馏等技术，并能够应用到实际项目中。\n6. 掌握性能分析和调优工具：熟悉性能分析和调优工具，如 TensorBoard、NVIDIA Nsight 等。能够使用这些工具来分析和调优模型推理的性能瓶颈，并做出相应的优化策略。\n7. 深入理解模型部署和集成：了解模型部署和集成的流程和工具。掌握常见的部署方式，如嵌入式设备、边缘计算平台、云平台等，能够将优化后的模型成功部署到目标平台上。\n8. 持续学习和关注最新技术：AI 领域发展迅速，持续学习和关注最新的技术和研究成果至关重要。阅读相关的学术论文、技术博客、研讨会等，保持对新技术和方法的敏感度\n\n要成为 AI 推理软件专家，可以采取以下步骤：\n\n1. 建立扎实的 AI 基础知识：深入学习机器学习和深度学习的基本理论、算法和模型。了解常见的神经网络结构和优化算法，如卷积神经网络、循环神经网络、注意力机制等。\n2. 学习推理引擎和框架：熟悉不同的 AI 推理引擎和框架，如 TensorRT、OpenVINO、ONNX Runtime 等。了解它们的特点、优化技术和部署方法，掌握使用它们进行模型推理和优化的技巧。\n3. 实践推理项目：参与实际的 AI 推理项目，从数据预处理、模型选择、推理性能优化等方面积累实践经验。通过实践中的挑战和解决方案，提升在 AI 推理软件工程中的能力。\n4. 研究模型优化和压缩技术：深入研究模型优化和压缩技术，如剪枝、量化、蒸馏等。了解如何减小模型的大小和计算量，提高推理性能，并能够应用这些技术来优化和压缩模型。\n5. 掌握性能分析和调优工具：熟悉性能分析和调优工具，如 TensorBoard、Profiler 等。学会使用这些工具来分析和评估模型的推理性能，并针对性地进行调优。\n6. 深入了解硬件加速和优化技术：了解常见的硬件加速器，如 GPU、FPGA 等，并学习如何充分利用硬件加速器提高模型推理的效率和速度。掌握硬件相关的优化技术和工具。\n7. 持续学习和追踪最新技术：AI 领域发展迅速，保持学习和追踪最新技术和研究成果非常重要。阅读学术论文、参加研讨会和会议，关注业界领先公司的技术博客和公开项目，与其他专家进行交流和讨论。\n8. 实践和贡献开源项目：参与开源项目，为 AI 推理软件的开发和优化做出贡献。通过与开源社区的合作和分享，不断提升自己的技能和知识，并展示自己在 AI 推理软件方面的专业能力。\n9. 与领域专家合作：寻求与领域内的专家合作和交流，参与相关的研究团队或实验室，共同探讨和解决 AI 推理软件领域的问题。与其他专家的合作将加速个人成长和知识积累。\n\n通过持续的学习、实践和不断提升自身能力，成为 AI 推理软件专家需要一定的时间和经验积累，但坚持不懈和热爱学习将助您在这个领域取得成功。\n\n## 如何学习推理优化技术\n\n要学习推理优化技术，可以按照以下步骤进行：\n\n1. 建立基础知识：首先，建立对深度学习模型推理的基本理解。了解常用的深度学习框架，如 TensorFlow、PyTorch 等，以及它们的推理过程和优化方法。掌握深度学习模型的基本结构和常用的推理算法。\n2. 学习推理优化技术的理论：深入学习推理优化技术的理论知识。这包括模型剪枝、量化、蒸馏、深度压缩等技术。了解这些技术的原理、优势和适用场景。阅读相关的学术论文、研究报告和专业书籍，掌握推理优化技术的最新研究成果。\n3. 掌握推理优化工具和框架：学习使用推理优化工具和框架，如 TVM、ONNX Runtime、NVIDIA TensorRT 等。了解它们的使用方法、API 接口和优化技术支持。通过实际操作和示例代码，掌握如何在具体的环境中应用推理优化技术。\n4. 实践项目和案例研究：选择一些实际的项目和案例，应用推理优化技术进行实践研究。可以使用开源数据集和模型，尝试不同的推理优化方法，并进行性能对比和评估。通过实践项目，加深对推理优化技术的理解和掌握。\n5. 参加培训和研讨会：参加相关的培训课程、研讨会和工作坊，了解推理优化技术的最新进展和应用实践。这些培训活动通常由专业机构、学术界和工业界组织举办，提供专业指导和实际操作经验。\n6. 加入社区和论坛：加入相关的学术社区、开发者论坛和技术交流平台，与其他学习者和专家进行交流和讨论。这些社区和论坛提供了学习资源、问题解答和经验分享，可以获取更多的学习资料和实践建议。\n7. 持续学习和实践：推理优化技术是一个不断发展和演进的领域，需要持续学习和实践。跟踪最新的研究成果和技术进展，参与相关的竞赛和挑战，与行业内的专家保持联系，不断提升自己的技能和知识水平。\n   总之，学习推理优化技术需要坚实的基础知识、实践项目的经验和与专家的交流。通过不断学习和实践，逐步提升自己的技能，成为一名熟练的推理优化技术专家。\n\n## 如何学习推理框架\n\n学习推理框架的步骤如下：\n\n1. 确定学习目标：明确你想学习的推理框架，如 TensorRT、ONNX Runtime、OpenVINO 等。了解每个框架的特点、适用场景和优势，选择符合你学习目标和需求的框架。\n2. 学习基础知识：掌握深度学习的基础知识，包括神经网络的结构、训练和推理过程等。了解常见的深度学习框架，如 TensorFlow、PyTorch 等，并学习它们的基本使用方法和 API。\n3. 框架官方文档：查阅所选推理框架的官方文档。官方文档是学习和使用框架的最重要资源，其中包含框架的详细说明、API 文档、示例代码和教程。仔细阅读官方文档，了解框架的功能、接口和使用方法。\n4. 在线教程和视频：寻找相关的在线教程和视频资源。许多推理框架提供官方的在线教程，可以帮助你快速入门和掌握基本操作。此外，还可以搜索其他人分享的教程和视频，如博客文章、YouTube 视频等。\n5. 实践项目：选择一些实际的项目来应用所学的推理框架。可以使用开源的深度学习模型和数据集，将它们加载到推理框架中，进行模型推理和结果分析。通过实践项目，加深对框架的理解和掌握。\n6. 社区交流和讨论：参与相关的开发者社区和技术论坛，与其他学习者和专家进行交流和讨论。这些社区和论坛提供了宝贵的学习资源、问题解答和经验分享，可以从中获得更多的学习资料和实践建议。\n7. 持续学习和更新：推理框架和相关技术在不断发展和更新，保持学习的持续性非常重要。关注最新的技术进展、研究成果和开发者社区的动态，了解最新的框架版本和功能，不断更新自己的知识和技能。\n\n## 如何学习 python\n\n成为 Python 专家需要付出一定的努力和持续的学习。以下是一些建议：\n\n1. 扎实的基础知识：掌握 Python 的基础知识，包括语法、数据类型、流程控制、函数、模块等。理解 Python 的核心概念和特性，建立坚实的基础。\n2. 深入学习核心库：熟悉 Python 的核心库，如 NumPy、Pandas、Matplotlib 等。这些库是 Python 数据分析和科学计算的基石，深入学习它们的使用方法和高级特性。\n3. 探索常用库和框架：学习并熟悉 Python 的常用库和框架，如 Django、Flask、TensorFlow、PyTorch 等。了解它们的特点、用途和 API，能够使用它们构建实际项目。\n4. 阅读优秀的 Python 代码：阅读优秀的 Python 代码可以帮助你学习和理解高效、优雅的编程风格和技巧。参考开源项目、博客文章、书籍等资源，学习其他 Python 专家的实际应用。\n5. 实践项目：选择一些实际的项目来应用 Python 技术。通过实践项目，深入理解 Python 在不同领域的应用，掌握解决问题的实际方法和技巧。\n6. 参与社区和开源项目：积极参与 Python 开发者社区和开源项目。与其他 Python 专家交流和讨论，分享自己的经验和知识。通过参与开源项目，提升自己的编码能力和项目管理能力。\n7. 持续学习和更新：Python 生态系统在不断发展和更新，保持学习的持续性非常重要。关注最新的 Python 版本、库和框架的发布，了解最新的技术趋势和最佳实践。\n8. 掌握调试和性能优化技巧：学会使用调试工具和技巧来解决代码中的问题。了解 Python 的性能优化技巧，提高代码的执行效率和资源利用率。\n9. 教学和分享经验：通过教学和分享经验，巩固自己的知识，并帮助其他人学习 Python。可以编写博客文章、教程，参与技术分享活动等。\n   最重要的是保持对 Python 的热情和持续的学习态度。不断学习新知识，探索新技术，并将其应用到实际项目中，才能逐步成为 Python 专家。\n\n## AI 推理框架\n\nAI 推理框架是用于部署和执行训练好的深度学习模型进行推理（预测）的软件工具。这些框架提供了一套接口和工具，使得将训练好的模型部署到生产环境中变得更加容易和高效。\n以下是一些常见的 AI 推理框架：\n\n1. TensorFlow：由 Google 开发的开源深度学习框架，提供了高度灵活的图计算模型和丰富的工具和库。TensorFlow 的推理部分包括 TensorFlow Serving 和 TensorFlow Lite，用于在服务器和嵌入式设备上进行推理。\n2. PyTorch：由 Facebook 开发的开源深度学习框架，提供了动态图计算模型和易用性。PyTorch 的推理部分包括 TorchScript 和 TorchServe，用于在生产环境中进行高性能推理。\n3. ONNX：开放神经网络交换格式（Open Neural Network Exchange），是一种开放的中间表示格式，可用于在不同的深度学习框架之间转换和共享模型。ONNX 定义了一套通用的推理规范，使得模型能够在支持 ONNX 的框架中进行部署和执行。\n4. TensorRT：英伟达（NVIDIA）推出的推理加速引擎，针对英伟达 GPU 进行了优化。TensorRT 通过网络优化、低精度推理和并行计算等技术，提供高性能和低延迟的深度学习推理能力。\n5. OpenVINO：英特尔（Intel）推出的开放式视觉推理和神经网络优化工具包，用于在英特尔硬件上进行高效的深度学习推理。OpenVINO 支持多种模型优化技术，包括量化、剪枝和硬件加速等。\n   这些 AI 推理框架都有各自的特点和优势，选择合适的框架取决于你的应用需求、硬件平台和编程偏好。学习和掌握这些框架可以帮助你有效地进行深度学习模型的推理部署，并实现高性能和高效能的预测任务。\n\n## collect\n\n1. 深度学习基础\n1. onnx\n   - 熟悉规范\n1. onnx runtime\n   - 推理\n   - 模型优化， 量化\n1. TVM\n1. MLIR IREE\n1. TensorRT\n   - 各种教程\n   - c++ 推理接口, sample, plugin\n1. pytorch\n1. 模型优化和压缩技术(剪枝、量化、 蒸馏)\n1. [ncnn](https://github.com/Tencent/ncnn)\n1. Modular vs OctoML (MLIR vs TVM)\n   - OctoML: 是一个真正的“输入模型，自动化输出硬件和软件”，而且随时可以部署\n1. LLVM\n   - 学习模块化\n1. 汇编\n1. neon\n1. dsp\n1. gpu cuda 加速\n1. 计算机体系结构\n1. 熟悉常用的算子\n1. chatgpt 使用: vscode ...\n1. 线性代数\n1. python\n1. 性能优化\n1. 推理两大主题： 内存管理(onnx runtime tensor) + 调度(onnx runtime session)\n1. 内存管理\n   - [memory-allocators-101-write-a-simple-memory](https://arjunsreedharan.org/post/148675821737/memory-allocators-101-write-a-simple-memory)\n   - malloc 源码\n1. 调度\n   - dag\n\n## links\n\n1. [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)\n1. [LLVM 之父 Chris Lattner：我的 AI 基础设施软件构建理念](https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247492618&idx=1&sn=a20f4828b9ab3e3cee3fedfd906e0eb2&chksm=fe426a3cc935e32a8312ce9efbb4f2640787508d3e811579bbffe918685cdb07a8bd8e3ffc4b&scene=132&exptype=timeline_recommend_article_extendread_samebiz#wechat_redirect)\n1. [TVM：成为深度学习领域的“Linux”](https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247487015&idx=1&sn=04282e2d15eca05eb56062062b46e781&chksm=fe418011c9360907048966af43299fa55b570c9d634c4bcdb3702c6e4d8101a72ef07d5ec77f&scene=21#wechat_redirect)\n","tags":["Roadmap"],"categories":["Others","Roadmap"]},{"title":"AI-ops","url":"/2023/06/08/AI-ops/","content":"\n## NOTE\n\n1. [Operators](https://github.com/onnx/onnx/blob/main/docs/Operators.md)\n1. [torch.nn](https://pytorch.org/docs/stable/nn.html)\n1. [netron 在线打开 onnx](https://netron.app/)\n1. [arm 官方加速库](https://github.com/ARM-software/ComputeLibrary)\n\n## 常见的算子\n\n深度学习中常见的算子包括：\n\n1. 卷积层 (Convolutional Layer)：用于提取输入数据的特征，通过卷积操作在输入数据上滑动卷积核，并对每个位置进行乘法累加操作。\n2. 池化层 (Pooling Layer)：用于降低特征图的空间维度，常见的池化操作包括最大池化和平均池化，通过选取窗口中的最大值或平均值来减小特征图的大小。\n3. 全连接层 (Fully Connected Layer)：将输入数据的每个元素与权重相乘并加上偏置，得到输出向量，常用于将卷积层或池化层的输出展平并连接到最终的分类或回归层。\n4. 激活函数 (Activation Function)：引入非线性变换，增加模型的表达能力。常见的激活函数包括 ReLU (Rectified Linear Unit)、Sigmoid、Tanh、Leaky ReLU 等。\n5. 批归一化 (Batch Normalization)：用于提高网络的训练速度和稳定性，通过对每个小批量数据进行归一化操作，减少内部协变量偏移。\n6. 残差连接 (Residual Connection)：用于解决深层网络的梯度消失和梯度爆炸问题，通过将输入直接与输出相加，使得网络可以学习残差信息。\n7. 循环神经网络 (Recurrent Neural Network, RNN)：用于处理序列数据的神经网络，通过引入循环结构，使得网络可以对先前的信息进行记忆和处理。\n8. 长短期记忆网络 (Long Short-Term Memory, LSTM)：一种特殊的循环神经网络，通过引入门控机制，有效地处理长序列依赖关系。\n9. 注意力机制 (Attention Mechanism)：用于对输入数据中的不同部分分配不同的注意力权重，以便于网络更加关注重要的信息。\n10. 卷积转置层 (Transpose Convolutional Layer)：用于进行上采样操作，通过反卷积操作将低分辨率特征图转换为高分辨率特征图。\n\n以上只是深度学习中常见的一些算子，实际上还有很多其他的算子和结构，不同的模型和任务可能会使用不同的算子组合。\n除了上述提到的常见算子外，深度学习中还有其他一些常用的算子，包括但不限于以下几种：\n\n1. 扩张卷积 (Dilated Convolution)：通过在卷积核中引入间隔，使得卷积核在输入上以不同的空洞率进行卷积操作，从而增加感受野大小。\n2. 反向卷积 (Deconvolution)：也称为转置卷积或分数步长卷积，用于进行上采样操作，将低分辨率特征图转换为高分辨率特征图。\n3. 转移学习 (Transfer Learning)：通过将预训练模型的权重作为初始权重进行微调，从而加快训练速度和提升模型性能。\n4. 高斯滤波 (Gaussian Filtering)：一种平滑图像的操作，通过对每个像素及其周围像素进行加权平均，减小图像中的噪声和细节。\n5. 非极大值抑制 (Non-Maximum Suppression)：用于边缘检测和目标检测等任务中，通过对局部最大值进行抑制，提取出稀疏且准确的边缘或目标位置。\n6. 随机失活 (Dropout)：用于减少过拟合的正则化技术，通过随机将部分神经元的输出设置为零，降低神经元之间的依赖关系。\n7. 权重衰减 (Weight Decay)：一种正则化技术，通过在损失函数中引入权重的 L2 范数惩罚项，降低权重的绝对值，减小模型的复杂度。\n8. 梯度裁剪 (Gradient Clipping)：用于解决梯度爆炸问题，通过限制梯度的范数阈值，防止梯度值过大导致训练不稳定。\n9. 自注意力机制 (Self-Attention Mechanism)：一种注意力机制的变种，用于对序列或图像中不同位置之间的关系进行建模，通过计算位置之间的相对权重来加强或抑制不同位置的表示。\n10. 生成对抗网络 (Generative Adversarial Network, GAN)：由生成器和判别器组成的对抗性模型，通过博弈训练的方式，使生成器逐渐生成逼真的样本。\n\n这些算子在不同的深度学习任务和模型中发挥着重要的作用，可以根据具体的问题和需求选择适合的算子进行使用。\n\n### [激活函数](https://www.jiqizhixin.com/articles/2021-02-24-7)\n\n#### relu\n\n1. `max(0,x)`\n1. [可视化](https://www.desmos.com/calculator/hi1hxgezri)\n1. code\n\n```c++\ndouble relu(double x) {\n    return (x > 0) ? x : 0;\n}\n```\n\n#### sigmoid\n\n1. `1/(1+exp(-x))`\n1. [可视化](https://www.desmos.com/calculator/hp9f98wxrh)\n1. code\n\n```c++\ndouble sigmoid(double x) {\n    return 1.0 / (1.0 + std::exp(-x));\n}\n```\n\n1. 优化： 指数运算很耗时， 查表法\n\n```c++\n#include <iostream>\n#include <cmath>\n#include <vector>\n\n// 查表法实现的Sigmoid函数\ndouble sigmoid(double x, const std::vector<double>& sigmoidTable) {\n    // 查表获取结果\n    double index = (x + 5.0) / 10.0 * sigmoidTable.size();\n    int lowerIndex = static_cast<int>(std::floor(index));\n    int upperIndex = lowerIndex + 1;\n    double lowerValue = sigmoidTable[lowerIndex];\n    double upperValue = sigmoidTable[upperIndex];\n    double fraction = index - lowerIndex;\n\n    return lowerValue + (upperValue - lowerValue) * fraction;\n}\n\nint main() {\n    // 构建查表\n    const int tableSize = 1000;\n    std::vector<double> sigmoidTable(tableSize + 1);\n    for (int i = 0; i <= tableSize; ++i) {\n        double value = static_cast<double>(i) / tableSize * 10.0 - 5.0;\n        sigmoidTable[i] = 1.0 / (1.0 + std::exp(-value));\n    }\n\n    double x = 0.0;\n    double result = sigmoid(x, sigmoidTable);\n\n    std::cout << \"Input: \" << x << std::endl;\n    std::cout << \"Output: \" << result << std::endl;\n\n\n    return 0;\n}\n```\n\n#### tanh\n\n1. 双曲正切函数： `(exp(x) - exp(-x)) / (exp(x) + exp(-x))`\n1. [可视化](https://www.desmos.com/calculator/8xqzjeujqw)\n\n## links\n\n1. [Operators](https://github.com/onnx/onnx/blob/main/docs/Operators.md)\n1. [tensorrt onnx operators.md](https://github.com/onnx/onnx-tensorrt/blob/main/docs/operators.md)\n1. [数学公式可视化](https://www.desmos.com/calculator?lang=zh-CN)\n1. [深度学习编译器 - 算子的高效实现](https://zhuanlan.zhihu.com/p/511043383)\n   - 自动生成算子代码\n1. [onnxruntime/contrib_ops](https://github.com/microsoft/onnxruntime/tree/main/onnxruntime/contrib_ops)\n"},{"title":"chatgpt","url":"/2023/06/01/chatgpt/","content":"\n## 用处\n\n1. 生成文字，可以用作文档、PPT 和简历\n1. python 转换 c++\n1. 优化 c++函数\n1. 深度学习常见的算子？\n1. c++测试配合 [wandbox](https://wandbox.org/) 在线编译\n1. python 测试配合 [google colab](https://colab.research.google.com/) or [codespaces](https://github.com/codespaces)\n1. 解释代码\n1. 添加注释\n\n## samples\n\n1.  如何成为资深 AI 推理软件工程师\n1.  先创建一个大小为 100 的二进制文件， 读入一个二进制文件，输出各元素，float 类型\n1.  如何使用 openmp 优化 c++?\n1.  如何研究推理优化技术\n1.  cuda 核函数测试程序\n1.  pytorch 基本概念\n1.  pytorch to onnx sample\n1.  量化上述模型\n\n## Note\n\n1. vpn 选美国\n1. 注册邮箱后可能需要清理缓存，或者换个浏览器\n\n## links\n\n1. [tutorial](https://mp.weixin.qq.com/s/7k5IlgxKMirED653oJfDgg)\n1. [google bard](https://bard.google.com/)\n1. [LLaMa](https://labs.perplexity.ai/?utm_content=first_codellama&s=u&utm_source=twitter&utm_campaign=labs)\n1. [claude](https://claude.ai/) 可用于分析 csv 文件, 生成文字，用于汇报\n1. [bot-on-anything](https://github.com/zhayujie/bot-on-anything)\n"},{"title":"RISC-V","url":"/2023/05/10/RISC-V/","content":"\n## links\n\n1. [riscv](https://github.com/riscv)\n1. [「硅仙人」吉姆 · 凯勒：我在特斯拉是最闲的员工，却要在英特尔管一万人](https://www.pingwest.com/a/244625)\n1. [不可一世的 Arm，要遭遇 20 年来的最大危机](https://36kr.com/p/2109040627812483)\n   - 吉姆·凯勒在离开英特尔不久之后，于 2021 年加入了一家加拿大 AI 芯片初创公司 Tenstorrent。随后，该公司就宣布将基于 RISC-V 开发自研架构，以此为基础开发高性能 AI 芯片，预计可用于各种应用，包括同时需要 AI 和 HPC 能力的下一代超级计算机。吉姆·凯勒曾经任职于英特尔、DEC、AMD、博通、苹果、特斯拉等公司，担任工程副总裁或首席架构师等工作。过去几十年，他是一手打造苹果 A 系列芯片的设计师，也是帮助 AMD 翻身的「Zen 之父」，还是特斯拉自动驾驶芯片的缔造者。此外，他还是 x86-64 指令集的作者之一。\n"},{"title":"benchmark","url":"/2023/05/10/benchmark/","content":"\n## basic\n\n## links\n\n1. [geekbench 芯片性能统计](https://browser.geekbench.com/v6/cpu)\n1. [抛弃 ARM，高通第五代汽车芯片](https://mp.weixin.qq.com/s/uTp9DXsG0pzTbyux1JgHMA)\n"},{"title":"hightway","url":"/2023/05/09/hightway/","content":"\n## links\n\n1. [highway](https://github.com/google/highway/tree/master)\n1. [getting-started](https://google.github.io/highway/en/master/faq.html#getting-started)\n1. [libjxl reference implementation of JPEG XL (encoder and decoder)](https://github.com/libjxl/libjxl)\n1. [hello_world](https://github.com/chromium/chromium/blob/22b51215052e84b7c4ee35ba2d4d21638b906b35/third_party/distributed_point_functions/code/dpf/internal/get_hwy_mode.cc)\n1. [adding-a-new-op](https://google.github.io/highway/en/master/impl_details.html#adding-a-new-op)\n1. [print simd](https://github.com/google/highway/blob/6c285d64ae50e0f48866072ed3a476fc12df5ab6/hwy/print-inl.h#L59-L59)\n\n## basic\n\n1. 可以打印 V.raw\n1. 源码编译 build 目录下工具`hwy_list_targets`可以显示 cpu 支持的加速硬件 [src](https://github.com/google/highway/blob/master/hwy/tests/list_targets.cc); HWY_STATIC_TARGET: SSE2 显示默认支持\n1. 具体运行程序见 cpp_sandbox/highway\n1. Advanced Encryption Standard (AES); NEON_WITHOUT_AES\n1. [获取支持的加速硬件](https://github.com/google/highway/blob/f86369577e9f884f9156dddbf03ee786493c67f9/hwy/examples/benchmark.cc#LL245C5-L245C31)\n   - `cat /proc/cpuinfo` 看 flags\n1. [获取函数运行 cycle](https://github.com/google/highway/blob/33d7d0a6651bd783f97534c936bc9733a3117478/hwy/nanobenchmark.cc#L736)\n\n## [simd library](https://www.reddit.com/r/cpp/comments/106ivke/simd_intrinsics_and_the_possibility_of_a_standard/)\n\n1. [highway cpu 向量加速库 SIMD](https://github.com/google/highway)\n1. [eve](https://github.com/jfalcou/eve)\n1. [xsimd](https://github.com/xtensor-stack/xsimd)\n1. [图像处理与机器学习 Simd](https://github.com/ermig1979/Simd)\n1. [parallelism TS v2](https://en.cppreference.com/w/cpp/experimental/simd)\n1. [simde](https://github.com/simd-everywhere/simde) 如果平台不存在硬件加速，使用模拟函数，如在 x86 上运行 neon\n"},{"title":"neon","url":"/2023/03/23/neon/","content":"\n## base\n\n1. 新的 Armv8a 架构有 32 个 128bit 向量寄存器，老的 ArmV7a 架构有 32 个 64bit（可当作 16 个 128bit）向量寄存器，编码时记得数一下占用多少个专用寄存器（例如 1 个 float32x4 就占用 1 个 128bit 寄存器），别用过量了，避免寄存器溢出 (Register Spilling）(https://blog.csdn.net/qq_41112170/article/details/90286091) 导致的负优化。\n1. armv8: 一条 Neon 指令最多可以计算 4 个 float32，或者 8 个 float16，或者 16 个 int8。\n1. `uint8x16_t` 表示 16 个 uint8\n1. `float32x4_t` 表示 4 个 float32\n\n## 要使用 NEON 加速步骤：\n\n1. `load` 将相关数组数据加载到 NEON 寄存器。\n1. `calculate` 使用 NEON 指令对多个数据元素进行并行操作。\n1. `store` 将结果从 NEON 寄存器存储回主存储器。\n\n## 编译选项\n\n1. j5 需要 `-ftree-vectorize -funroll-loops` 组合才能优化，单独不行\n1. `-mfpu=neon` 此选项告诉编译器要为 NEON 浮点单元生成代码。这适用于较老的 ARM 架构和编译器版本。\n1. `-march` 使用此选项指定目标架构，例如`-march=armv8-a`。这可以确保编译器针对特定的 ARM 版本生成优化代码。\n1. `-mfloat-abi` 该选项定义了浮点数应该如何在函数调用中传递。有三个选项可以选择：soft、softfp 和 hard。使用 NEON 时，通常建议使用-mfloat-abi=hard。\n1. `-ftree-vectorize` 这是一个优化选项，允许编译器自动将循环转换为使用向量指令。虽然这不是直接与 NEON 相关的，但它可以帮助自动利用 NEON 功能。\n1. `-funroll-loops`这也是一个优化选项，用于循环展开，可能有助于提高 NEON 代码的性能。\n\n## SVE(Scalable Vector Extension)\n\n1. 是 arm AArch64 架构下的下一代 SIMD 指令集，旨在加速高性能计算，SVE 引入了很多新的架构特点\n1. SVE（可扩展矢量指令 Scalable Vector Extension）是针对高性能计算（HPC）和机器学习等领域开发的一套全新的矢量指令集，它是下一代 SIMD 指令集实现，而不是 NEON 指令集的简单扩展。SVE 指令集中有很多概念与 NEON 指令集类似，例如矢量、通道、数据元素等。SVE 指令集也提出了一个全新的概念：可变矢量长度编程模型(VectorLength Agnostic，VLA)。\n1. SVE 指令集的矢量寄存器的长度最小支持 128 位，最大可以支持 2048 位，以 128 位为增量。\n1. SVE 指令集是在 A64 指令集的基础上新增的一组指令集，而 SVE2 是在 ARMv9 架构上发布的，它是 SVE 指令集的一个超集和扩充。\n1. [ARMv9 的 SVE/SVE2 入门教程](https://zhuanlan.zhihu.com/p/399686472)\n\n## links\n\n1. [hello world](http://www.armadeus.org/wiki/index.php?title=NEON_HelloWorld)\n1. [ARM_NEON_CNN 编程](https://github.com/Ewenwan/MVision/blob/master/CNN/HighPerformanceComputing/ARM_NEON_CNN%E7%BC%96%E7%A8%8B.md)\n1. [CPU 优化技术-NEON 指令介绍](https://zhuanlan.zhihu.com/p/441686632)\n"},{"title":"OpenXLA","url":"/2023/03/13/OpenXLA/","content":"\n## links\n\n1. [openxla/xla](https://github.com/openxla/xla)\n1. [tensorflow/xla](https://www.tensorflow.org/xla?hl=zh-cn)\n1. [iree](https://openxla.github.io/iree/#support-matrix)\n1. [简介](https://www.sohu.com/a/653633664_129720)\n1. [机器学习访存密集计算编译优化框架 AStitch，大幅提升任务执行效率](https://www.sohu.com/a/578161914_612370)\n1. [TVM 中文网站](https://tvm.hyper.ai/docs/tutorial/intro/)\n"},{"title":"cross-compile","url":"/2023/03/06/cross-compile/","content":"\n## 作用\n\n## [基本组成](https://blog.csdn.net/u012503639/article/details/104159375)\n\n### binutils\n\n### gcc\n\n### glibc\n"},{"title":"TVM","url":"/2023/02/17/TVM/","content":"\n## base\n\n1. Apache TVM 是一个用于 CPU、GPU 和机器学习加速器的开源机器学习编译器框架，旨在让机器学习工程师能够在任何硬件后端上高效地优化和运行计算。\n1. 可以搜索优化模型，提供了 runtime\n1. 模型相当于语言， TVM 相当于编译器，将模型编译到各种硬件上\n1. TVM: Tensor Virtual Machine\n1. 利用 TVM，机器学习算法可以被自动编译成可供下层硬件执行的机器语言，从而可以利用多种类型的算力。\n1. 我们希望创建一个简洁的抽象统一解决这些问题，希望用一个干净、统一的管理平台把所有的系统和硬件都清晰地抽象出来，以便能够部署模型，并最大限度地利用好目标硬件。\n1. 他们致力于打造一个可扩展、开放、中立的端到端栈，用于深度学习模型的`优化和部署`，目标是减少企业为特定硬件开发和深度学习软件部署所花费的成本和时间。\n1. 按照官方的定义，TVM 是一套完整的 stack，包括神经网络图优化（比如 op fusion）和单个 operation 优化等部分。我习惯于将图优化的部分归类做 Relay 项目，而仅仅把单个 operation 优化看做 TVM，因此文章之后提到的 TVM 基本是指单个算子优化这部分。\n1. 做自动代码优化的优秀项目除了 AutoTVM，还有 Halide(https://halide-lang.org/papers/autoscheduler2019.html)，个人认为目前Halide做代码自动优化做的更好。TVM的基本思路参考自Halide，\n1. TVM 中的调优是指，在给定 target 上优化模型，使其运行得更快。与训练或微调不同，它不会影响模型的准确性，而只会影响 runtime 性能。作为调优过程的一部分，TVM `实现并运行许多不同算子的变体，以查看哪个性能最佳`。这些运行的结果存储在调优记录文件（tune 命令的最终输出）中。\n\n1. [初识 TVM](https://zhuanlan.zhihu.com/p/88188955)\n\n## build\n\n1.  [docker](https://tvm.hyper.ai/docs/install/docker/)\n1.  使用自己 docker\n1.  [wadewuu/tvm-test/v2](https://hub.docker.com/layers/wadewuu/tvm-test/v2/images/sha256-58a2d0f3f9aefbf1c8d681a32f72ee3ffd2b05971461973ee632f03eaa1fd529?context=explore)\n1.  要先现在源码，编译出 docker，再编译 tvm\n1.  替换源\n1.  build 时 llvm 打开\n\n```\nRUN sed -i s@/archive.ubuntu.com/@/mirrors.tuna.tsinghua.edu.cn/@g /etc/apt/sources.list\nRUN apt-get clean\n```\n\n## python\n\n1.  `python3 -m tvm.driver.tvmc --help`\n1.  `alias tvmc='python3 -m tvm.driver.tvmc'`\n\n## [sample](https://tvm.hyper.ai/docs/tutorial/compile/)\n\n1. `wget https://github.com/onnx/models/raw/b9a54e89508f101a1611cd64f4ef56b9cb62c7cf/vision/classification/resnet/model/resnet50-v2-7.onnx`\n1. [Error when trying to tune the ResNet Model](https://discuss.tvm.apache.org/t/error-when-trying-to-tune-the-resnet-model/13431) model input should frozen\n\n## links\n\n1. [TVM](https://tvm.apache.org/#about)\n1. [TVM 中文网站](https://tvm.hyper.ai/docs/tutorial/intro/)\n1. [sample](https://tvm.hyper.ai/docs/tutorial/compile/)\n1. [Vitis AI 集成](https://tvm.hyper.ai/docs/how_to/deploy/vitis_ai)\n1. [TI TVM](https://software-dl.ti.com/codegen/docs/tvm/tvm_tidl_users_guide/index.html)\n1. [机器学习编译器的前世今生](https://www.zhihu.com/question/401766029/answer/2733700454)\n1. [TVM：成为深度学习领域的“Linux”](https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247487015&idx=1&sn=04282e2d15eca05eb56062062b46e781&chksm=fe418011c9360907048966af43299fa55b570c9d634c4bcdb3702c6e4d8101a72ef07d5ec77f&scene=21#wechat_redirect)\n1. [LLVM 之父 Chris Lattner：我的 AI 基础设施软件构建理念](https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247492618&idx=1&sn=a20f4828b9ab3e3cee3fedfd906e0eb2&chksm=fe426a3cc935e32a8312ce9efbb4f2640787508d3e811579bbffe918685cdb07a8bd8e3ffc4b&scene=132&exptype=timeline_recommend_article_extendread_samebiz#wechat_redirect)\n"},{"title":"JFrog","url":"/2023/01/16/JFrog/","content":"\n## [Artifactory](https://zhuanlan.zhihu.com/p/274996585)\n\n1. 上传最好不要用 sudo 用户，否则容易覆盖之前文件，不好管理\n1. guest 用户可以禁止 ui 登录，防止用户被锁\n1. 可以通过界面上传文件\n1. 作为一个二进制包管理工具，可以用于管理构建产物：即把生成的 jar 包存放到 JFrog，当在生产环境进行部署时，Jenkins 直接从 JFrog 中拉取对应的 jar 包即可。\n1. 官方的介绍：JFrog Artifactory 是一个可扩展的通用二进制存储库管理器，可在整个应用程序开发和交付过程中自动管理你的工件和依赖项。一句话概括：Artifactory 是一个存放制品（Artifacts）的工具。\n1. 左下角 getting started\n1. 允许匿名用户，否则 wget curl 下载不下来， [link](https://juejin.cn/post/7080707817778184205)\n1. 先创建 repo，再上传\n1. repo 分为：local, remote 和 virtual\n1. monitoring -> storage 可以看各 repo 存储大小\n1. Application -> Artifactory -> artifacts 右上角 Set me up 可以查看 deploy 和 resolve 命令\n1. set me up 中可以设置 configue 来隐藏密码\n1. artifacts 中的文件可以单独下载，右上角下载符号\n1. 有些文件可以预览，右上角...展开, 或者选中文件，右击\n1. 可以查看下载次数和被谁下载\n1. [artifacts 布局 layouts](https://www.jfrog.com/confluence/display/JFROG/Repository+Layouts) 可以查看版本, 可以生成各种工具依赖的版本信息\n1. MD5 check：`echo 99 > test.txt && MD5=$(md5sum test.txt | awk '{print $1}') && curl -uxiyang.jia:APAQR97hg1swsSNZ -T test.txt -H \"X-Checksum-MD5:${MD5}\" -L \"http://artifacts.phigent.io/artifactory/xiyang-test/test/test/test-1.0.3.txt\" -v`\n1. 可以通过 name, checksum, property 搜索 artifacts\n1. `wget -O test.tar.gz --no-check-certificate  https://guest:Guest.123@xxx/artifactory/test.tar.gz` 下载, 覆盖原来文件\n1. `curl -sSfLO https://guest:Guest.123@xxx/artifactory/test.tar.gz` 下载\n\n## [with gilab](https://jfrog.com/blog/gitlab-and-artifactory-on-your-mark-get-set-build/)\n\n### NOTE\n\n1. curl -L http:xxx 不加 -L 会自动转换为 https\n1. curl -v 查看中间过程\n1. shell\n\n```sh\n#!/bin/bash\n\nJFROG_USER=xiyang.jia\nJFROG_PASSWD=APAQR97hg1swsSNZ\n\npush_to_jfrog() {\n        FILE=$1\n        JFROG_PATH=http://artifacts.phigent.io/artifactory/$2\n        MD5=$(md5sum $FILE | awk '{print $1}')\n        curl -u\"${JFROG_USER}:${JFROG_PASSWD}\" -T $FILE -H \"X-Checksum-MD5:${MD5}\" -L \"${JFROG_PATH}\"\n}\n\npush_dir_to_jfrog(){\n        for file in $(find $1 -type f); do\n                push_to_jfrog ${file} $2/${file}\n        done\n}\n\nif [ -d $1 ]; then\n        push_dir_to_jfrog $1 $2\nelse\n        push_to_jfrog $1 $2\nfi\n```\n"},{"title":"Cpp20","url":"/2023/01/13/Cpp20/","content":"\n## module\n\n## [coroutine](https://zhuanlan.zhihu.com/p/172471249)\n\n1. 协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。\n1. 协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。\n1. 因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步 IO 结合起来，才能发挥最大的威力。\n1. 协程只有和异步 IO 结合起来才能发挥出最大的威力。\n1. 协程可以通过 yield（取其“让步”之义而非“出产”）来调用其它协程，接下来的每次协程被调用时，从协程上次 yield，返回的位置接着执行，通过 yield 方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。\n1. 协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益（特别是对硬性实时操作的适合性和相对廉价的相互之间切换）。\n1. 协程的核心竞争力在于：它能简化异步并发任务，以同步方式写异步代码, 这也是为什么要引入协程的原因了：简化异步并发任务\n1. 线程是操作系统层面的概念，协程是语言层面的概念, 线程与协程最大的区别在于：线程是被动挂起恢复，协程是主动挂起恢复\n\n### link\n\n1. [wikipedia](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)\n1. [进程、线程和协程的区别](https://juejin.cn/post/6973650934664527885)\n"},{"title":"BPF","url":"/2022/12/26/BPF/","content":"\n## tools\n\n1. [各种 tools](https://blog.csdn.net/qq_23662505/article/details/125427689?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-125427689-blog-119563743.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-125427689-blog-119563743.pc_relevant_aa2&utm_relevant_index=8)\n\n## BCC\n\n1. 需要 sudo 来执行命令\n1. 各命令有 man 手册\n1. `sudo apt-get install bpfcc-tools`\n1. ` './include/linux/kconfig.h' file not found` => `cd /lib/modules/5.10.104-tegra/build/ && ln -s /lib/modules/5.10.104-tegra/build/kernel-5.10/include .`\n1.\n\n### install\n\n1. [docker](https://github.com/iovisor/bcc/blob/master/QUICKSTART.md) 需要用宿主机上的内核源码\n\n## bpftrace\n\n1. `mount -t debugfs none /sys/kernel/debug/`\n\n### install\n\n1. `sudo apt-get install -y bpftrace`\n1. 需要内核开启一些选项\n1. [ubuntu](https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#ubuntu-packages)\n"},{"title":"unix","url":"/2022/12/02/unix/","content":"\n## [UNIX 环境高级编程](http://www.apuebook.com/apue3e.html)\n\n1. ID\n\n   - 文件(文件描述符)\n   - 进程\n   - 错误处理(errno)\n   - 用户标识(用户 ID, 组 ID)\n   - 信号(SIG)\n\n1. `stat`: 获取文件各种信息\n   - `stat -c %s file` 查看文件长度\n1. `strace - trace system calls and signals`\n\n## 文件\n\n## IO\n\n## 信号\n\n1. 信号是软件中断。\n1. 终端键盘上有两种信号方法：\n   - SIGINT 中断键：C-c\n   - SIGQUIT 退出键：C-\\\n1. 使用 system 而不是直接用 fork 和 exec 的优点是： system 有各种错误处理和各种信号处理\n\n### 进程\n\n1. 进程 ID 用 pid_t 数据类型来表示，是一个非负整数。 线程 ID 是用 pthread_t 数据类型来表示， 是一个结构体， 不同系统类型不同。\n1. 如果进程中的任意线程调用了 exit, \\_Exit 或者\\_exit, 那么整个进程就会终止。\n1. `nm -C test | grep GLIBC_`可以看出 c++程序用 thread 和 mutex 最终调用了 pthread_create 和 pthread_mutex\\*\n1. 守护进程出错记录使用 syslog，log 位置 /var/log/syslog\n\n#### 进程间通信 InterProcess Communication IPC\n\n1. 同一机器：管道，FIFO, 消息队列，信号量，共享内存。\n2. 不同机器：socket\n\n#### 线程间通信\n\n1. mutex, 读写锁，自旋锁， 条件变量\n1. mutex 保护的是 lock 和 unlock 之间的代码\n1. 如果线程对一个互斥量加锁两次，那么它自身就会陷入死锁。\n1. 线程间循环依赖锁也会死锁，解决办法：1. 控制互斥量加锁的顺序避免死锁。2. try_lock 如果获得不了想要的锁， 先释放已占有的锁，过一段时间再试试。\n1. 自旋锁与互斥量类似， 但自旋锁获取锁之前线程是非阻塞状态。适用于锁持有时间段，线程不希望在重新调度上花费太多成本。自旋锁在非抢占式内核中非常有用，在用户层，自旋锁并不是很有用。\n1. 很多互斥量实现非常高效，有些互斥量的实现在试图获取互斥量的时候会自选一小段时间，只有自旋计数达到某一阈值的时候才会休眠。\n\n### [linux 下源码编译问题](https://blog.csdn.net/qq_29116917/article/details/103786194)\n\n1. minor 找不到： filedir/devrdev.c `#include <sys/sysmacros.h>`\n1. `sudo apt install libbsd-dev`\n1. err_sys 找不到问题， error.c 源码复制到 apue.h 中\n"},{"title":"version","url":"/2022/11/15/version/","content":"\n## Linux 动态库版本管理\n\n1. Linux 通过版本号来管理动态库的版本，版本号最多有 3 级，其格式为 libname.so.x.y.z\n   - x: major release，非兼容修改，可能对接口做了大改动，比如重命名、增加或减少参数等。\n   - y: minor release，不改变兼容性，但是增加了新接口\n   - z: patch release，不改变兼容性，仅仅是修复 bug、或者优化代码实现、优化性能等。\n"},{"title":"github-ci","url":"/2022/10/30/github-ci/","content":"\n## actions\n\n1. fork 的 repo 需要手动在 actions 里 enable\n1. [disabling-and-enabling-a-workflow](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow)\n1. [actions doc](https://docs.github.com/cn/actions)\n\n## sample\n\n1. use 可以连续用\n\n```yaml\nname: Ubuntu\non: push\njobs:\n  release-test:\n    name: dataflow build on ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4 ## checkout到分支\n      - uses: prefix-dev/setup-pixi@v0.3.0 ## 安装pixi\n      - name: run all test\n        run: pixi run all\n      - name: \"Upload Artifact\"\n        uses: actions/upload-artifact@v3\n        with:\n          name: my-artifact\n          path: .gitignore\n```\n\n## [upload-artifact](https://github.com/actions/upload-artifact#zipped-artifact-downloads)\n\n1. config\n\n```yaml\n- name: \"Upload Artifact\"\n  uses: actions/upload-artifact@v3\n  with:\n    name: my-artifact\n    path: .gitignore\n```\n\n1. ci job 左侧 summary 可以下载 artifacts\n\n## [upload-release-asset](https://github.com/actions/upload-release-asset)\n\n1. [push 失败问题： 需要设置 repo read_and_write 权限](https://stackoverflow.com/questions/75995802/resource-not-accessible-by-integration-github-action-fails-for-pushed-commit)\n1. 参考 cpp_sandbox 和 python_sandbox\n\n## links\n\n1. [官方文档](https://docs.github.com/zh/actions/quickstart)\n1. [action samples](https://github.com/marketplace?type=actions)\n1. [readme show build status](https://github.com/microsoft/onnxruntime/blob/main/README.md)\n1. [taskflow samples](https://github.com/taskflow/taskflow/tree/master/.github/workflows)\n1. [基于 Github Action 的 CI/CD 流程](https://zhuanlan.zhihu.com/p/250534172)\n"},{"title":"Coroutine","url":"/2022/10/25/Coroutine/","content":"\n## base\n\n1. 协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。\n1. 协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。\n1. 因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步 IO 结合起来，才能发挥最大的威力。\n1. 协程只有和异步 IO 结合起来才能发挥出最大的威力。\n\n## links\n\n1. [什么是协程？](https://zhuanlan.zhihu.com/p/172471249)\n"},{"title":"开发方法","url":"/2022/10/21/开发方法/","content":"\n## base\n\n1. 瀑布流方法（Waterfall）\n1. V 型方法（V-model）\n1. 迭代式开发（Iterative and incremental development, IID）\n1. 螺旋开发（Spiral）\n1. 敏捷开发（Scrum）\n1. 极限编程（Extreme programming, XP）\n"},{"title":"Compiler","url":"/2022/10/21/Compiler/","content":"\n## base\n\n1. LLVM（Low-Level Virtual Machine)\n1. [llvm VS gcc](https://mp.weixin.qq.com/s/OB7JJHgknJgDFjXKI3jOcA)\n1. [解释， 编译， 字节码(JIT)](https://mp.weixin.qq.com/s/AH7tdFR_QGTMg2wxaj0sog)\n1. 传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码\n1. llvm 和 clang 关系\n   ![llvm和clang关系](https://img-blog.csdn.net/20160718211639694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n1. IR(intermediate representation): 中间语言，最常见的中间语言表述形式，是三位址码（Three address code）\n1. LLVM 是一种基础设施，是有用的编译器技术的集合，可以用于解决特定问题（例如构建 C 编译器或特效管道中的优化器）\n1. [bitcode 和 bytecode 的区别是什么](https://worktile.com/kb/p/37934)\n1. 注意`import` and `export` symbols\n1. `echo | xt-clang -E -Wp,-v -` -E 选项告诉编译器只进行预处理，-Wp,-v 选项告诉编译器打印出它在预处理阶段使用的头文件路径。\n1. [动态库全局符号覆盖的大坑 double free](https://gaomf.cn/2020/06/03/shared_library_global_symbol_override/)\n   - `nm libmylib1.so libmylib2.so | grep -P \"^[^\\\\s]+ T \" | cut -d' ' -f3 | sort | uniq -d | grep -v '_fini' | grep -v '_init' | c++filt` 查看是否有相同全局符号\n1. [Symbols 与 gcc -g 产生的 debug info 并不是一个东西](http://arthurchiao.art/blog/linux-tracing-basis-zh/)\n1. function tracing 只需要 symbols，不需要 debug symbols（gcc -g）。strip 之后不能跟踪\n1. 动态符号（.dynsym）vs. 局部符号（.symtab）， 可以用命令 strip 来手动去掉局部符号表， strip 前后用`readelf -s ./test`看, strip 只去除了.symtab\n1. [查看依赖动态库的一些方法](https://unix.stackexchange.com/questions/120015/how-to-find-out-the-dynamic-libraries-executables-loads-when-run)\n   - `sudo awk '/\\.so/{print $6}' /proc/1/maps | sort -u` 查看进行 1 链接的动态库\n   - `LD_DEBUG=files ./xx` 查看运行时加载的库\n   - `readelf -d build/dog/dog_test1 | grep 'NEEDED'` 查看加载用到的库\n   - `sudo lsof -p 1| grep mem | grep so` 查看进程用到的库\n\n<!-- more -->\n\n1. 解释型语言解释器是一个运行的交互程序，接收输入命令，执行对应操作并将结果输出\n1. ld 编译选项`--whole-archive`, 告诉链接器，将后面库中所有符号都链接进来，参数`-no-whole-archive`则是重置，以避免后面库的所有符号被链接进来。要通 gcc 传递到 ld，需要在他们前面加 -Wl\n1. `set(CMAKE_SHARED_LINKER_FLAGS \"-s -Wl,--version-script=${PROJECT_SOURCE_DIR}/symbol.lst\")` 跟据 symbol.lit 来 strip， 可以只暴露需要的 symbol, `nm -C`看不到符号， `readelf -s`可以\n   `target_link_options(tensorflowlite_c PRIVATE \"-Wl,--version-script,${TENSORFLOW_SOURCE_DIR}/tensorflow/lite/c/version_script.lds\")`\n1. [c++ 全局变量初始化](https://www.cnblogs.com/catch/p/4314256.html)\n   根据 C++ 标准，全局变量的初始化要在 main 函数执行前完成，常识无疑，但是这个说法有点含糊，main 函数执行前到底具体是什么时候呢？是编译时还是运行时？答案是既有编译时，也可能会有运行时(seriously), 从语言的层面来说，全局变量的初始化可以划分为以下两个阶段（c++11 N3690 3.6.2)：\n   - static initialization: 静态初始化指的是用常量来对变量进行初始化,主要包括 zero initialization 和 const initialization，静态初始化在程序加载的过程中完成，对简单类型(内建类型，POD 等)来说，从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量初始化基本是一致的。\n   - dynamic initialization：动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a = foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。\n     需要明确的是：静态初始化执行先于动态初始化！ 只有当所有静态初始化执行完毕，动态初始化才会执行。显然，这样的设计是很直观的，能静态初始化的变量，它的初始值都是在编译时就能确定，因此可以直接 hard code 到生成的代码里，而动态初始化需要在运行时执行相应的动作才能进行，因此，静态初始化先于动态初始化是必然的。\n1. 注册：(`库中符号没有被使用，库不会被初始化(具有全局声明周期的变量和所有函数)` `具有side-effect的变量会被初始化，肯定用到了所在库`)\n\n   - 全局不初始化是没链接接上，没链接是因为没加载， 不是 NEEDED lib\n   - `readelf -d build/dog/dog_test1 | grep 'NEEDED'` 查看加载用到的库\n   - [注册全局变量未初始化初始化](http://www.cppblog.com/kevinlynx/archive/2010/01/17/105885.aspx)\n   - [Static variable initialization over a library](https://stackoverflow.com/questions/5202142/static-variable-initialization-over-a-library)\n   - 未依赖的全局变量可能并不初始化。main 之前也可以打印。\n   - dlopen 打开 lib，运行时注册(需要知道库名字)。\n   - My guess - when linking against a library, the linker only brings over symbols that are actually used by the executable. Object files whose exported symbols are not referenced from anywhere are simply ignored; so registered variable is dropped and its initializer doesn't run. Normally, that's a good thing - you wouldn't usually want unused parts of a large library to nevertheless wind up in your binary.\n   - [TensorFlow c++ SessionFactory 注册与 No session factory registered 错误](https://blog.csdn.net/gaussrieman123/article/details/106384853)\n     在上面我们已经分析清楚，这个报错的根本原因是 TensorFlow 动态库中的这两个源文件中的全局静态变量 registrar 没有初始化，导致后面在创建 Session 的时候 GetFactory 失败。\n     有一篇文章\"Integrating TensorFlow libraries\"也分析是这个原因。因为 TF 组件化的设计思路，一个很小的 core+注册的方式来完成包括 SessionFactory、Op_Kernel、Op 等的加载，在编译的时候，如果这部分代码被编译器忽略了，就会导致部分代码注册失败，进而导致报错。\n     为什么不初始化呢？\n     动态库的加载分为`显示加载和隐式加载`，我们后面验证了显示加载，即显示通过 dlopen 来调用这些动态库，是可以正常运行的，说明这种情况下，所有的注册都完成了。问题出在隐式加载上。\n   - `A non-local variable with static storage duration having initialization with side-effects must be initialized even if it is not odr-used ` side-effects 引起其他地方改变，被其他地方使用就算引起改变\n   - [One_Definition_Rule(ODR)](https://en.wikipedia.org/wiki/One_Definition_Rule) 在整个程序中，对象或非内联函数不能有多个定义；如果使用一个对象或函数，它必须有一个定义。您可以声明一个从未使用过的对象或函数，在这种情况下，您不必提供定义。在任何情况下都不可能有多个定义\n   - [Is static object guaranteed to be initialized](https://stackoverflow.com/questions/18600034/is-static-object-guaranteed-to-be-initialized)\n   - [与 flow 加载问题相似例子](https://stackoverflow.com/a/18601535)\n   - `the first odr-use of any function or variable deﬁned in the same translation unit as the variable to be initialized` 同一个编译单元不管是否用到都会初始化\n   - ` If the initialization is deferred to some point in time after the ﬁrst statement of main, it shall occur before the ﬁrst odr-use (3.2) of any function or variable deﬁned in the same translation unit as the variable to be initialized.` 如果某全局变量初始化推迟到 main 之后，那么使用该全局变量所在 TU 内的任何变量和函数之前需要初始化该全局变量，如果该全局变量与 main 在同一 TU 内，那么使用 main 中任何变量前，都要初始化改全局变量，等效 main 之前初始化, 因为用到了当前库中的符号。(做实验，同一 UT 内(没使用也会被初始化，注册成功)，随便使用另一个 so 中的函数(随便引用了一个毫无相关的内容，注册进工厂))\n   - `The compiler is not allowed to optimiza away global objects. Even if they are never used.` 全局变量不会被优化掉，静态库可能不链接；动态库整个 TU 可能不被加载, 动态库在磁盘上，如果没有用到，不会被加载?。 [link](https://stackoverflow.com/a/1229542) `\"It seems that having a file purely consisting of these global objects is what's causing the problem. It's as if that translation unit was entirely ignored\". The translation unit is being ignored in the sense that it is being omitted by the linker because it's in a library. If an object is in a library and isn't called by anything in the app, it's omitted, that's the whole idea of libaries! `\n   - `they were not setup at startup if no symbol of the DLL were used in the main.` 库中符号没有被使用，库不会被初始化。\n   - [SELF REGISTERING CLASSES](https://accu.org/journals/overload/6/27/bellingham_597/) (多研究下怎们用 extern)\n   - 解决方法 1： 运行时加载 dlopen 打开 so 时， 会初始化全局变量\n   - 解决方法 2： 显示使用符号，测试程序中使用库中的任意符号`extern int xxx; int test(){return xxx;}` 为什么能工作？`当前TU中的函数会被初始化， 函数里使用到了xxx， xxx所在库全局声明周期变量会被初始化`\n   - 库和测试程序都定义同一个内联函数不解决问题。\n   - 由于内存太小，所以真的动态执行，只有用到了才加载到内存，执行完就释放掉了，\n\n1. 动态链接库的加载方式有两种：隐式加载(静态链接或动态加载时链接)和显示加载(动态运行时链接)。 显示加载会加载所有符号，初始化所有变量, 可能是因为不确定要调用哪些符号，所以都初始化了。\n\n1. `flow单例注册问题`: 单例不只一份 static\n   - 隐藏单例的 Instance 函数 symbol 会出问题, 会有多个 static 变量\n   - `链接静态库要用PRIVATE保护`： 可能被链接两次，如单例模式注册问题， 链接了两份静态， 导致注册到不同地方。\n   - [C++单例模式跨 DLL 是不是就是会出问题?](https://www.zhihu.com/question/425920019/answer/2254967131)\n   - linux 上的 GNU GCC 编译器默认给函数的属性是`attribute`((visibility(\"default\")))，如果没有指定编译选项 visilibility 的话默认会导出所有的符号 `-fvisibility=hidden`\n   - [控制库符号导出](https://www.cnblogs.com/lsgxeva/p/12510201.html)\n   - 加了-fvisibility=hidden 后 static 符号(Instance 函数)被隐藏，有多份 static 局部变量，会有多个实例\n   - [自测 sample](https://github.com/jiaxiyang/cpp_sandbox/tree/master/design_pattern/singleton)\n   - 还有可能测试程序链接的静态库，只链接了用到的静态变量，导致未用到的没注册；链接整个静态库`-Wl,--whole-archive dcv_predict -Wl,-no-whole-archive`\n\n## LLVM\n\n1. `.c --frontend--> AST --frontend--> LLVM IR --LLVM opt--> LLVM IR --LLVM llc--> .s Assembly --OS Assembler--> .o --OS Linker--> executable`\n\n### MLIR（Multi-Level Intermediate Representation）和 LLVM IR（LLVM Intermediate Representation）区别：\n\n1. `多层次表示 vs 单层次表示`:\n   - `MLIR` 是多层次的中间表示，它允许表示不同层次的抽象，从高级语言特定领域语言（DSL）到底层硬件描述。这使得 MLIR 在各种领域和应用中非常灵活。\n   - `LLVM IR` 是单层次的中间表示，更专注于从高级源代码到目标机器代码的转换。它不支持多层次抽象或领域特定语言的内置支持。\n2. `领域特定语言支持`:\n   - `MLIR` 提供了内置支持领域特定语言（DSLs）的机制，这使得开发者可以更容易地在 MLIR 中定义和优化特定领域的代码。\n   - `LLVM IR` 不提供直接的 DSL 支持，尽管可以通过 LLVM 的扩展来实现某些领域特定的优化。\n3. `生态系统和用途`:\n   - `MLIR` 被设计为通用的多领域中间表示，适用于编译器、机器学习、图形处理器编程等多个领域。\n   - `LLVM IR` 在开始时更专注于编译器优化和代码生成，但它的生态系统也在不断扩展，包括用于 WebAssembly、GPU 等不同领域的扩展。\n4. `设计目标`:\n   - `MLIR` 的设计目标之一是提供灵活性和可扩展性，以适应不同领域的编译和代码生成需求，包括优化和分析。\n   - `LLVM IR` 更侧重于提供优化编译器的中间表示，以便在各种目标平台上生成高性能代码。\n5. `历史和成熟度`:\n   - `LLVM IR` 已经存在更长时间，拥有更成熟的生态系统和广泛的应用。它是众多编程语言的编译器后端的首选中间表示。\n   - `MLIR` 是相对较新的项目，尚未在广泛的生产环境中获得与 LLVM IR 相似的广泛应用。\n     总之，MLIR 和 LLVM IR 都是强大的中间表示语言，用于编译器和代码生成领域，但它们的设计和用途有所不同。MLIR 更注重灵活性和多领域支持，而 LLVM IR 则更注重编译器优化和生成高性能代码。选择使用哪个中间表示取决于项目的需求和目标。有些项目甚至可以同时使用两者，以充分利用它们的不同特性。\n\n## Just-in-Time (JiT) 和 Ahead-of-Time (AoT)\n\n### Just-in-Time (JiT) 编译：\n\n1. `定义`: JiT 编译是在运行时，即代码执行时进行的编译。一个常见的例子是 Java 虚拟机(JVM)，它将字节码在运行时转换为机器代码。\n1. `优点`:\n   - `跨平台`: 代码可以为不同的硬件/操作系统平台提供同一种中间表示形式，然后在每个目标平台上进行 JiT 编译。\n   - `优化`: 由于编译发生在运行时，JiT 编译器可以利用特定于当前机器的优化，例如考虑当前的 CPU 和内存状况。\n   - `适应性`: 可以针对正在执行的代码的实际使用模式进行优化。\n1. `缺点`:\n   - `启动延迟`: 在应用程序开始执行时可能需要额外的时间进行编译，从而导致启动延迟。\n   - `内存使用`: JiT 编译需要额外的内存来存储中间表示形式和机器代码。\n\n### Ahead-of-Time (AoT) 编译：\n\n1. `定义`: AoT 编译是在代码执行之前进行的编译。传统的 C/C++编译器（例如 gcc、clang）就使用了这种方法，它们将源代码直接编译为机器代码。\n1. `优点`:\n   - `快速启动`: 由于代码已经被编译，应用程序通常可以更快地启动。\n   - `确定性`: 编译的输出是静态的，它不会因为运行时的条件或环境而改变。\n   - `资源`: 通常使用较少的内存，因为不需要存储中间表示形式或进行运行时编译。\n1. `缺点`:\n   - `跨平台问题`: 每个目标平台都需要一个特定的编译版本。\n   - `失去运行时优化`: 由于编译是在运行时之前完成的，AoT 编译器不能基于实际的运行时数据或环境进行优化。\n\n### 总结：\n\n1.  `JiT` 更适合需要跨平台支持和能够利用运行时数据进行优化的场景。\n1.  `AoT` 更适合对启动时间有严格要求、需要确定的性能或在资源受限的环境中运行的应用。\n\n## [FFI](https://cloud.tencent.com/developer/news/607788)\n\n1. FFI（Foreign Function Interface）是这样一种机制：用一种编程语言写的程序能调用另一种编程语言写的函数（routines）。\n\n## ABI 和指令集\n\n1. CPU--vendor--OS 这三者决定了一个平台，只要这三者一致，我们生成的二进制程序往往就可以确定了。这三者就被称为一个「目标三元组」（Target Triple）。x86_64-unknown-linux-gnu，这里 x86_64 指的是 CPU 架构，unknown 是 vendor，对于 Linux 环境，往往不太重要\n1. ABI (Application Binary Interface) 和指令集是两个在计算领域中经常被提及的概念，它们是相关的，但各自有其定义和用途。下面是对两者的简要描述和区别：\n\n### ABI (Application Binary Interface)\n\n1. 为什么 ABI 很重要？\n   - 如果你有一个预编译的库，并想在不同的环境中使用它，那么 ABI 的兼容性就非常重要。如果编译应用程序的编译器产生与库不兼容的 ABI，那么该应用程序可能无法正确地链接或运行。\n   - 当更新系统的库或操作系统时，保持 ABI 的稳定性是很重要的，否则之前编译的应用程序可能会因为新的库或操作系统的 ABI 改变而崩溃。\n1. `定义`：ABI 是程序模块（通常是一个可执行文件和一个共享库）之间在二进制级别进行交互所需要遵循的协议。换句话说，ABI 是软件之间的\"约定\"，这些软件在二进制层面上交互。\n1. `内容`：ABI 通常涉及到以下方面：\n   - `函数调用约定`：如何传递参数，如何返回结果，以及在调用中如何使用堆栈。\n   - `数据类型的大小和对齐`：例如，一个 `int` 类型在某个平台上可能是 4 字节，而在另一个平台上可能是 8 字节。\n   - `系统调用的约定`：这决定了应用程序如何进行系统调用。\n   - `目标文件格式`：例如 ELF (Executable and Linkable Format)。\n   - `其他方面`：如名称修饰和 C++的函数重载。\n1. `重要性`：不同的编译器，或同一编译器的不同版本，可能会有不同的 ABI。如果两个模块有不同的 ABI 并且它们尝试相互交互，那么可能会出现不可预知的行为。\n\n#### ABI 例子\n\nABI（应用程序二进制接口）是特定于架构和操作系统的，用于确保在二进制层面上的软件组件可以正确地相互交互。以下是一些常见的 ABI 的例子：\n\n1. `System V ABI`：这是 Unix 系统上最常见的 ABI，被多个 Unix-like 操作系统所采用，包括 Solaris、HP-UX、AIX 以及其他的系统。\n2. `Microsoft x64 calling convention`：这是 Windows 在 x64 架构上使用的 ABI。\n3. `PowerOpen ABI (PABI)`：这是 PowerPC 上的 ABI。\n4. `ARM ABI (AAPCS, ARM Architecture Procedure Call Standard)`：这是 ARM 架构上的 ABI。它也有多个变种，例如 AAPCS-VFP 用于硬浮点单元。\n5. `MIPS O32 ABI`：MIPS 架构上的一种常见 ABI。\n6. `Itanium C++ ABI`：这是为 Itanium 架构 (IA-64) 设计的，但其他架构上的 C++ 实现也采用了这个 ABI，如 x86 和 x86-64 的 GCC。\n7. `x86_64 psABI`：为 x86_64 架构设计的 ABI。\n8. `AArch64 ABI`：为 ARM 的 64 位版本设计的 ABI。 [arm abi github](https://github.com/ARM-software/abi-aa/)\n9. `EABI (Embedded ABI)`：适用于嵌入式处理器，特别是 ARM 和 MIPS。\n10. `Wasm ABI`：针对 WebAssembly 设计的 ABI。\n\n#### linux ABI 和 ARM ABI 关系\n\nLinux ABI (Application Binary Interface) 和 ARM ABI 都是关于应用程序二进制接口的规范，但它们的关注点和应用场景有所不同。\nLinux ABI 和 ARM ABI 是为不同的目的和在不同的层次上定义的规范，但在一个 ARM Linux 系统中，它们共同确保了软件组件的二进制兼容性和互操作性。\n\n1. `readelf -a test1 |grep ABI` 查看 elf ABI\n1. `.note.ABI-tag` section 中有信息\n1. `file ./test`也有 ABI 信息\n1. `Linux ABI`:\n   - Linux ABI 特指 Linux 操作系统内核与用户空间应用程序之间的接口。更具体地说，它描述了应用程序如何发起系统调用，以及这些调用如何传递参数、返回值等。\n   - 它定义了系统调用的接口，即应用程序如何与 Linux 内核交互。\n   - 它涉及到数据类型、系统调用编号以及如何将参数传递给这些系统调用等。\n   - Linux ABI 是跨平台的，意味着它旨在为多种体系结构（如 x86、ARM、MIPS 等）提供一致的接口。\n   - Linux ABI 可以确保，`只要应用和内核之间的 ABI 保持一致，就可以在不重新编译应用程序的情况下升级或更换 Linux 内核`。\n1. `ARM ABI`: - 这是特定于 ARM 架构的规范。\n   - ARM ABI 定义了在 ARM 架构上的软件如何布局数据和如何进行函数调用。这包括调用约定、数据类型的大小和对齐、处理器寄存器的使用，以及异常处理等。\n   - ARM 公司定义了多个 ABI。例如，有针对 ARM 架构的基础 ABI，也有针对特定指令集如 AArch64 的 ABI。\n   - 当我们谈论 ARM ABI 时，常见的是\"EABI\" (Embedded ABI)，它是为嵌入式系统设计的。\n1. `关系`:\n   - ARM ABI 确保应用程序的正确执行，而 Linux ABI 则确保应用程序与内核的正确交互。\n   - `Linux 在 ARM 平台上运行时，用户空间的应用程序和库会遵循 ARM ABI 的规范。这确保了应用程序和库在 ARM 硬件上的正确执行。同时，这些应用程序和库与 Linux 内核交互时会使用 Linux ABI 定义的系统调用`。\n   - 当一个应用程序运行在这样的系统上时，它与操作系统内核通信时使用 Linux ABI。而应用程序内部，或者它与其他库和组件通信时，可能遵循 ARM ABI。\n   - 实际上，应用程序或库在被编译和链接为 ARM Linux 系统上的二进制时，编译器和链接器会确保它们遵循这两种 ABI。\n\n### 指令集 (Instruction Set Architecture, ISA)\n\n1. `定义`：指令集是计算机架构的一部分，描述了 CPU 可以执行的低级操作和它们在机器代码级别的表示。\n2. `内容`：指令集定义了如下方面：\n   - `指令`：如加法、乘法、跳转等。\n   - `寄存器集`：描述 CPU 中可用的寄存器。\n   - `寻址模式`：决定如何访问数据和指令。\n   - `数据类型`：例如整数、浮点数等。\n3. `示例`：常见的指令集包括 x86, x86_64, ARM, MIPS 等。\n\n### 区别\n\n- `级别`：ABI 在更高的层次上定义了如何在二进制级别进行交互，而指令集是关于 CPU 可以执行哪些基本操作的描述。\n- `目标`：`ABI 主要关注软件之间的互操作性，而指令集关注硬件（CPU）如何执行特定的操作`\n- `应用场景`：`开发者在为特定平台编写程序或编译代码时需要关心 ABI。而在设计或实现 CPU 时，会关心指令集`\n\n## link\n\n1. 链接就像拼积木，有凹槽，也有凸槽，有一定的规则，满足规则凹凸部分才能拼合。\n1. 数据段段和代码段为什么分开？\n   - 程序运行多次可以共享只读内容， 包括代码段，只读数据段等，可以节省大量内存。\n   - 权限可以不同：代码自读， 数据可以读写\n   - 提高 cache 命中率\n1. `/usr/include/elf.h`看 elf 文件结构体\n\n### 环境变量\n\n1. `man ld.so` 查看各种 linker/loader 环境变量\n1. [Linux 环境变量之 LD_PRELOAD & LD_LIBRARY_PATH & LD_DEBUG](https://blog.csdn.net/llm_hao/article/details/115493516)\n\n#### LD_PRELOAD\n\n1. `LD_PRELOAD=\"/path/to/library.so\" valgrind my-executable` valgrind 定位动态库内存泄漏可以用到 [link](https://stackoverflow.com/a/13136609)\n1. gdb 调试时打不上断点，要使用 LD_PRELOAD 先加载动态库，找不到文件所在动态库，使用 speedscope\n\n#### LD_LIBRARY_PATH\n\n#### LD_DEBUG\n\n1. `LD_DEBUG=help ls` 查看帮助\n1. `LD_DEBUG=libs ./xxx` 查看加载库时详细信息\n1. `LD_DEBUG=libs LD_DEBUG_OUTPUT=lib ./xxx` 信息输出文件中\n\n   - 搜索 so -> 初始化 so -> 初始化 elf -> 控制转移到 elf -> 运行 elf -> 结束 elf -> 反序结束 so\n   - 可以看到搜索顺序; LD_LIBRARY_PATH -> RUNPATH from elf -> /etc/ld.so.cache\n   - 可以看到库的初始化顺序与完成顺序相反， 先初始化的库后完成\n   - 可以看到一次对动态库进行初始化，然后再对可执行程序进行初始化\n   - 可以指定 so 初始化和析构函数, 可用于注册机制?\n\n   ```c++\n       void __attribute__((constructor)) init_function();\n       void __attribute__((destructor))  fini_function();\n   ```\n\n1. info\n   - “files”，显示整个装载过程；\n   - “libs”，显示共享库查找过程；\n   - “symbols”，显示符号的查找过程；\n   - “bindings”，显示动态链接的符号绑定过程；\n   - “versions”，显示符号的版本依赖关系；\n   - “reloc”，显示重定位信息；\n\n## Binary Utils\n\n### Google bloaty(https://github.com/google/bloaty)\n\n1. 查看二进制大的原因\n1. [guide](https://github.com/google/bloaty/blob/main/doc/using.md)\n1. `bloaty -d symbols ./test`\n1. `bloaty -d compileunits ./test`\n1. `bloaty -v -d sections ./test`\n\n### [ghidra](https://github.com/NationalSecurityAgency/ghidra)\n\n1. 可以查看各个段内容\n\n### [elfutils](https://sourceware.org/elfutils/)\n\n1. eu-stack 可以跟踪 on-cpu and off-cpu, perf 只能跟踪 off-cpu\n\n### [GNU binutils](https://www.gnu.org/software/binutils/)\n\n1. reverse enginerring 各种工具查看段内容\n1. `ar` : 创建静态库，插入删除，列出和提取成员。\n1. `strings` : 列出一个目标文件中所有可打印的字符串。\n   - 找一个唯一字符串， 可以用来看程序是否为最新版本\n   - `strings build/out/osqp_demo | grep include  |  xargs  -t -I {} ls {} | grep signal.h`查看头文件\n1. `strip` : 从目标文件中删除符号表信息。 `file`可以查看是否 strip\n1. `nm` : 列出一个目标文件的符号表中定义的符号。\n\n   - `nm -A -l build/base` 显示文件名和行号(需要 debug 模式编译)\n   - `nm --undefined-only -C ./test` 查看 import symbols\n   - `nm --defined-only -C ./test` 查看 export symbols, export 可以看到 symbol 前面有地址\n   - `nm -S xxx`查看 defined symbols size\n   - `nm -S --size-sort test` 按 size 排序\n   - `man nm` 查看用法\n   - 大写全局，小写局部, 局部变量不会记录到符号表中（static 除外）\n   - b:bss, t:text, d:data, r:readonly\n   - `nm -C build/base` decode [Name_mangling](https://en.wikipedia.org/wiki/Name_mangling) this makes C++ function names readable.\n   - `extern \"C\" {}` 作用是阻止 C++ name mangling, 生成 C 格式符号表\n   - `c++filt _ZN9NS_QZSOCK10CTcpClient11SendAndRecvEPciRiRjd` c++filt Name De-Mangling\n   - 符号详解\n     - `T`: 定义：函数定义在当前模块中， `nm -C libxxx | grep \" T \"`查看当前模块定义的函数\n     - `U`: 声明：使用定义在其他模块中的函数\n     - `D`: 初始化的 data (静态初始化的变量)\n     - `B`: 未初始化的 data(动态初始化的变量)\n     - `N`: debug 符号\n\n1. `size` : 列出目标文件中的节的名字和大小。\n   - `size -A ./test` 列出 section 详细信息\n1. `readelf` : 显示一个目标文件的完整结构，包含 size 和 nm 的功能。\n   - `readelf -a -W -C bin2float|less` -W wide 显示， -C demangle(最新版本才支持)\n   - `readelf -d build/dog/dog_test1 | grep 'NEEDED'` 查看加载用到的库\n   - readelf -a test 先显示 section 信息， 然后显示 segment(Program Headers)信息，接着显示 Section to Segment mapping 信息\n   - `readelf -a test1 |grep ABI` 查看 elf ABI\n1. `objdump` : 所有二进制文件之母。能够显示一个目标文件中所有的信息。它最大作用是反汇编.text 节中的二进制指令。\n   - `objdump -p test | grep NEEDED` 查看加载用到的库\n   - `objdump -g libxxx.so | grep /data0/....` 动态库调试信息中找文件路径\n   - `objdump --dwarf=decodedline test` 显示内存地址映射到具体某行源代码\n   - `objdump -d -C test` 反汇编，demangle\n1. `ldd` : 列出一个可执行文件在运行时所需要的共享库。\n   - `ldd -v xxx` 列出依赖详细关系，包括依赖的依赖\n1. !notice : use tldr to show the basic usage.\n1. `cat /proc/pid/maps 或 pmap pid` 看进程映射区域\n\n## glibc 初始化\n\n1. `_start -> __libc_start_main -> __libc_csu_init -> _init -> __do_global_ctors_aux(c++构造函数) -> main -> __do_global_dtors_aux -> _fini -> __libc_csu_fini`\n\n## GCC 编译选项\n\n1. 给 gcc 加上`-fno-common`选项, 这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用 -Werror 选项，它会把所有的警告都变为错误。`set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-common\")`\n1. `-Wl,--whole-archive target -Wl,-no-whole-archive` 静态链接时把 target 都打包， 正常情况下只会将使用到的符号相关代码数据打包\n\n## other\n\n1. [编译期间获取类型名](https://zhuanlan.zhihu.com/p/268462046)\n\n```\ntemplate <typename T>\nconstexpr auto type_name() noexcept\n{\n    std::string_view name, prefix, suffix;\n#ifdef __clang__\n    name = __PRETTY_FUNCTION__;\n    prefix = \"auto type_name() [T = \";\n    suffix = \"]\";\n#elif defined(__GNUC__)\n    name = __PRETTY_FUNCTION__;\n    prefix = \"constexpr auto type_name() [with T = \";\n    suffix = \"]\";\n#elif defined(_MSC_VER)\n    name = __FUNCSIG__;\n    prefix = \"auto __cdecl type_name<\";\n    suffix = \">(void) noexcept\";\n#endif\n    name.remove_prefix(prefix.size());\n    name.remove_suffix(suffix.size());\n    return name;\n}\n```\n\n1. [运行时获取类名字](https://blog.csdn.net/K346K346/article/details/51698184)\n\n```c++\nclass Object\n{\npublic:\n    //用于在运行时获取对象的真实类型名称\n    virtual string getClassName() const\n    {\n#ifdef _MSC_VER\n        return typeid(*this).name() + 6;\n#else\n        const char* name = typeid(*this).name();\n\n        while (*name >= '0' && *name <= '9') name++;\n\n        return name;\n#endif\n    }\n};\n```\n\n1. 防止编译器优化\n\n```c++\n#pragma optimize off\nint globalVar\n#pragma optimize on\n```\n\n## buildid\n\n1. This allows two builds of the same program on the same host to always produce consistent build-ids and binary content.\n1. `readelf -n /bin/bash` or `file /bin/bash`\n1. [读取自己的 buildid](https://blog.csdn.net/flurry_rain/article/details/122544969)\n\n## links\n\n1. [cling online](https://cppcli.net/)\n1. [cling the-interactive-c++-interpreter](https://github.com/root-project/cling/)\n1. [程序的编译、装载与链接](https://zhuanlan.zhihu.com/p/139026433)\n1. [llvm 论坛](https://discourse.llvm.org/)\n1. [llvm beginner-resources-documentation](https://discourse.llvm.org/t/beginner-resources-documentation/5872)\n1. [llvm discord](https://discord.com/invite/xS7Z362) 312567150\n1. [My First Language Frontend with LLVM Tutorial](https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html)\n1. [llvm blog](https://blog.llvm.org/)\n1. [compiler-research](https://compiler-research.org/)\n1. [BuildYourOwnLispCn](https://github.com/ksco/BuildYourOwnLispCn)\n1. [Writing a C Compiler](https://norasandler.com/archive/)\n1. [craftinginterpreters](https://www.craftinginterpreters.com/)\n1. [llvm-ir-tutorial](https://github.com/Evian-Zhang/llvm-ir-tutorial)\n1. [机器学习编译器的前世今生](https://www.zhihu.com/question/401766029/answer/2733700454)\n\n## books\n\n1. 深入理解计算机系统\n1. 程序员的自我修养\n1. 程序是怎样跑起来的\n"},{"title":"KataOS","url":"/2022/10/20/KataOS/","content":"\n## Links\n\n1. [sparrow-manifest](https://github.com/AmbiML/sparrow-manifest)\n1. [announcing-kataos-and-sparrow](https://opensource.googleblog.com/2022/10/announcing-kataos-and-sparrow.html)\n1. [Running Rust programs in seL4 using the sel4-sys crate](https://antmicro.com/blog/2022/08/running-rust-programs-in-sel4/)\n"},{"title":"explore","url":"/2022/10/18/explore/","content":"\n## idea\n\n1. 新功能用 sourcegraph 探索大家都怎么使用的， 如探索 mermaid 使用\n\n## links\n\n1. [github trending](https://github.com/trending)\n1. [github next](https://githubnext.com/)\n1. [github star sort](https://github.com/search?o=desc&q=stars%3A%3E0&s=stars&type=Repositories)\n1. [productivity-tools](https://github.com/collections/productivity-tools)\n1. [awesome-selfhosted 可以部署到本地的服务](https://github.com/awesome-selfhosted/awesome-selfhosted)\n1. [freeCodeCamp](https://github.com/freeCodeCamp/freeCodeCamp)\n1. [build-your-own-x](https://github.com/codecrafters-io/build-your-own-x)\n1. [project-based-learning like build-your-own-x](https://github.com/practical-tutorials/project-based-learning#cc)\n1. [system-design-primer](https://github.com/donnemartin/system-design-primer)\n1. [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)\n1. [llvm discord](https://discord.com/invite/xS7Z362) 312567150\n1. [topics/profiling](https://github.com/topics/profiling)\n1. [Open Source Awards](https://osawards.com)\n1. [osawards.com/javascript](https://osawards.com/javascript/2022)\n1. [opensource.google](https://opensource.google/projects)\n1. [DIYgod](https://github.com/DIYgod)\n\n## blog\n\n1. [oneflow AI 基础设施](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU5ODY2MTk3Nw==&action=getalbum&album_id=2467151539284246528&scene=173&from_msgid=2247492618&from_itemidx=1&count=3&nolastread=1#wechat_redirect)\n1. [diygod](https://diygod.cc/)\n1. [brendangregg](https://www.brendangregg.com/overview.html)\n1. [arthurchiao](http://arthurchiao.art/articles-zh/)\n1. [码农半亩地](https://gaomf.cn/2020/06/03/shared_library_global_symbol_override/)\n1. [freelancer-leon/notes](https://github.com/freelancer-leon/notes/tree/master)\n"},{"title":"color","url":"/2022/10/15/color/","content":"\n## basic\n\n1. `GLOG_colorlogtostderr=1 ./test` glog 输出彩色\n1. [ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors) 全面；包含各种颜色值\n1. [tip_colors_and_formatting](https://misc.flogisoft.com/bash/tip_colors_and_formatting)\n1. [Linux 使用 echo 命令打印输出特定颜色的字符](https://zhuanlan.zhihu.com/p/363287904)\n   - `echo -e \"\\033[43;31;5m我是黄底红色的闪烁字符串\\033[0m\"` 输出字符串的的前部\"\\033[43;31m\"和后部\\033[0m 是固定用法，被称为`ANSI控制码`\n   - 前部的 43 是背景设置, 31 是字符颜色设置，5 是闪烁\n1. `dircolors` ls 显示颜色 env: `LS_COLORS` [在 Linux 命令行中自定义文本颜色](https://zhuanlan.zhihu.com/p/39600129)\n1. `#f12` 等效 `#ff1122`\n1. 开发板命令显示颜色：`alias ll=\"ls -al --color=auto\" alias ls=\"ls --color=auto\"`\n1. [PS1 set](https://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/)\n\n```sh\nexport PS1=\"\\e[0;31m\\u@\\h:\\W% \\e[m\"\nexport PS1=\"\\e[0;32m\\u@\\h:\\W% \\e[m\"\nexport PS1=\"\\e[0;33m\\u@\\h:\\W% \\e[m\"\n\n```\n\n1. `script -q -c \"bat symbol.json\" color.log > /dev/null` 将彩色输出保存到到文件中 [write stdout to file with colors](https://stackoverflow.com/a/27399198)\n1. ninja color output\n\n```cmake\nif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n    add_compile_options (-fdiagnostics-color=always)\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\")\n    add_compile_options (-fcolor-diagnostics)\nendif ()\n```\n\n## Emacs\n\n1. `list-face-display and list-colors-display` 列出颜色\n1. `rainbow-mode` buffer 里显示颜色\n1. color-196 大红\n1. [emacs 正则](https://www.emacswiki.org/emacs/RegularExpression)\n1. 正则需要`\\\\`来转义\n1. minor mode: deffac 创建 face, font-lock-add-keywords 和 font-lock-remove-keywords 添加规则, define-minor-mode 添加 minor mode\n\n```emacs-lisp\n;; log color\n(defgroup log-group nil\n  \"Group for customization\"\n  :prefix \"log-\")\n\n(defface log-highlight-numbers-face\n  '((t :foreground \"yellow\"))\n  \"Face for numbers\"\n  :group 'log-group )\n\n(defface log-highlight-file-face\n  '((t :foreground \"magenta\"))\n  \"Face for file\"\n  :group 'log-group )\n\n(defface log-highlight-success-face\n  '((t :foreground \"black\"\n       :background \"green\"))\n  \"Face for pass success\"\n  :group 'log-group )\n\n(defface log-highlight-warning-face\n  '((t :foreground \"black\"\n       :background \"yellow\"))\n  \"Face for warning\"\n  :group 'log-group )\n\n(defface log-highlight-fail-face\n  '((t :foreground \"black\"\n       :background \"red\"))\n  ;; :bold t))\n  \"Face for fail, error\"\n  :group 'log-group )\n\n(defface log-highlight-normal-face\n  '((t :foreground \"black\"\n       :background \"cyan\"))\n  ;; :bold t))\n  \"Face for normol\"\n  :group 'log-group )\n\n\n(defvar log-keywords '(\n                       (\"[[:space:]]\\\\(\\\\+\\\\|-\\\\)?[0-9]+\\\\(\\\\.[0-9]+\\\\)?[[:space:]]\" . 'log-highlight-numbers-face)\n                       (\"[[:space:]][0-9a-zA-Z\\-\\_\\/]+\\\\.\\\\(jpg\\\\|jpeg\\\\|yuv\\\\|yuyv\\\\|png\\\\|json\\\\|bin\\\\|hbm\\\\|engine\\\\|txt\\\\)\" . 'log-highlight-file-face)\n                       (\"\\\\<\\\\([Ff]ps\\\\|FPS\\\\)\" . 'log-highlight-normal-face)\n                       (\"\\\\<\\\\([Ss]uccess\\\\|SUCCESS\\\\|[Pp]ass\\\\|PASS\\\\)\" . 'log-highlight-success-face)\n                       (\"^E\\\\([0-9]+\\\\)\" . 'log-highlight-fail-face)\n                       (\"\\\\<\\\\([Ff]ail\\\\|FAIL\\\\|[Ee]rror\\\\|ERROR\\\\|[Aa]bort\\\\|ABORT\\\\|[Ff]ault\\\\|FAULT\\\\)\" . 'log-highlight-fail-face)\n                       (\"^W\\\\([0-9]+\\\\)\" . 'log-highlight-warning-face)\n                       (\"\\\\<\\\\([Ww]arning\\\\|WARNING\\\\|[Ww]arn\\\\|WARN\\\\)\" . 'log-highlight-warning-face)\n                       )\n  \"Keywords for log-minor-mode highlighting\")\n\n(define-minor-mode log-minor-mode\n  \"Minor mode for customization\"\n  :init-value nil\n  :lighter \" LogMode\"\n  :group 'log-group\n  (when (bound-and-true-p log-minor-mode)\n    (font-lock-add-keywords nil log-keywords)\n    (font-lock-fontify-buffer))\n  (when (not (bound-and-true-p log-minor-mode))\n    (font-lock-remove-keywords nil log-keywords)\n    (font-lock-fontify-buffer)))\n(add-to-list 'auto-mode-alist '(\"\\\\.log\\\\'\" . log-minor-mode))\n```\n\n## tools\n\n1. PowerToys: windows color pick: `win + shift + c`\n1. [chrome plugin colorzilla](https://chrome.google.com/webstore/detail/colorzilla/bhlhnicpbhignbdhedgjhgdocnmhomnp?hl=zh-CN) 可以用来显示 value\n\n### bat\n\n1. [adding-new-themes](https://github.com/sharkdp/bat#adding-new-themes)\n\n### [colout](https://github.com/nojhan/colout)\n\n1. `pip install colout` install\n1. `cat yolox.log | colout fps white.red` colout 当 grep 用\n1. `ls -l | colout \".\" blue`\n   - [theme](https://github.com/nojhan/colout/tree/master/colout)\n\n```python\n## colout_log.py\ndef theme(context):\n    return context, [\n        # Pass and success\n        [\n            \"([Ff][Pp][Ss]|[Pp][Aa][Ss][Ss])(ing|ING)?|(success|SUCCESS|Success)(ful|FUL)?\",\n            \"white.green\", \"bold\"\n        ],\n\n        # warning\n        [\"^W[0-9]+\\d\", \"white.yellow\", \"bold\"],\n        [\"([Ww][Aa][Rr][Nn])(ing|ING)?\", \"white.yellow\", \"bold\"],\n\n        # error fail\n        [\"^E[0-9]+\\d\", \"white.red\", \"bold\"],\n        [\n            \"([Ee][Rr][Rr][Oo][Rr]|[Ff][Aa][Ii][Ll]|[Aa][Bb][Oo][Rr][Tt])(ing|ING|ure|URE)?\",\n            \"white.red\", \"bold\"\n        ],\n\n        # file\n        [\n            \"(\\s[0-9a-zA-Z\\/\\_\\-]+.)(jpg|jpeg|yuv|yuyv|png|json|bin|hbm|engine|txt)\\s\",\n            \"magenta\", \"bold\"\n        ],\n\n        # []\n        # [\"(\\[[^\\]]+\\])\", \"cyan\", \"bold\"],\n\n        # num\n        [\"\\s\\d+\\s\", \"yellow\", \"bold\"],\n        [\"\\s\\d+[uUmMnN]?[sS]\", \"red\", \"bold\"],\n    ]\n```\n\n1. .bashrc 添加 function\n\n```sh\ncl() {\n\tset -o pipefail\n\tcat \"$@\" 2>&1 | colout -t log -T ~/\n}\ncless() {\n\tset -o pipefail\n\tcat \"$@\" 2>&1 | colout -t log -T ~/ | less\n}\n\n```\n\n### [TxtStyle](https://github.com/armandino/TxtStyle) 自定义输出颜色\n\n1.  [style](https://github.com/armandino/TxtStyle/blob/6fd9028587bedd67a99e1bf7e950ede2c8ef35fe/txtstyle/txtsconf.py#L31)\n1.  [sample](https://stackoverflow.com/a/62337029)\n1.  color log TxtStyle `cl test.log | less` or `ls -al | cl` or `bat test.log`\n\n```sh\ncl() {\n\tset -o pipefail\n\tcat \"$@\" 2>&1 | txts -n example --color-always\n}\n\n# .txts.conf\n[Style=\"example\"]\n# Print in red any line containing the word 'error'\n# !red: regex(\"error\")\n# !red: regex(\"ERROR\")\n# !red: regex(\"Error\")\n# !yellow bold: regex(\"warning\")\n# !yellow bold: regex(\"WARNING\")\n# !yellow bold: regex(\"Warning\")\nwhite on-yellow bold: regex(\"[Ww][Aa][Rr][Nn](ing|ING)?\")\nwhite on-red bold: regex(\"([Ee][Rr][Rr][Oo][Rr]|[Ff][Aa][Ii][Ll](ing|ING|ure|URE)?)\")\nwhite on-green bold: regex(\"([Ff][Pp][Ss]|[Pp][Aa][Ss][Ss](ing|ING)?)|(success|SUCCESS|Success)(ful|FUL)?\")\nwhite on-red bold: regex(\"^E[0-9]+\\d\")\nwhite on-yellow bold : regex(\"^W[0-9]+\\d\")\n# white on-green bold: regex(\"[Ff][Pp][Ss]\")\n\nyellow: regex(\"\\s[0-9]+\\s\")\nred: regex(\"\\s[0-9]+[uUmM][sS]\")\n# magenta: regex(\"\\s[^\\]]+.(jpg|jpeg|yuv|yuyv|png|json|bin|hbm|engine|txt)\")\nmagenta: regex(\"\\s[0-9a-zA-Z\\/\\_\\-]+.(jpg|jpeg|yuv|yuyv|png|json|bin|hbm|engine|txt)\")\n\n# Date\ngreen: regex(\"\\d{4}-\\d\\d-\\d\\d\")\n# Time\ngreen bold: regex(\"\\d\\d:\\d\\d:\\d\\d\")\n# IP address (and port number if present)\nyellow underline: regex(\"\\d+\\.\\d+\\.\\d+\\.\\d+(:\\d+)?\")\nmagenta: regex(\"\\[samplesession\\]\")\n# Catch-all for anything else inside [square brackets]\nblue: regex(\"\\[[^\\]]+\\]\")\n# Catch-all for any remaining standalone numbers\ncyan bold: regex(\"\b\\d+\b\")\n\n```\n\n### [lolcat](https://github.com/busyloop/lolcat)\n\n1. `pip install logcat`\n1. 彩色输出 `lolcat phigent.txt -F 0.02`\n\n### [logtool](http://xjack.org/logtool/)\n\n1. `sudo apt install logtool`\n1. `cat no_bug_car.txt | logtool > test.txt` 输出颜色\n\n## link\n\n1. [code style 主题：programmingfonts](https://www.programmingfonts.org/#ubuntu)\n1. [color palettes](https://coolors.co/palettes/palettes)\n1. [正则表达测试](https://regex101.com/)\n1. [正则表达式解释](https://tool.oschina.net/uploads/apidocs/jquery/regexp.html)\n"},{"title":"Markdown","url":"/2022/10/14/Markdown/","content":"\n## basic\n\n1. [color](https://stackoverflow.com/a/73613628)\n1. page break: `<div style=\"page-break-after: always; break-after: page;\"></div>`\n1. check box `- [x]`: 好好利用，写好 worklog\n1. `>` 注意符号\n1. diff\n\n```diff\npublic class Hello1\n{\n   public static void Main()\n   {\n-      System.Console.WriteLine(\"Hello, World!\");\n+      System.Console.WriteLine(\"Rock all night long!\");\n   }\n}\n```\n\n## emoji\n\n1. 直接复制就能用\n1. [webfx](https://www.webfx.com/tools/emoji-cheat-sheet/)\n1. [emojipedia](https://emojipedia.org/)\n1. [总结](https://gist.github.com/rxaviers/7360908)\n1. [cheatsheet](https://github.com/ikatyang/emoji-cheat-sheet#table-of-contents)\n1. ✅ 🔥 😀\n\n## Keybindings(emacs)\n\n1. stying test: C-c C-s\n2. toggle: C-c C-x\n3. help: C-c C-h\n4. outline navigation: same as org-mode\n5. running: C-c C-c\n\n### Links and Images\n\n1. C-c C-l: insert link\n2. C-c C-i: insert image\n\n### Text Styles C-c C-s\n\n1. C-c C-s i: _italic_\n2. C-c C-s b: **bold**\n3. C-c C-s c: `inline code`\n4. C-c C-s C: code block\n\n### Headings C-c C-s\n\n### Horizontal Rules C-c C-s -\n\n### Footnodes: C-c C-s f\n\n### Wiki Links\n\n### ...TODO\n\n## Reference\n\n1. [(good)markdown 教程](https://eblog.gitee.io/posts/hexo/hexo-writing-skills.html)\n1. [写的好的 markdown, 供参考](https://eblog.gitee.io/posts/hexo/hexo-theme-beautify.html)\n1. [markdown mode tutorial](https://github.com/jrblevin/markdown-mode)\n"},{"title":"v4l2","url":"/2022/10/09/v4l2/","content":"\n## usb 双目\n\n1. 只能打开一个原因 [link](https://www.21xrx.com/Articles/read_article/259051) [link2](https://blog.csdn.net/qq_32900237/article/details/102392445)\n1. 保存到同一画面上的优势：解决同步问题, 通过板载芯片来进行同步\n\n## [v4l2](http://zhaoxuhui.top/blog/2021/09/23/v4l2-introduction-and-usb-camera-bayer-raw-data.html)\n\n1. `sudo v4l2-ctl --list-devices`获取相机列表\n1. `media-ctl -p`\n1. `v4l2-ctl --all -d /dev/video`\n1. `v4l2-ctl -d /dev/video0 --list-formats-ext` 列出/dev/video0 支持的格式\n1. `yavta /dev/video0 -n3 -c10 -f YUYV -s1920x1282 --skip 9 -Fvideo0_#.yuv &` 从/dev/video0 拿图, 保存未.yuv\n1. `v4l2-ctl --set-fmt-video=width=1920,height=1282,pixelformat=YUYV --stream-mmap --stream-count=1 -d /dev/video0 --stream-to=camera_0_1920_1282_0.yuv` 获取一张图片\n1. [send video to /dev/video0](https://askubuntu.com/a/881341)\n1. `ffmpeg -y -t 15 -f video4linux2 -video_size 1920x1080 -input_format nv12 -timestamps abs -use_libv4l2 1 -i /dev/video0 out.mov` ffmpeg [link](https://superuser.com/q/1449252)\n\n## sample\n\n1. [wuhanstudio/capturev4l2](https://github.com/wuhanstudio/capturev4l2)\n1. [C\\+\\+ sample](https://www.kernel.org/doc/html/v4.9/media/uapi/v4l/capture.c.html) `gcc -o v4l2_test v4l2_test.c`\n1. simple opencv sample\n\n```c++\n#include \"opencv2/opencv.hpp\"\n#include \"iostream\"\n\nint main(int, char**) {\n    // open the first webcam plugged in the computer\n    cv::VideoCapture camera(0);\n    if (!camera.isOpened()) {\n        std::cerr << \"ERROR: Could not open camera\" << std::endl;\n        return 1;\n    }\n\n    // create a window to display the images from the webcam\n    cv::namedWindow(\"Webcam\", CV_WINDOW_AUTOSIZE);\n\n    // this will contain the image from the webcam\n    cv::Mat frame;\n\n    // capture the next frame from the webcam\n    camera >> frame;\n\n    // display the frame until you press a key\n    while (1) {\n        // show the image on the window\n        cv::imshow(\"Webcam\", frame);\n        // wait (10ms) for a key to be pressed\n        if (cv::waitKey(10) >= 0)\n            break;\n    }\n    return 0;\n}\n```\n\n## issue\n\n1. `OPENCV_LOG_LEVEL=DEBUG ./demo` 打开 opencv debug 信息\n1. 注意`/dev/video*` 权限\n1. 双目摄像头可能需要同时打开 `/dev/video0` 和 `/dev/video1`\n"},{"title":"bling","url":"/2022/10/09/bling/","content":"\n## zh\n\n1. 路径切换\n   ![cpp profiling](/images/gif/zh.gif)\n\n## emacs and tmux\n\n1. git 一键提交\n   ![emacs magit](/images/gif/emacs_magit.gif)\n\n1. 统计 log 中数值均值, 方差......\n   ![emacs statistics](/images/gif/mean.gif)\n\n1. emacs 中通过 tmux 将命令发送到另外 tmux panel，省去多次复制操作\n   ![emacs tmux](/images/gif/emacs_tmux.gif)\n\n1. 一键启动多进程程序\n   ![tmux send](/images/gif/tmux.gif)\n\n<!-- more -->\n\n## profiling\n\n1. c++ profiling 库， 一条语句来进行流程控制，fps 打印，各模块耗时统计表\n   ![cpp profiling](/images/gif/profiling.gif)\n","tags":["ideas"],"categories":["Others"]},{"title":"Life-experience","url":"/2022/10/09/Life-experience/","content":"\n## base\n\n1. `找到内心的召唤`， 做事要培养兴趣，不然很难做好 `Hackers write better code when it's for their own satisfaction instead of for pay.`\n1. `多尝试`，别怕出错\n1. `不要用反问` 老板要是换个说法，说“这个文件需要打印两份”。你觉得哪种说法更容易接受呢？明显后者听起来舒服多了。 比如你打印文件，老板跟你说“你怎么只打印一份啊？老板要是换个说法，说“这个文件需要打印两份”。你觉得哪种说法更容易接受呢？明显后者听起来舒服多了。老板要是换个说法，说“这个文件需要打印两份”。你觉得哪种说法更容易接受呢？明显后者听起来舒服多了。\n1. `能够轻易得到答案的简单问题不要问出口`，那并不会显得你很好学，反而会显得你无知又懒惰。\n1. `不经过思考后的答案不要脱口而出`，控制住嘴巴是你学会成熟的第一步。\n1. `说话尽量不要带“吧”字`，好和好吧，行和行吧，听你的和听你的吧，前者是直接坦率的，后者是犹豫而无奈的。要做就做，干脆一点，不然为何答应\n1. `要把自己当作一个公司去运营`，要有战略方向（你的人生目标），要有运营路径（你的行动方案），要有产品竞争力（你的个人能力维度），要有营销（你的公开表达），要有财务思维（你的收支平衡）\n1. `职场没有功劳就没有苦劳` 只有建立在功劳基础上的苦劳，才有价值。\n1. `远离抱怨的人`\n1. `生气时，学会闭嘴` 生气时，情绪完全被动物大脑控制，很容易得罪人。像钉子钉墙一样，就算把钉子拔出来，墙依然会有孔 最好的办法就是深呼吸，闭嘴。\n1. `如果找不到热爱的事业，先做最擅长的工作`\n1. `别糊弄`\n1. 别人找你帮忙的时候，不要果断答应。如果对方是爽快之人，你可以同样爽快交往。但对大部分人，不要急于表露自己的热情好客，你的直爽只会把你的付出变得廉价，在他眼里你办这事没有任何难度，不会从心里感激你，只是把你当工具人。\n"},{"title":"log","url":"/2022/09/30/log/","content":"\n## glog\n\n1. `GLOG_colorlogtostderr=1 ./test` 输出彩色\n1. `GLOG_alsologtostderr=false` 关闭 log\n1. export GLOG_log_dir=./log_tmp 输入 log 到 log_tmp 目录下\n\n## logrotate\n\n1. 使用 logrotate 实现 log 循环覆盖功能，将 log 文件限制在一定大小。由于 logrotate 程序不能解决多文件未知变量名的情况，讨论了一下解决办法，设置环境变量 GLOG_max_log_size=1，使得程序输出的 log 被分片，每片最大为 1M,然后使用脚本保留最新的几片 log，从而控制 log 的大小在一定范围内。\n\nhttps://www.cnblogs.com/kevingrace/p/6307298.html 配置\n\nhttp://blog.csdn.net/hxh129/article/details/8178647 指定文件大小，超过就转存\n\n```sh\nsize=`ll /var/log/messages | cut -d \" \" -f 5`\nif [ $size -ge xxxxx ];\nthen\nlogrotate  /xxx/xxx.conf;\nfi\n```\n\n## logrotate 功能\n\n```sh\ncd /tmp\nwhile sleep 15; do\n        file_num=`ls -l |grep \"^-\"|wc -l`\n        if [ \"$file_num\" -gt 8 ]; then\n                rm_num=$(($file_num - 8))\n                for i in `ls -t /tmp | tail -n $rm_num`; do\n                        rm \"$i\"\n                done\n        fi\ndone\n\ncd /tmp\nwhile sleep 15; do\n        file_num=`ls -l |grep \"^-\"|wc -l`\n        echo \"$file_num\"\n        if [ \"$file_num\" -gt 8 ]; then\n                rm_num=$(($file_num - 8))\n                echo \"$rm_num\"\n                ls -lt\n                for i in `ls -t /tmp | tail -n $rm_num`; do\n                        echo \"clear log file $i\";\n                        rm \"$i\" || echo ok\n                done\n        fi\ndone\n\nalive_counter=0\nprog=run_smartsv\ncd /tmp\nwhile sleep 5; do\n    if [ $((alive_counter % 5 )) -eq 0 ]; then\n        echo test\n        file_num=`ls -l |grep \"^-\"|wc -l`\n        echo \"$file_num\"\n        if [ \"$file_num\" -gt 6 ]; then\n                rm_num=$(($file_num - 6))\n                echo \"$rm_num\"\n                ls -lt\n                for i in `ls -t /tmp | tail -n $rm_num`; do\n                        echo \"clear log file $i\";\n                        rm \"$i\" || echo ok\n                done\n        fi\n    fi\ndone\n```\n"},{"title":"wallpaper","url":"/2022/09/29/wallpaper/","content":"\n## 桌面背景制作\n\n1. color value : `1E1E1E`\n1. [express.adobe](https://express.adobe.com/zh-Hans-CN/sp/design/post/urn:aaid:sc:VA6C2:a245b511-f975-4454-94d9-cdb73067395b) 先抠图，纯色背景，调整透明度\n1. [canva](https://www.canva.com)\n1. [think twice 模板链接](https://www.canva.com/design/DAFNl8MDuMs/Og2VZlsR1bnZXNcsOhPOYg/view?utm_content=DAFNl8MDuMs&utm_campaign=designshare&utm_medium=link&utm_source=publishsharelink&mode=preview)\n1. [在线抠图](https://picwish.cn/upload)\n\n## links\n\n1. [canva 搜索壁纸](https://www.canva.com/search/templates?q=%E5%A3%81%E7%BA%B8%E6%B1%BD%E8%BD%A6&fCategory=tACZCp5JRWg&filters=eyJBIjoiTUBmcFVZX0dNQlhrM19idyIsIkE%2FIjoiQyIsIkQiOiIwMDAwMDAifQ%3D%3D)\n1. [口袋妖怪适合 zenburn 背景的壁纸](https://wallpaperaccess.com/full/1644661.jpg)\n1. [口袋妖怪壁纸](https://wallpaperaccess.com/awesome-gengar)\n1. [口袋妖怪壁纸黑](https://wallpaperaccess.com/black-pokemon)\n1. [ubuntu 每一版壁纸汇总](http://ubuntu.ecchi.ca/wallpapers/)\n1. [ubuntu 壁纸](https://wallpaperaccess.com/ubuntu)\n1. [windows 壁纸](https://wallpaperhub.app/creators/genrolecaspe)\n1. [windows 壁纸 2](https://wallpaperhub.app/wallpapers/?tags=windows)\n1. [close scroll bar](https://github.com/microsoft/terminal/issues/3878#issuecomment-735253417)\n1. [themes](https://windowsterminalthemes.dev/)\n1. [programmer backgroud](https://wallpapers.com/wallpapers/4k-programming-codes-in-black-screen-cl72lv0j7uvh4bmy.html)\n1. [cool car](https://wallpapers.com/wallpapers/cool-car-neon-blue-j3a9pqeowr7ywja3.html)\n1. [cool](https://express.adobe.com/zh-Hans-CN/sp/design/post/urn:aaid:sc:VA6C2:928899ca-b02d-442f-9132-8607d4a4fada?workflow=quicktask)\n1. [car](https://m.media-amazon.com/images/S/aplus-media-library-service-media/d64dd730-5df0-4bd0-a30c-c78d168d48bd.__CR0,0,1464,625_PT0_SX1464_V1___.jpg)\n1. [cool-sports-car](https://wallpaperaccess.com/cool-sports-car)\n"},{"title":"Pandoc","url":"/2022/09/27/Pandoc/","content":"\n## base\n\n1. Pandoc is a Haskell library for converting from one markup format to another, and a command-line tool that uses this library.\n1. [pandoc](https://github.com/jgm/pandoc) (The universal markup converter 可以转换各种标记语言)\n\n## usage\n\n1. [demos](https://pandoc.org/demos.html)\n1. [online 转换](https://pandoc.org/try/)\n1. markdown to pdf `pandoc MANUAL.md --pdf-engine=xelatex -o example13.pdf`\n"},{"title":"Document","url":"/2022/09/26/Document/","content":"\n## 文档\n\n1. [参考 bazel](https://bazel.build/?hl=zh-cn)\n1. are several main types of documents that software engineers often need to write:\n\n   - Reference documentation, including code comments 参考文档，包括代码注释\n   - Design documents 设计文档\n   - Tutorials 教程\n   - Conceptual documentation 概念文档\n   - Landing pages 着陆页\n   - quickstart, Getting Started\n   - introduction, overview\n\n1. [Software-Engineering-at-Google](https://qiangmzsx.github.io/Software-Engineering-at-Google/#/zh-cn/Chapter-10_Documentation/Chapter-10_Documentatio)\n\n## tools\n\n1. [pandoc](https://github.com/jgm/pandoc) (The universal markup converter 可以转换各种标记语言)\n1. doxygen\n1. [sphinx-doc/sphinx](https://github.com/sphinx-doc/sphinx)\n1. Latex [pandoc-latex-template](https://github.com/Wandmalfarbe/pandoc-latex-template)\n1. [readthedocs](https://readthedocs.org/)\n"},{"title":"github","url":"/2022/09/26/github/","content":"\n## explore\n\n1. [start sort](https://github.com/search?o=desc&q=stars%3A%3E0&s=stars&type=Repositories)\n1. [octobox.io 管理 github 通知](https://octobox.io/)\n   - 直接登录 github 就能显示\n\n## gist\n\n## base\n\n1. 访问 github 有问题，访问 gitlab 无问题， 可以先用 gitlab 去 mirrors github repo， 再访问 gitlab\n1. 点击`go to file`， 搜索文件\n"},{"title":"LaTeX","url":"/2022/09/25/LaTeX/","content":"\n## base\n\n1. LaTeX: Lamport TeX\n1. 读音：莱泰克\n1. [调整字体大小](https://www.overleaf.com/learn/latex/Font_sizes%2C_families%2C_and_styles)\n1. 中文问题 `\\begin{CJK}{UTF8}` 换成 `\\begin{CJK}{gbsn}` [link](https://www.cnblogs.com/zyl910/archive/2013/06/02/doxygen_pdf_chinese.html)\n1. 换页问题： `\\doxysection` 之前加 `\\newpage`\n1. [fancy Headers_and_footers](https://www.overleaf.com/learn/latex/Headers_and_footers)\n   - `O` or `E`: to specify Odd or Even pages\n   - `H` or `F`: to indicate Header or Footer\n   - `L`, `C` or `R`: for the Left, Centre and Right “zone” of the header or footer\n1. `\\pagestyle{fancyplain}` doxygen refman.tex 删除之后页眉页脚不再有横杠\n1. pagestyle `\\pagestyle{⟨style⟩}` [link](https://www.overleaf.com/learn/latex/Headers_and_footers)\n   - empty: no headers or footers on pages\n   - plain: no page headers, footers consist of a centered page number\n   - headings: no footers, headers contains class-specific information and page number\n   - myheadings: no footers, headers contains page number and user-supplied information\n1. picture in header [link](https://tex.stackexchange.com/a/122936) picture 下可以添加官网网址，并加上点击链接 `\\fancyhead[L]{\\includegraphics[width=3cm]{logo1} \\\\\\href{https://www.wikibooks.org}{Wikibooks home}}`\n1. oneside or twoside [link](https://www.overleaf.com/learn/latex/Single_sided_and_double_sided_documents#Difference_between_one-side_and_two-side_documents)\n1. chapter style [link](https://tex.stackexchange.com/a/18605)\n1. [list of features and tables](https://www.overleaf.com/learn/latex/Lists_of_tables_and_figures)\n\n```sh\n% Headers & footers\n\\usepackage{fancyhdr}\n\\pagestyle{fancy}\n\\setlength\\headheight{32pt}\n\\fancyhead{}\n\\fancyhead[L]{\\includegraphics[width=3cm]{logo1}}\n\\fancyhead[R]{\\text{dcv-cpp 开发手册} \\\\[4pt] \\\\\\text{\\fancyplain{}{\\rightmark}}}\n% \\renewcommand{\\headrulewidth}{0pt}\n% \\renewcommand{\\footrulewidth}{0pt}\n\\renewcommand{\\headruleskip}{2.5pt}\n% \\renewcommand{\\footruleskip}{0pt}\n```\n\n1. 首页设置\n\n```sh\n\\begin{titlepage}\n\\vspace*{7cm}\n\\begin{center}%\n\\includegraphics[width=4cm]{logo1}\n\n\\textbf{\\Huge heimdallr-\\/sdk 用户手册 \\\\[3ex]\\Large v1.\\+0.\\+0 }\\\\\n\\vfill\n\\vspace*{1cm}\n{\\large 制作者 PhiGent Robotics}\\\\\n\\end{center}\n\\end{titlepage}\n```\n\n## editer\n\n1. [vscode](https://github.com/James-Yu/LaTeX-Workshop)\n1. [online editer overleaf](https://www.overleaf.com/)\n   - 点击可以到对应代码\n   - 可以修改主题， 编译器, 字体大小，style 等\n   - 添加 package [link](https://tex.stackexchange.com/a/536730)\n   - doxygen 需要的 sty: tabu_doxygen.sty, ongtable_doxygen.sty, doxygen.sty\n\n## Tutorial\n\n1. [overleaf Learn_LaTeX_in_30_minutes](https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes)\n1. [Begin-Latex-in-minutes](https://github.com/luong-komorebi/Begin-Latex-in-minutes)\n1. [Begin-Latex-in-minutes Chinese](https://github.com/luong-komorebi/Begin-Latex-in-minutes/blob/master/Translation-Chinese.md)\n\n## 简历模板\n\n1. The CV presents a full history of your academic credentials, so the length of the document is variable. In contrast, a resume presents a concise picture of your skills and qualifications for a specific position, so length tends to be shorter and dictated by years of experience (generally 1-2 pages).\n1. CV 是履历，Resume 是简历。\n\n   - Resume，简述于求职相关的教育背景和工作经历，其目的在于说服用人单位雇用自己；\n   - CV，Curriculum Vitae 事集中说明学术工作，不重视与文化程度和学习成绩无直接关系的资料。\n\n1. [Awesome-CV](https://github.com/posquit0/Awesome-CV) CV: Curriculum Vitae 个人简历\n1. [overleaf awesome-cv template](https://www.overleaf.com/latex/templates/awesome-cv/dfnvtnhzhhbm)\n1. [latexcv](https://github.com/jankapunkt/latexcv/tree/master/sidebar)\n1. [awesome-resume-for-chinese](https://github.com/dyweb/awesome-resume-for-chinese)\n\n## links\n\n1. [ drawing neural networks for reports and presentation](https://github.com/HarisIqbal88/PlotNeuralNet)\n1. [pandoc-latex-template](https://github.com/Wandmalfarbe/pandoc-latex-template)\n1. [TI 文档参考](https://www.ti.com/lit/an/spracz2/spracz2.pdf?ts=1664353778597&ref_url=https%253A%252F%252Fwww.google.com%252F)\n"},{"title":"DataStructure","url":"/2022/09/15/DataStructure/","content":"\n## CPP\n\n### map\n\n1. unordered_map 排序：使用 map `std::map<int, int> ordered(unordered.begin(), unordered.end());` [link](https://stackoverflow.com/a/6212709)\n1.\n"},{"title":"J5","url":"/2022/09/14/J5/","content":"\n## software development\n\n1. 功能\n1. 指标\n1. 性能\n\n## docker\n\n1. [ai_toolchain_ubuntu_20_j5_cpu](https://hub.docker.com/r/openexplorer/ai_toolchain_ubuntu_20_j5_cpu/tags)\n1. [ai_toolchain_ubuntu_20_j5_gpu](https://hub.docker.com/r/openexplorer/ai_toolchain_ubuntu_20_j5_gpu/tags)\n\n## Model Convert\n\n1. PTQ 根据算法计算 scale, QAT 训练的时候学习 scale\n1. `PTQ` 后量化（即：Post-training Quantization，浮点定点转换方案 ）：先训练浮点模型，然后使用校准图片计算量化参数，将浮点模型转为量化模型。该方法简单、快捷，但将浮点模型直接转为量化模型难免会有一些量化损失，地平线浮点转换工具链中提供的后量化工具能做到 80%以上的模型量化误差小于 1%。\n1. `QAT` 量化训练 （Quantization Aware Training）通过在训练过程中融入量化和反量化过程，来实现量化模型的精度恢复, 由于量化是每层独立进行的，所以每层的量化是不依赖于前一层量化的结果的，这就导致了在实际的 inference 过程中会出现误差累积的情况，我们需要一种可学习的 scale。QAT 就是在做这样一件事情\n1. 浮点转定点工具链生成物是异构混合模型 bin 文件，与量化训练方案中最后的定点模型 hbm 文件有概念上的差异。\n\n## Runtime 部署\n\n1. `format`: NV12, NV12_SEPERATE, BGR, YUV\n1. `layout`: NCHW or NHWC\n1. `type`: float, S32, int8; quant and dequant 定浮点转换\n1. `memory`: alloc, free, sync\n1. `inference`: setinput, do, getoutput\n1. `align`: model output align\n\n## hardware acceleration\n\n1. VPS 硬件：提供了缩放，镜像，旋转，矫正，流控，金字塔等图像处理能力。硬件上由单个 IPU，单个金字塔 PYM，两个 GDC 组成。软件上则采用分组来实现分时复用硬件，最大支持 8 个组的分时复用。\n1. VENC/VDEC 模块：编解码\n\n## 金字塔配置\n\n1. 参考《MU-3020-12-J5-视频通路配置指南》vpm 配置\n1. 1920 _ 1080 -> 896 _ 512（需要 16 的倍数)\n   - bl 线性变换到 960 \\* 540\n   - ds roi 设置 960 \\* 540 roi 0, 0, 960, 540\n   - ds 设置 output 为 896 \\* 512\n\n## Tools\n\n1. 交叉编译: OE(OpenExplorer 天工开物开发平台)\n1. 系统升级\n1. 查看模型信息\n1. profiling\n1. dump 对数\n1. `hrut_ddr -t all -p 1000000 -n 1` 查看 ddr 读写带宽\n1. `hrut_bpuprofile -b 2 -r 0`查看 bpu 使用率\n\n## Links\n\n1. [一文了解模型量化中的 QAT 和 PTQ](https://blog.csdn.net/m0_38043555/article/details/118278641)\n1. [j5 开发板信息](https://developer.horizon.ai/api/v1/fileData/horizon_j5_open_explorer_v1_1_40c_py38cn_doc/oe_mapper/source/appendix/hardware/dev_board_kit.html)\n1. [horizon_j5_open_explorer_v1_1_40c_py38cn_doc](https://developer.horizon.ai/api/v1/fileData/horizon_j5_open_explorer_v1_1_40c_py38cn_doc/vdsp/dsp_rpc_api_doc/source/index.html)\n1. [Cadence NatureDSP Library for MathX KP6 DSP cores](https://github.com/cad-rlc/ndsp-kp6)\n1. [x3 模型官方性能](https://developer.horizon.ai/api/v1/fileData/doc/ddk_doc/navigation/ai_toolchain/docs_cn/horizon_ai_toolchain_user_guide/chapter_6_appendix.html)\n1. [pointpillar dps 加速](https://developer.horizon.cc/api/v1/fileData/horizon_j5_open_explorer_cn_doc/vdsp/dsp_example_doc/source/dsp_example.html#pointpillars)\n"},{"title":"SOA","url":"/2022/09/07/SOA/","content":"\n## Basic\n\n1. SOA 是一种架构风格\n1. 实际上 SOA 只是一种架构设计模式，而 SOAP、REST、RPC 就是为了实践这种设计模式而设计的数据通讯方式，其中 SOAP 通俗理解就是服务间通过 http+xml 的形式完成数据交换，REST 就是 http+json 的形式，RPC 是基于 socket 的形式。CXF 框架就是典型的 SOAP/REST 框架，Dubbo 就是典型的 RPC 框架，而 SpringCloud 就是遵守 REST 规范的微服务生态系统。\n   1 .后来又有了微服务的概念，个人理解微服务和 SOA 就是孪生子。如今生产实践中提到的微服务，在 SOA 的基础上更进一层，引入了很多新的东西如服务治理、链路跟踪、配置管理等等可以帮助企业构建高可用高并发高性能的系统的组件。\n1. 为什么服务总是和以太网，DDS 或 SOME/IP 绑定的呢？CAN 网络上是否可以实现完整的 SOA 架构？\n   - 首先，以 SOME/IP 举例，因为 SOME/IP 的完整名称其实能回答上面的大多数问题，SOME/IP = Scalable service-Oriented Middleware over IP。即“运行于 IP 之上的可伸缩的面向服务的中间件”。可见，并不是 SOA 必须和 SOME/IP 绑定，而是 SOME/IP 天生就是为了 SOA 架构而生。\n   - SOME/IP 的精华在于“Middleware 中间件”，这是一种独立的系统软件或服务程序，分布式应用软件可借助 Middleware 在不同的技术之间共享资源。分布式应用软件，在这里指的就是“服务”；不同的技术之间，在这里指的就是不同的平台或操作系统，比如 Linux 系统或 AUTOSAR OS OSEK 等。\n   - Scalable Middleware，顾名思义，则是“可伸缩中间件”，指的是该中间件能够适配于不同的平台及操作系统，其支撑的平台可大可小。\n   - 简单来说，SOA 是软件架构的一种设计理念；SOME/IP 是一种将软件接口进行打包的打包方式，是一种中间件。而汽车行业通常所指的\"以太网\"是泛化之后的概念，涵盖了基于以太网技术所实现的各种相关技术手段，包括 TCP/IP 协议、DoIP 协议、SOME/IP 协议等。当然若通过其他非以太网的通信方式来实现 SOA 也是可行的，但通常大家不那么用。比如基于 CAN 总线的架构，由于其基础的架构和通信协议栈里不存在 Middleware 中间层的概念，所以要实现 SOA 的代价是非常巨大的。\n1. 以服务导向的软件系统构架（SOA）将成为主流，以 SOA/SOME-IP 为脉络支撑起汽车以服务为出发点和差异化竞争的整车 E/E 架构。\n1. `SOA`（Service-Oriented Architecture，面向服务的架构）\n1. SOA 的软件架构\n   ![SOA的软件架构](https://mmbiz.qpic.cn/mmbiz_png/dgmES0HFW0utCXbf5mDOFepsQSA2wVFPBqzgGf38bkxsJOlMEkjvHG3H5ibs5ZW9Mw968jLxgOOpVk8iaKNRdABg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1. ![SOA汽车分层模型](https://mmbiz.qpic.cn/mmbiz_png/dgmES0HFW0utCXbf5mDOFepsQSA2wVFPBqzgGf38bkxsJOlMEkjvHG3H5ibs5ZW9Mw968jLxgOOpVk8iaKNRdABg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1. [SOA 所解决的核心问题](https://segmentfault.com/a/1190000040618603)\n   - 系统集成：站在系统的角度，解决企业系统间的通信问 题，把原先散乱、无规划的系统间的网状结构，梳理成规整、可治理的系统间星形结构，这一步往往需要引入 一些产品，比如 ESB、以及技术规范、服务管理规范；这一步解决的核心问题是【有序】\n   - 系统的服务化：站在功能的角度，把业务逻辑抽象成可复用、可组装的服务，通过服务的编排实现业务的快速再生。目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用；这一步解决的核心问题是【复用】\n   - 业务的服务化：站在企业的角度，把企业职能抽象成可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力；前面两步都是从技术层面来解决系统调用、系统功能复用的问题。第三步，则是以业务驱动把一个 业务单元封装成一项服务。这一步解决的核心问题是 【高效】\n\n## Links\n\n1. [车载 SOA 软件架构技术规范 1.0](https://www.kdocs.cn/l/sbWWKnW352t2)\n1. [\"域\"测未来 \"域\"见 SOA](https://www.3cst.cn/Information/info/RHcujT3VVDQD11ea8d6300163e0473d8)\n1. [什么是 SOA？什么是微服务？SOA 和微服务有什么区别？](https://bbs.huaweicloud.com/blogs/315752)\n1. [面向 SOA 服务的智能汽车高性能计算平台布局与测试方案](https://www.sohu.com/a/523519503_560178)\n1. [SOA 中的软件架构设计及软硬件解耦方法论](https://www.3cst.cn/Information/info/ALwsiHASP99L11ea8d6300163e0473d8)\n1. [MVC、 RPC、SOA 和 微服务架构异同](https://www.jianshu.com/p/48839b7d0050)\n"},{"title":"软件架构图","url":"/2022/09/07/软件架构图/","content":"\n## Basic\n\n1. 画图工具\n\n   - [excalidraw](https://excalidraw.com/)\n\n1. 黑色背景图更清晰显眼 [test](https://excalidraw.com/#json=QQSsjTtgSH00X3SatzWVM,fCNSETDLrfuaDv7-iRMwAA)\n1. 黑白灰就可以让框图显示的清晰\n1. 动态流程图 [link](https://www.bilibili.com/video/BV1by4y167EA/)\n1. 交互式流程图 [link](http://www.jtopo.com/)\n1. ProcessOn 数据流图动图\n1. [用 JointJs 实现数据流图](https://juejin.cn/post/7111894700952387621)\n1. [如何用 drawio 让自己的流程图线条产生动起来的效果](https://www.drawzh.com/1457.html)\n1. [figma motion](https://babkin-pavel.medium.com/how-to-animate-objects-along-the-path-in-figma-motion-plugin-370f3bf95e7b)\n1. [figma flow arrow](<https://www.figma.com/file/35Xwhb4WtXZdRGQlWDdewn/Motion---UI-and-Games-animation-(Community)?node-id=0%3A1>)\n\n## 层次图\n\n### sample\n\n1. [微软程序建构指南](<https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ee658124(v=pandp.10)>)\n   ![Common application architecture](<https://docs.microsoft.com/en-us/previous-versions/msp-n-p/images/ee658124.b8220f0d-f76a-40d6-8b1b-5279f7cdcee9(en-us,pandp.10).png>)\n1. appolo\n   ![Apollo 7.0](https://github.com/ApolloAuto/apollo/raw/master/docs/demo_guide/images/Apollo_7_0.png)\n1. vitis-ai-library\n   ![vitis-ai-library](https://github.com/Xilinx/Vitis-AI/raw/master/src/Vitis-AI-Library/ai_library_diagram.png)\n1. dcv-cpp\n   ![dcv-cpp](/images/software-diagram/dcv-cpp.jpg)\n1. [理想的软件自研规划](https://inews.gtimg.com/newsapp_bt/0/14916534758/1000)\n   ![理想的软件自研规划](/images/software-diagram/lixiang.png)\n1. ![SOA汽车分层模型](https://mmbiz.qpic.cn/mmbiz_png/dgmES0HFW0utCXbf5mDOFepsQSA2wVFPBqzgGf38bkxsJOlMEkjvHG3H5ibs5ZW9Mw968jLxgOOpVk8iaKNRdABg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n1. ![华为MDC智能驾驶计算平台](https://img-blog.csdnimg.cn/20210414055550879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1amlhbmluZ18xMTAxMTc=,size_16,color_FFFFFF,t_70)\n1. [华玉通软 Greenstone 智能驾驶基础软件平台](https://nwzimg.wezhan.cn/contents/sitefiles2049/10245019/images/23519503.png)\n   ![华玉通软Greenstone 智能驾驶基础软件平台](/images/software-diagram/huayu.png)\n1. ![华玉通软应用](https://nwzimg.wezhan.cn/contents/sitefiles2049/10245019/images/25100339.gif)\n1. ![nvidia](http://nvidia.zhidx.com/uploadfile/2018/10/5bce021d3364a.jpg)\n"},{"title":"AUTOSAR","url":"/2022/09/06/AUTOSAR/","content":"\n## basic\n\n1. `AUTOmotive Open System ARchitecture`\n1. 开发标准化：interfaces, exchange formats, methodology\n1. 代码分为静态代码和动态代码，静态是写死的，动态是根据配置自动生成的\n1. 配置通过[axml](https://developer.cisco.com/docs/axl/#!what-is-axl)\n1. 有三层：application, runtime environment(rte) 和 basic Software(bsw), 每一层通过标准接口通信。(没有增加中间层解决不了的问题)\n1. `Any problem in computer science can be solved by another layer of indirection` 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决\n1. application 由 software component(swc)组成\n1. rte 均是动态代码，类似事件总线, 起到交换机的作用\n1. runnables 类似 graph 概念, 是一个静态概念，tasks 是动态概念, 有 map 机制，将静态概念映射到动态\n1. 区分好静态概念和动态概念：如 graph 是静态概念，runner 是动态概念， 静态是一种表示(程序)， 动态运行静态概念(进程)\n\n## Links\n\n1. [release](https://www.autosar.org/nc/document-search/?tx_sysgsearch_pi1%5Bquery%5D=&tx_sysgsearch_pi1%5Bcategory%5D%5B150%5D=150)\n1. [AUTOSAR Introduction: The AUTOSAR Partnership and Standardization(官网)](https://www.autosar.org/fileadmin/user_upload/AUTOSAR_EXP_Introduction_Part1.pdf)\n1. [AUTOSAR Introduction: Current Features in a Nutshell(官网)](https://www.autosar.org/fileadmin/user_upload/AUTOSAR_EXP_Introduction_Part2.pdf)\n1. [Adaptive Autosar 整体架构理解](https://blog.csdn.net/AgingMoon/article/details/102813280)\n1. [AUTOSAR 与 ROS2 区别](https://www.3cst.cn/Information/info/1uwAF7ySxL8111ea8d6300163e0473d8)\n"},{"title":"域控制器","url":"/2022/09/06/域控制器/","content":"\n## Basic\n\n1. 在今天软件定义汽车和汽车智能化、网联化的发展趋势下，原来基于 ECU 的分布式 EEA 也日益暴露诸多问题和挑战。为了解决分布式 EEA 的这些问题，人们开始逐渐把很多功能相似、分离的 ECU 功能集成整合到一个比 ECU 性能更强的处理器硬件平台上，这就是汽车“域控制器（Domain Control Unit，DCU）”。\n1. ECU（Electronic Control Unit）电子控制单元，又称“行车电脑”、“车载电脑”等。它和普通的电脑一样,由微控制器（MCU）、存储器（ROM、RAM）、输入/输出接口（I/O）、模数转换器（A/D）以及整形、驱动等大规模集成电路组成。\n1. 经典的五域集中式 EEA ：\n   - 动力域（Power Train）\n   - 底盘域（Chassis）\n   - 车身域（Body/Comfort）\n   - 座舱域（Cockpit/Infotainment）\n   - 自动驾驶域（ADAS）\n1. 在五域集中式架构基础上进一步融合，把原本的动力域、底盘域和车身域融合为整车控制域，从而形成了三域集中式 EEA，也即：\n\n   - 车控域控制器（VDC，Vehicle Domain Controller）\n   - 智能驾驶域控制器（ADC，ADAS\\AD Domain Controller）\n   - 智能座舱域控制器（CDC，Cockpit Domain Controller）\n\n1. 在分布式 ECU 时代，计算和控制的核心是 MCU 芯片，传输的基础核心是基于传统的 CAN、LIN 和 FlexRay 等低速总线。\n1. 在域控制器时代，高性能、高集成度的异构 SoC 芯片作为域的主控处理器，将成为域控制器的计算与控制的核心芯片。而汽车 `TSN（Time-Sensitive Network）`以太网因为具有高带宽、实时和可靠的数据通信能力等特点，必将成为整车通信的核心基础设施，尤其是域主控处理器之间的通信主干网。\n1. 分布式 => （跨）域集中式 => 中央+区域集中式\n\n## Links\n\n1. [国内主机整车 EEA 架构汇总](https://zhuanlan.zhihu.com/p/561699068)\n1. [深度分析汽车芯片的现状与发展（一）汽车电子电气架构的变革](https://zhuanlan.zhihu.com/p/460683077)\n1. [深度分析汽车芯片的现状与发展（二）域控制器时代](https://zhuanlan.zhihu.com/p/461714692)\n1. [深度分析汽车芯片的现状与发展（三）ADAS/AD 域控制器及芯片平台分析](https://zhuanlan.zhihu.com/p/462675111)\n1. [深度分析汽车芯片的现状与发展（四）整车控制域](https://zhuanlan.zhihu.com/p/464930132)\n1. [2022 年自动驾驶域控制器行业概览](https://pdf.dfcfw.com/pdf/H3_AP202205181566386836_1.pdf?1652907375000.pdf)\n"},{"title":"ROS2","url":"/2022/09/06/ROS2/","content":"\n## Basic\n\n1. [ROS2 节点介绍](https://fishros.com/d2lros2foxy/#/chapt3/3.1ROS2%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D)\n\n## Links\n\n1. [ROS1 与 ROS2、AUTOSAR 与 ROS2 区别](https://www.3cst.cn/Information/info/1uwAF7ySxL8111ea8d6300163e0473d8)\n"},{"title":"CANBUS","url":"/2022/09/06/CANBUS/","content":"\n## Basic\n\n## Links\n\n1. [CAN FD 协议实用指南](https://zhuanlan.zhihu.com/p/178274029)\n1. [CAN FD 总线协议深度解析-简单易懂协议详解](https://blog.csdn.net/u013606261/article/details/112529205)\n1. [DBC 文件：](https://zhuanlan.zhihu.com/p/141638034) DBC 是 Database Can 的缩写，其代表的是 CAN 的数据库文件，在这个文件中把 CAN 通讯的信息定义的非常完整清楚，而 CAN 网络的通讯就是依据这个文件的描述进行的，所以 DBC 文件的作用非常强大，正是因为有了它才可以使得整个 CAN 网路的节点控制器无差错的协同同步开发。\n1. [CANoe 软件介绍](https://zhuanlan.zhihu.com/p/343635976)\n"},{"title":"IDL","url":"/2022/09/06/IDL/","content":"\n## Basic\n\n1. [接口描述语言（Interface description language，缩写 IDL）](https://zh.m.wikipedia.org/zh-hans/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80)\n1. 是用来描述软件组件介面的一种计算机语言。IDL 通过一种独立于编程语言的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用 C++写成，另一个组件用 Java 写成。\n   IDL 通常用于远程调用软件。在这种情况下，一般是由远程客户终端调用不同操作系统上的对象组件，并且这些对象组件可能是由不同计算机语言编写的。IDL 建立起了两个不同操作系统间通信的桥梁。\n1. [idl 开发示意图](https://p1.itc.cn/q_70/images03/20220217/2bd3a649a51c4cd08a37ac5c0e864e97.png)\n"},{"title":"消息中间件","url":"/2022/09/05/消息中间件/","content":"\n## 中间件\n\n1. [自动驾驶汽车的软件连接解决方案](https://www.rti.com/rti-blog-cn/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%9E%E6%8E%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)\n   - 第一种选择是利用为大规模系统开发的云和企业技术\n   - 第二种选择是从头开始构建解决方案。\n   - 第三种方法是选择一种新的汽车平台，例如 AUTOSAR Adaptive、ROS 2、Apollo 等，并围绕它们构建系统。\n   - 第四种方法是使用基于标准的关键技术中已证明的基础技术。上面提到的几种汽车平台都使用 Data Distribution Service™（DDS）标准作为其核心。\n1. 中间件——一种应用于分布式系统的基础软件，自上世纪 80 年代诞生以来，在分布式环境中低调地发挥着重要作用。基于中间件，系统软件与应用软件之间实现了高效连接与沟通，应用开发得以提速。\n1. 消息中间件和计算中间件\n\n## Basic\n\n1. RPC 和消息中间件区别？ [link](https://blog.csdn.net/u012562943/article/details/98586854)\n   - 主要的区别就是消息队列适用于异步场景，而 rpc 是远程同步调用 [[消息队列 RPC 之间的区别与联系](https://www.cnblogs.com/lizhensheng/p/11117407.html)]\n   - rpc 没有 broker, 而消息队列是需要管理消息的存储的，rpc 没有存储，只有通信。\n   - 不管是消息队列还是 rpc 调用都是 分布式下面的 通信方式。\n   - 消息队列最容易理解的方式就是生产者消费者模式，使两个应用解耦。mq 等框架就是对这的具体实现。\n   - MQ 是生产者消费者模式。\n   - RPC 是请求响应模式。\n   - MQ 是面向数据的。\n   - RPC 是面向动作的。\n1. Broker: 消息服务器，作为 server 提供消息核心服务\n1. Producer: 消息生产者，业务的发起方，负责生产消息传输给 broker，\n1. Consumer: 消息消费者，业务的处理方，负责从 broker 获取消息并进行业务逻辑处理\n1. Topic: 主题，发布订阅模式下的消息统一汇集地，不同生产者向 topic 发送消息，由 MQ 服务器分发到不同的订阅者，实现消息的广播\n1. Queue: 队列，PTP 模式下，特定生产者向特定 queue 发送消息，消费者订阅特定的 queue 完成指定消息的接收\n1. Message: 消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输\n\n## baidu cyber RT\n\n1. [Apollo6.0 学习 002：Cyber RT 框架](https://zhuanlan.zhihu.com/p/397607823)\n\n## ZeroMQ\n\n1. 号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常使用，偏重于实时数据通信场景。ZMQ 能够实现 RabbitMQ 不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。\n1. 无锁的队列模型：对于跨线程间的交互（用户端和 session）之间的数据交换通道 pipe，采用无锁的队列算法 CAS；在 pipe 的两端注册有异步事件，在读或者写消息到 pipe 的时，会自动触发读写事件。\n1. [无锁队列的实现](https://blog.csdn.net/armlinuxww/article/details/103988198)\n\n## Links\n\n1. [中间件](https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6)\n1. [中间件是什么,常用的中间件有哪些](https://blog.csdn.net/weixin_40210977/article/details/109729464)\n1. [消息队列](https://www.jianshu.com/p/79ca08116d57)\n1. [消息中间件（一）MQ 详解及四大 MQ 比较](https://www.cnblogs.com/insane-Mr-Li/p/10684536.html)\n"},{"title":"DDS","url":"/2022/09/05/DDS/","content":"\n## Basic\n\n### what\n\n1. [what-is-dds](https://www.dds-foundation.org/what-is-dds-3/)\n1. `DDS(Data Distribution Service,数据分发服务)` 是一种以数据为中心的通信协议，用于分布式软件应用程序通信。\n1. RTPS 是 Real-Time Publish Subscribe 的缩写\n1. [分布式实时通信——DDS 技术简洁](https://zhuanlan.zhihu.com/p/192981171)\n1. ![示意图](https://pic1.zhimg.com/80/v2-ff84b83ecac6b84f96d3631827080188_720w.jpg)\n1. [简介 2](https://www.zhihu.com/question/56652257)\n   ![DDS模型架构图](https://picx.zhimg.com/80/v2-daee8186bd378ce224b0f032a735f6c6_720w.jpg?source=1940ef5c)\n\n### why\n\n1. [why-choose-dds](https://www.dds-foundation.org/why-choose-dds/)\n1. [dds 与 some/ip 及 opendds 与 fastdds 区别](https://icode.best/i/86439147785337)\n1. dds, mq , rpc 区别：\n   - dds： 事件总线模式， mq: 代理模式？ [事件总线（发布订阅模式）](https://juejin.cn/post/6949929918138417165)\n   - dds 是（主要是）基于组播的“无中心”的端到端发布订阅，kafka 等主要是基于代理节点的发布订阅，二者在体系结构上差异明显\n   - 抽象程度不一样。DDS 的很多高级功能如果在 ZMQ 基础上增加成本很高。 ZMQ 更底层\n1. [why-would-anyone-use-dds-over-zeromq](https://www.rti.com/blog/2017/04/20/why-would-anyone-use-dds-over-zeromq)\n   - In DDS you just publish/subscribe to topic names. You never have to provide IP addresses, computer names or ports. It is all handled by the built-in discovery. And it does it automatically without additional services. This means that applications can be re-deployed and integrated without recompilation or reconfiguration.\n   - In comparison, ZeroMQ is lower level. You must specify ports, IP addresses, etc.\n1. [IIoT Solutions | 6 Industrial IoT Communication Solutions](https://www.rti.com/blog/industrial-iot-communication-solutions-which-ones-for-you-comparison)\n1. [比较图表](https://info.rti.com/hubfs/blog-files/iiot_comsol_pngaspdf.pdf)\n1. ![Architectural diagrams for the various IoT protocols.](https://marvel-b1-cdn.bc0a.com/f00000000264121/www.rti.com/hs-fs/hubfs/Assets%202017/communicationsevolution.jpg?width=720&height=405&name=communicationsevolution.jpg)\n\n### how\n\n1. [how-dds-works](https://www.dds-foundation.org/how-dds-works/)\n\n### others\n\n1. [FastDDS、OpenDDS、ConnextDDS 三者之间是能够实现通信的](https://blog.csdn.net/Tom942067059/article/details/113382934)\n\n## Fast-DDS\n\n1. DCPS(以数据为中心的发布订阅模型)\n\n### sample\n\n```sh\n% docker pull iceoryx/fastdds\n% docker run -id --name fastdds iceoryx/fastdds\n% docker exec -it fastdds bash\n% tmux new-session \"./HelloWorldExample publisher 0 1000\" \\; \\\nsplit-window \"./HelloWorldExample subscriber\" \\; \\\nselect-layout even-vertical\n\n```\n\n## Links\n\n1. [通信中间件 Fast DDS 基础概念简述与通信示例](https://blog.csdn.net/briblue/article/details/124081170)\n"},{"title":"VSCode","url":"/2022/09/05/VSCode/","content":"\n## Links\n\n1. [Bito](https://marketplace.visualstudio.com/items?itemName=Bito.Bito)\n1. [codegpt.co](https://codegpt.co/)\n1. [ai 助手](https://marketplace.visualstudio.com/items?itemName=Blackboxapp.blackbox)\n1. [inlay-hints](https://ash12rai-weblearning.medium.com/visual-studio-code-vs-code-inlay-hints-32fee837e80)\n   - font 从 windows 下查找\n   - font: Lucida Calligraphy, Lucida Bright\n   - toggle: `alt+'`\n1. [从 VSCode 看大型 IDE 技术架构 j](https://zhuanlan.zhihu.com/p/96041706)\n1. [vscode proxy setting](https://device.harmonyos.com/cn/docs/documentation/guide/vscode_proxy-0000001074231144)\n\n## [sync config](https://code.visualstudio.com/docs/editor/settings-sync)\n\n1. 不好用\n\n## task\n\n1. `Task: configure task` 设置 task 选择 other task\n1. `Task: run task`\n\n## cmake\n\n1. `M-x C/C++ Edit configurations(JSON)` 打开工程配置 c_cpp_properties.json\n1. [c_cpp_properties.json reference](https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference)\n1. \"compileCommands\": \"/path/to/compile_commands.json\", 设置 compile_commands.json， 方便代码补全\n1. 关闭 cmake tools 自动 build 功能\n\n## format\n\n1. `M-S-f`\n1. 自动 format `C-,` 打开设置，搜索 format, 选中 format on save\n1. `File: Save withourt Formatting` 命令\n\n## base\n\n1. debug console 中可以输入命令：`-exec info registers`\n1. 鼠标左键是 expand select\n1. `ctrl+g`多用\n1. `dev contatiner show all logs`\n1. `Open Log File` 可以看各种 log, window 可以看经常断开原因\n1. `output`窗口可以选择看各种 log\n1. `\"stopAtEntry\": false` c++ 调试默认会有个断点，但不会开启（launch.json)\n1. `Debug Visualizer`可以可视化常用数据结构，便于调试\n1. debug 可以使用 `Hex Editor` 查看内存, 点击\n1. `remote-containers.openDevContainerFile` 打开配置设置 `\"remoteUser\": \"xiyang\"` docker 可以使用 xiyang 用户登录, 每个 container 有一个配置\n1. dev-container 可以访问远程机器上的 docker，不用开端口\n1. windows 配置路径在当前用户.vscode 下面 例如:C:\\Users\\86158\\.vscode (extensions) 注意和 C:\\Users\\86158\\AppData\\Roaming\\Code\\User(settings) 数据做区分\n1. `toggleDevTools` 用来调试插件\n1. 注意配置文件区分:\n   - host: `keybindings.json settings.json`\n   - target: `.vscode-server/data/User/extensions.json`\n   - target project: `launch.json settings.json task.json c_cpp_properties.json`\n1. 右侧放 baseline， 代码导航下面\n1. `alt`有时候会误触，按 esc 或 alt\n1. 使用 vim 插件，使用 vim 快捷键 如： `*` 把当前的字段作为查找内容，找下一处。可以配合 `n` or `N`使用\n1. zen mode 模式下一遍写代码， 一边画图， `M-l or M-h`切换\n1. [zen mode 显示 tabs](https://stackoverflow.com/a/49196147) 可以设置 zen mode 显示\n\n## [short keys](https://code.visualstudio.com/docs/getstarted/keybindings)\n\n1. [basic editing](https://code.visualstudio.com/docs/editor/codebasics)\n1. [cheetsheat](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)\n1. [open-symbol-by-name](https://code.visualstudio.com/docs/editor/editingevolved#_open-symbol-by-name)\n1. `Navigate Edits History - Goto Last Edit`安装插件， 设置 loop true, `move to previous edit` -> `, g g`\n1. `Terminal: run recent command` 执行最近 command 的命令 或者安装插件`Rerun last command in termnalxs`\n1. `Terminal: go to recent directory` 进入最近使用的文件夹\n1. `S-M downarrow` vim 模式下对列操作\n1. `C-space` 补全的时候能显示更多信息，如 c++能显示文件路径, 也可以直接按\n1. `Developer: Toggle Screencast Mode` 对应 emacs `C-h k` 显示键对应的命令\n1. `view: toggle menu bar / status bar / activate bar / breadcrumbs`\n1. `Terminal: focuse find` C-f 快捷键删除，想用的时候使用命令\n1. 罗技鼠标 master 可以前进后退\n1. 多用命令\n1. File > Preferences > Keyboard Shortcuts 查看所有快捷键\n1. 可以点击测试 key 绑定到什么命令上\n1. 可以复制键设置到配置文件，然后修改键绑定\n1. `alt`给禁止了 设置为 emacs key [link](https://stackoverflow.com/a/65163917)\n1. `C-p ?`查看简写帮助 like emacs `C-h h`\n1. `C-k z` zen mode 非常好用\n1. `C-1` 聚焦到 editor\n1. `C-S o` + `C n/p` goto symbol in editor 可用于跳转函数, 很好用\n1. `Ctrl+T` goto symbol in workspace\n1. `Rename symbol`\n1. `C-,` 打开设置\n1. `M-x open settings (json)` 打开配置文件\n1. `C-b` toggle left side bar\n1. `C-j` toggle down side bar\n1. C-\\` toggle termianl\n1. C-S-\\` new terminal\n1. `C-w` 关闭 tab\n1. `C-+` 扩大字体 `view room in`\n1. `C--` 减小字体 `view room out`\n1. `M-x editor font size in` 只放大 editor size(emacs buffer)\n1. `F12` goto-defination 改为 `M-.`\n1. `M-leftarrow` go-back 改为 `M-,`\n1. vim `C-o and C-i` 前后跳转\n1. `C-pagedown` next tab/terminal 改为 `M-l`\n1. `C-pageup` previous tab/terminal 改为 `M-h`\n1. `M-1` first tab\n1. `C-p` find file 删除`C-e`\n1. `C-S-p` 命令搜索\n1. Esc 取消\n1. F8 next error\n1. `C-S-y` debug console window\n1. `C-S-u` output window\n1. `C-S-m` problems window\n1. `Focus on opened editors` 设置到 `M-b`, 配合`C-S-e`使用\n1. `show all editors by appearance by recent use` 设置到 `M-b`, emacs `,bb`\n1. `View: Focus Next Editor Group` -> `alt+o`\n1. `View: duplicate edior right` -> `alt-3`\n1. `View: duplicate edior down` -> `alt-2`\n1. `go to next change` git 修改 next\n1. `C-S-t` reopen closed editor\n1. `M-p toggle editor v/h layerout` 改变横向纵向分割\n1. `reload window`\n1. `设置alt-n导航` [link](https://stackoverflow.com/a/58082645)\n1. [emacs 快捷键设置](https://gist.github.com/cschleiden/4dbc22a5711f069199a0cc730ac42cb5)\n1. [快速切换 window](https://stackoverflow.com/a/54403042)\n1. `M-S-c` copy file path\n1. `Alt + Click`：添加新的光标, 多行操作\n1. `Alt + Shift + Click`：多行操作\n1. `M-S p` project manager: list project to open 配合 `C-M q` quick swich windwos\n\n## 免密\n\n1. 公钥放到服务器配置文件中\n1. `IdentityFile \"C:\\Users\\xxx/xxx\\id_rsa\"` config 配置里添加私钥位置\n1. `chmod 400 ~/.ssh/id_rsa` Permissions are too open\n1. wsl 里权限有问题，可以把 id_rsa 拷贝出来，换个指定位置。\n1. 将本地`~/.ssh/id_rsa.pub`复制到`~/.ssh/authorized_keys`中\n\n## plugins\n\n1. [JSON Crack json 可视化](https://marketplace.visualstudio.com/items?itemName=AykutSarac.jsoncrack-vscode)\n1. jupyter 不用安装图形界面就能显示\n   - [教程](https://code.visualstudio.com/docs/datascience/jupyter-notebooks)\n   - C-Enter 运行 code\n   - C-M-S-Enter 进入 cell debug 模式\n1. [toggle 设置](https://marketplace.visualstudio.com/items?itemName=rebornix.toggle)\n1. [dabbrev-expand](https://marketplace.visualstudio.com/items?itemName=kiwanamie.dabbrev-expand) alt+/\n1. [format-toggle](https://marketplace.visualstudio.com/items?itemName=tombonnike.vscode-status-bar-format-toggle) status bar 右下角有 status, 可以点击切换状态\n1. [toogle shortcut settings](https://marketplace.visualstudio.com/items?itemName=hoovercj.vscode-settings-cycler)\n1. [line-num-toggle](https://marketplace.visualstudio.com/items?itemName=jfacoustic.line-num-toggle)\n1. [doxdocgen](https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen)\n1. [Bookmarks](https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks)\n1. [python-extension-pack](https://marketplace.visualstudio.com/items?itemName=donjayamanne.python-extension-pack)\n1. [vscode-pylance lsp server 好用， 智能助手](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance)\n1. vscode 里选 most popular\n1. Laravel goto view ctrl 点击跳转, 配合 mater3 鼠标后退键，很高效\n1. [marketplace](https://marketplace.visualstudio.com/vscode)\n1. [StatusBar Debugger](https://marketplace.visualstudio.com/items?itemName=fabiospampinato.vscode-statusbar-debugger)\n   - 关闭 floating debug toolbar: setting: debug -> tool bar location -> hiden\n1. magit\n1. sourcegraph\n1. shell-format\n1. Prettier format\n1. cmake format\n1. [hungry-delete](https://marketplace.visualstudio.com/items?itemName=jasonlhy.hungry-delete)\n1. [vscode-debug-visualizer](https://github.com/hediet/vscode-debug-visualizer)\n1. project manager (status bar 有图标， 可用于切换)\n1. gitlens\n   - 关闭自动显示配置\n   - 编辑右上角有 toggle changes/blame/heatmaps 图标\n   - 设置 git diff tool [link](https://code.visualstudio.com/docs/sourcecontrol/overview#_vs-code-as-git-difftool-and-mergetool)\n   - `C-w`关闭 diff\n   - `open remote` 可以打开远程 commit branch file\n   - status bar 可以选择 zen or review mode， review mode 能显示多种信息\n1. vscode-icons\n1. [Duplicate selection or line](https://marketplace.visualstudio.com/items?itemName=geeebe.duplicate)\n1. [duplicate file](https://marketplace.visualstudio.com/items?itemName=mrmlnc.vscode-duplicate)\n1. [vscode-filesize](https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize)\n1. wsl\n1. json\n1. code runner\n1. Material Icon Theme\n1. remote ssh\n1. C/C++ Extension Pack\n1. Better C++ Syntax\n1. C/C++ Compile Run\n1. Path Intellisense\n1. Remote Development\n1. Rainbow Brackets\n1. [colorize](https://marketplace.visualstudio.com/items?itemName=kamikillerto.vscode-colorize) 显示值颜色\n1. [highlight-words](https://marketplace.visualstudio.com/items?itemName=rsbondi.highlight-words)\n1. todo highlight\n1. [highlight](https://github.com/debugpig/vscode-extension-highlight) 选择高亮字符, 配合 vim `*` `#` 使用\n1. [vscode-highlight](https://github.com/fabiospampinato/vscode-highlight) 直接高亮字符\n1. Svg Preview\n1. better comment\n1. next console\n1. gdb-syntax\n1. excel view 查看 csv 文件\n1. doxygen document 生成 doxygen 注释\n1. Manpages\n1. [dimmer](https://marketplace.visualstudio.com/items?itemName=imagio.vscode-dimmer-block)\n1. [back 图标](https://marketplace.visualstudio.com/items?itemName=nick-rudenko.back-n-forth)\n1. [path-intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense)\n1. [stats-bar: show cpu and mem usage](https://marketplace.visualstudio.com/items?itemName=njzy.stats-bar)\n1. [vscode-fileutils](https://marketplace.visualstudio.com/items?itemName=sleistner.vscode-fileutils)\n1. [vscode 中打开网页，用于调试 server](https://marketplace.visualstudio.com/items?itemName=antfu.browse-lite)\n1. [rainbow-csv](https://marketplace.visualstudio.com/items?itemName=mechatroner.rainbow-csv)\n1. [excelviewer](https://marketplace.visualstudio.com/items?itemName=GrapeCity.gc-excelviewer)\n1. [csv-to-table](https://marketplace.visualstudio.com/items?itemName=phplasma.csv-to-table)\n\n## [vim](https://github.com/VSCodeVim/Vim)\n\n1. [设置 learder key](https://cnodejs.org/topic/5b9e696037a6965f59051a09)\n1. `toggleDevTools` 用来调试插件 vim loglevel 设置为 debug\n1. 打开 easymotion\n1. 修复 fold [link](https://stackoverflow.com/a/50892839)\n1. 可以设置 search color\n\n## theme\n\n1. [vscode-theme-onedark](https://marketplace.visualstudio.com/items?itemName=akamud.vscode-theme-onedark)\n2. pe\n\n## todo\n\n1. fold and unfold tab to toggle fold\n1. show command using key\n1. 对比 emacs 看有哪些好用的功能\n\n## issues\n\n1. [关闭 vscode 烦人的提示框](https://codeantenna.com/a/ZOXgWzApJO)\n\n## python\n\n1. set python3 path: Python: Select Interpreter\n"},{"title":"Jenkins","url":"/2022/08/19/Jenkins/","content":"\n## Jenkins\n\n1. [Doc](https://www.jenkins.io/doc/)\n1.\n\n## install\n\n```sh\n% wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -\n% sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'\n% sudo apt-get update\n% sudo apt-get install jenkins\n% sudo vi /etc/default/jenkins ## change port\n% sudo /etc/init.d/jenkins start\n## http://localhost:port\n```\n\n## Plugins\n\n1. [插件下载量排名](https://plugins.jenkins.io/ui/search?sort=installed&categories=&labels=&view=List&page=1&query=)\n1. 在 Jenkins 界面，系统管理->管理插件->安装 SSH Plugin [ssh](https://plugins.jenkins.io/ssh/) [link](https://fanlychie.github.io/post/jenkins-remote-ssh.html)\n1. [gitlab-plugin](https://plugins.jenkins.io/gitlab-plugin/)\n1. [git parameter](https://plugins.jenkins.io/git-parameter/)\n1. [build timeout](https://plugins.jenkins.io/build-timeout/)\n1. [jobConfigHistory](https://plugins.jenkins.io/jobConfigHistory/)\n1. [rebuild](https://plugins.jenkins.io/rebuild/)\n1. [material-theme](https://plugins.jenkins.io/material-theme/) Indigo is good\n1. [ansicolor](https://plugins.jenkins.io/ansicolor/)\n1. [display-console-output](https://plugins.jenkins.io/display-console-output/)\n\n## basic\n\n1. [jenkins 状态反馈给 gitlab](https://www.cnblogs.com/mingerlcm/p/12728873.html)\n1. [gitlab hook](https://cloud.tencent.com/developer/article/1599050)\n   - 使用 webhook, webhook 与异步编程中\"订阅-发布模型\"非常类似，一端触发事件，一端监听执行。\n     ![数据更新后通过 webhook主动推送](https://segmentfault.com/img/remote/1460000020249992?w=1000&h=690)\n1. 匿名用户查看权限 Manager Jenkins ---> Configure Global Security ---> 授权策略\n1. 修改记录里有 git commit 历史\n1. 可以看工作空间\n1. log rotation Job Configuration -->Discard Old Builds:(丢弃旧的构建), job 描述正下方\n1. Add timestamps to the Console Output\n1. 归档时记录所有归档成品的指纹\n1. 工作区 job 目录下的 config.xml 文件比较重要，可以 git 管理起来，能恢复配置\n1. 下载.war 包 https://jenkins.io/download/\n1. 使用命令： java -jar jenkins.war\n1. 参考文档： https://jenkins.io/doc/book/\n1. 远程部署：安装插件 [Publish Over FTP Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Publish+Over+FTP+Plugin) publish over ssh FTP 用于传文件 SSH 用于在远程机器上执行命令\n1. 定时构建： https://www.cnblogs.com/caoj/p/7815820.html\n1. 存档： https://blog.csdn.net/liqiangeastsun/article/details/79062806 文件位置 : ./jobs/test/builds/57/archive ， deephi\\*\n1. 文件命名：日期 + git 号 。gitnum=`git log --pretty=oneline -1 | cut -b 1-8` date*temp=`date +%m%d` mv app.c app*${date_temp}_${gitnum}.c\n1. 文件 md5 值： http://ju.outofmemory.cn/entry/117335\n1. 邮箱：管理员地址 https://blog.csdn.net/songjiaping/article/details/51496977 126 开启 smtp https://www.cnblogs.com/yangxia-test/p/4366172.html https://www.jianshu.com/p/2afb099f2a79 http://skyfar666.iteye.com/blog/1973434\n1. 本地文件管理，源码管理不用 git 仓库，选择 none。就能在其他目录下工作，可以把要保留的文件传回到工作区，保存。\n1. 如何获取远程机器的 log?\n1. Timestamper 控制台输出显示\n1. Workspace Cleanup Plugin\n1. blue ocean 插件\n1. 增加项目描述 https://www.cnblogs.com/chongyou/p/7365351.html\n1. 配置变更记录 https://blog.csdn.net/j3T9Z7H/article/details/78422565\n1. 配置\n\n## Note\n\n1. jenkins ssh 登录找不到 cmake, 因为 jenkins 会从/usr/bin 下找，和登录环境不一样。解决办法：修改客户端 ssh 配置，允许 PermitUserEnvironment [link](https://docs.cloudbees.com/docs/cloudbees-ci-kb/latest/client-and-managed-masters/how-to-set-up-a-jenkins-agent-to-have-the-same-path-as-the-user-when-connected-via-remote-desktop)\n"},{"title":"OpenCV","url":"/2022/08/18/OpenCV/","content":"\n## doc\n\n1. 注意 doc 中函数说明下面有 examples\n1. [Mat](https://docs.opencv.org/4.6.0/d3/d63/classcv_1_1Mat.html)\n\n## Note\n\n1. debug opencv:`OPENCV_LOG_LEVEL=DEBUG`\n1. nv12 type 是 `CV_8UC1， h = real_h * 3 / 2`\n1. opencv 不支持 nv12 resize， 需要 `to rgb -> resize -> to nv12` 或 [libyuv](https://github.com/lemenkov/libyuv) 来 resize\n\n## [Mat](https://docs.opencv.org/4.6.0/d3/d63/classcv_1_1Mat.html)\n\n1. `mata.mul(matb)` 矩阵相乘\n1. `cv::Mat Z_c2 = Z_w * std::cos(phi) + hc * std::sin(phi);` Z_w 为 Mat，直接做运算\n1. [fossies 依赖关系](https://fossies.org/dox/opencv-4.6.0/classcv_1_1Mat.html) 点图右上角能展开图片\n1. (代理模式？) opencv 接口使用代理类 _InputArray，This is the proxy class for passing read-only input arrays into OpenCV functions. \\_InputArray is a class that can be constructed from Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat\\_<T> >, UMat, std::vector<UMat> or double. It can also be constructed from a matrix expression.\n1. [\\_InputArray](https://fossies.org/dox/opencv-4.6.0/classcv_1_1__InputArray.html)\n1. cv::resize 等接口用的都是(InputArray..) `cv::resize (InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR)`\n\n### 属性\n\n1. [Opencv Mat 矩阵中 data、size、depth、elemSize、step 等属性的理解](https://blog.csdn.net/dcrmg/article/details/52294259)\n1. `flags`\n1. `dims` Mat 矩阵的维度，若 Mat 是一个二维矩阵，则 dims=2，三维则 dims=3\n1. `rows` Mat 矩阵的行数。\n1. `cols` Mat 矩阵的列数。\n1. `data` uchar 类型的指针，指向 Mat 数据矩阵的首地址。\n1. `size` 首先 size 是一个结构体，定义了 Mat 矩阵内数据的分布形式，数值上有关系式：image.size().width==image.cols; image.size().height==image.rows\n1. `step` 可以理解为 Mat 矩阵中每一行的“步长”，以字节为基本单位，每一行中所有元素的字节总量，是累计了一行中所有元素、所有通道、所有通道的 elemSize1 之后的值；\n1. `channels()`：Mat 矩阵元素拥有的通道数。例如常见的 RGB 彩色图像，channels==3；而灰度图像只有一个灰度分量信息 channels==1。\n1. `type()` Mat 矩阵的类型\n1. `depth()` 用来度量每一个像素中每一个通道的精度，但它本身与图像的通道数无关！depth 数值越大，精度越高。Opencv 中，Mat.depth()得到的是一个 0~6 的数字，分别代表不同的位数，对应关系如下：enum{CV_8U=0,CV_8S=1,CV_16U=2,CV_16S=3,CV_32S=4,CV_32F=5,CV_64F=6}\n1. `elemSize()` elem 是 element(元素)的缩写，表示矩阵中每一个元素的数据大小，如果 Mat 中的数据类型是 CV_8UC1，那么 elemSize==1；如果是 CV_8UC3 或 CV_8SC3，那么 elemSize==3；如果是 CV_16UC3 或者 CV_16SC3，那么 elemSize==6；即 elemSize 是以 8 位（一个字节）为一个单位，乘以通道数和 8 位的整数倍；\n1. `total()`: the total number of array elements. `mat data size: total() * elemSize()`\n\n## functions\n\n### 构造\n\n1. Mat array = (Mat\\_<double>(3, 3) << 0, -1, 5, -1, 5, -1, 0, -1, 0);\n\n### imread\n\n1. `Mat cv::imread(const String &filename, int flags = IMREAD_COLOR);`\n1. [flags list](https://fossies.org/dox/opencv-4.6.0/group__imgcodecs__flags.html#ga61d9b0126a3e57d9277ac48327799c80)\n1. IMREAD_COLOR(value is 1): If set, always convert image to the 3 channel BGR color image.\n1. IMREAD_GRAYSCALE(vaule is 0): If set, always convert image to the single channel grayscale image (codec internal conversion).\n\n### imwrite\n\n1. `bool cv::imwrite (const String& filename, InputArray img, const std::vector<int> & params = std::vector<int>())`\n1. `params` Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see [cv::ImwriteFlags](https://fossies.org/dox/opencv-4.6.0/group__imgcodecs__flags.html#ga292d81be8d76901bff7988d18d2b42ac)\n\n### resize\n\n1. 不支持 nv12 resize [libyuv](https://github.com/lemenkov/libyuv)来做 yuv resize\n\n### crop\n\n1. 使用 cv::Rect (x, y, w, h)\n\n```c++\ncv::Rect crop_region(250, 10,400, 400);\nauto mat2=mat1(crop_region);\n```\n\n1. [libyuv crop](https://github.com/lemenkov/libyuv/blob/6900494d90ae095d44405cd4cc3f346971fa69c9/include/libyuv/convert.h#L900)\n\n### cvtColor\n\n1. [列表](https://docs.opencv.org/4.6.0/d8/d01/group__imgproc__color__conversions.html)\n1. `cv::cvtColor(src, dst, cv::COLOR_YUV2BGR_YVYU)`\n1. `cv::cvtColor(src, dst, cv::COLOR_BGR2GRAY)`\n1. `cv::cvtColor(src, dst, cv::COLOR_GRAY2BGR)`\n1. `cv::cvtColor(origin_image, image_rgb, cv::COLOR_YUV2RGB_NV12);`\n1. 不支持 yuv 转 rbg, 可以参考[代码](https://github.com/mhomola/AutonomousFlight/blob/422de6ccbbd3ec290a16c8d919fd23d4503ad62f/CV_scripts/opencv-4.x/modules/gapi/test/streaming/gapi_streaming_tests.cpp#L208-L208)\n\n### permute / transpose 通道转换\n\n1. [transposeND](https://docs.opencv.org/4.x/d2/de8/group__core__array.html#gab1b1274b4a563be34cdfa55b8919a4ec)： Transpose for n-dimensional matrices.\n\n### cv::FileStorage 序列化与反序列化\n\n1. `cv2.FileStorage(\"output.yml\", cv2.FILE_STORAGE_WRITE).write(\"mat\", mat)`\n1. test\n\n```c++\n    cv::FileStorage file(\"test.yml\", cv::FileStorage::READ);\n    cv::Mat left_image, right_image;\n    int out_hei, out_wid;\n    cv::Mat Q;\n    float phi, hc, traj_center, traj_wid, traj_near, traj_far;\n    bool affine;\n\n    file[\"left_image\"] >> left_image;\n    file[\"right_image\"] >> right_image;\n    out_hei = (int)file[\"out_hei\"];\n    out_wid = (int)file[\"out_wid\"];\n    file[\"Q\"] >> Q;\n    phi = (float)file[\"phi\"];\n    hc = (float)file[\"hc\"];\n    int int_affine = (int)file[\"affine\"];\n    affine = int_affine == 0 ? false : true;\n```\n\n## links\n\n1. [Mat 常见属性](https://blog.51cto.com/SpaceVision/5071910)\n"},{"title":"Vim","url":"/2022/08/13/Vim/","content":"\n## keybind [link](https://blog.csdn.net/RunBoying/article/details/7695164)\n\n1. [] 调上一个 func\n1. `:e filename` 打开 file\n1. `za` fold and unfold\n1. `zM` fold all\n1. `zO` unfold all\n1. `C-^` 切换 buffer\n1. `c-d` 向下滚屏, 左手单手操作\n1. `c-u` 向上滚屏\n1. `ZZ`: 普通模式下保存并退出\n1. `:e!` 可以不保存文件并重新载入这个文件\n1. `*` 把当前的字段作为查找内容，找下一处。可以配合 `n` or `N`使用\n1. `%` 跳转到相配对的括号\n1. `v %` 选中括号里内容\n1. `^` 跳转至行第一个非空字符\n1. `:set hlsearch` 可以将查找的内容设置成高亮。`:set nohlsearc` 取消高亮或 `/xxxx`\n1. `mm` and \\`m : mark and jump back\n1. `C-o` 命令则跳到一个 \"较老\" 的地方 (提示： O 表示 older)。`C-i` 则跳到一个 \"较新\" 的地方.\n1. `f` 向后搜索, `F` 向前搜索, `;` next\n1. H:将光标移动到当前可见页面的顶部（High）\n1. M:将光标移到当前可见页面的中间（Middle）\n1. L:将光标移动到当前可见页面的底部（Low）\n1. `:buffers` or `:ls` 列出可用的缓冲区\n1. `:bn` 下一个缓冲区。类似地，我们可以通过键入 b 数字或名称（在上面的第一列）或名称来切换到缓冲区。\n1. `:bd` 删除当前 buffer\n1. `p and S-p` 当前字符前后复制\n1. `I` go to start line and insert\n1. `A` go to end line and insert\n\n## [easymotion](https://github.com/easymotion/vim-easymotion)\n\n1. Set a custom color for the easymotion search n-character (default <leader><leader>/).\n1. `<leader><leader>f` char\n\n1. like emacs avy-jump\n\n## Plugins\n\n1. [native package](https://shapeshed.com/vim-packages/)\n\n### [vim-slime](https://github.com/jpalardy/vim-slime)\n\n1. install\n\n```sh\nmkdir -p ~/.vim/pack/plugins/start\ncd ~/.vim/pack/plugins/start\ngit clone https://github.com/jpalardy/vim-slime.git\n```\n\n1. vimrc config\n\n```sh\nlet g:slime_target = \"tmux\"\nnmap <c-c><c-l> <Plug>SlimeLineSend\nnmap <c-a> <Plug>SlimeLineSend\n```\n\n1. [try in docker](https://blog.jpalardy.com/posts/trying-vim-slime-in-docker/)\n"},{"title":"系统架构师","url":"/2022/07/30/系统架构师/","content":"\n## Links\n\n1. [网上报名平台](https://bm.ruankao.org.cn/sign/welcome)\n1. [资料](https://github.com/gitlfc163/SystemArchitect)\n1. [高质量、最全面的 2022 年系统架构设计师（软考高级）备考资源库](https://github.com/xxlllq/system_architect)\n1. [中国计算机技术职业资格网](https://www.ruankao.org.cn/)\n1. [报考指南](https://www.ruankao.org.cn/platform)\n1. [考试安排](https://www.ruankao.org.cn/arrange)\n1. [知乎分析](https://www.zhihu.com/question/264585896)\n"},{"title":"software-features","url":"/2022/07/27/software-features/","content":"\n## 软件质量\n\n1. [各种标准介绍](https://bbs.huaweicloud.com/blogs/261499)\n1. [ISO/IEC 25010](https://iso25000.com/index.php/en/iso-25000-standards/iso-25010)\n   ![ISO/IEC 25010](https://iso25000.com/images/figures/en/iso25010.png)\n\n<!-- more -->\n\n1. [ISO/IEC 5055](https://www.encora.com/insights/software-quality-standards-iso-5055-overview)\n   - [视频](https://www.youtube.com/watch?v=J8Wz0m1mkn4)\n1. ISO 5055 is intended to supplement the levels of measurement in the ISO/IEC 25000 series. Also known as SQaRE, the ISO 25000 series uses a set of eight software quality characteristics, including our four from earlier, to measure a software’s quality at a behavioral level. This is different from ISO 5055, which is looking at software at a code level. ISO/IEC 25000 and ISO 5055 are designed to complement each other.\n   ![软件质量](http://www.itcast.cn/files/image/202010/20201009143141577.jpg)\n\n1. ISO/IEC 9126:1901 标准所包含的 6 大特性的具体含义如下。\n   - `功能性`:在指定条件下,软件满足用户显式需求和隐式需求的能力。\n   - `可靠性`:在指定条件下使用时,软件产品维持规定的性能级别的能力。\n   - `可使用性`:在指定条件下,软件产品被使用、理解、学习的能力。\n   - `效率`:在指定条件下,相对于所有资源的数量,软件产品可提供适当性能的能力。\n   - `可维护性`:指软件产品被修改的能力。修改包括修正、优化和功能规格变更的说明。\n   - `可移植性`:指软件产品从一个环境迁移到另一个环境的能力。\n\n## 优点\n\n1. Functionality\n1. Usability (User-friendly) 易用性\n1. Efficiency 高效\n1. Flexibility\n1. Reliability 可靠性\n1. Maintainability\n1. Portability\n1. Integrity\n1. 可复用性\n1. 可用性\n1. 兼容性\n1. 可扩展性\n1. 可移植性\n1. 安全性\n\n## 缺点\n\n## 指标\n\n1. 延迟\n1. 吞吐\n1. 利用率\n"},{"title":"CPM","url":"/2022/07/16/CPM/","content":"\n## basic\n\n1. CPMAddPackage 是 CMake 的一个模块，它是 CPM.cmake 的一部分，用于管理项目依赖项。当你使用 CPMAddPackage 下载 .tgz 或 .tar.gz 归档文件时，该模块会自动解压归档文件,会去除一层\n1. [samples](https://github.com/cpm-cmake/CPM.cmake/wiki/More-Snippets#sol2)\n1. 导入外部库 `INTERFACE IMPORTED` [link](https://hsf-training.github.io/hsf-training-cmake-webpage/04-targets/index.html)\n1. 全局导入外部库 `INTERFACE IMPORTED GLOBAL`， 解决 cpm local scope include_directories 不工作问题\n1. ? add_definitions()传递， 后引入的库在作用域更小， 先引入的库作用域大，与顺序有关\n1. download\n\n```cmake\nset(CPM_DOWNLOAD_VERSION 0.27.2)\nset(CPM_DOWNLOAD_LOCATION \"${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake\")\n\nif(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))\n    message(STATUS \"Downloading CPM.cmake\")\n    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})\nendif()\n\ninclude(${CPM_DOWNLOAD_LOCATION})\n```\n\n1. cpm url lib export， [cmake 导入外部链接库](https://github.com/cpm-cmake/CPM.cmake/wiki/More-Snippets#sol2)\n\n```cmake\ncpmaddpackage(\n  NAME\n  gflags\n  URL\n  https://mirrors.xxxxxx/nfs/pkgs/gflags_2.2.2/$gflags_2.2.2.tar\n)\n\n# if(gflags_ADDED AND NOT TARGET gflags)\n## 错误\nif(gflags_ADDED)\n  add_library(gflags INTERFACE)\n  target_include_directories(gflags INTERFACE \"${gflags_SOURCE_DIR}/include\")\n  target_link_directories(gflags INTERFACE \"${gflags_SOURCE_DIR}/lib\")\nendif()\n\n## 正确(官网的例子没有set properties，是因为会编译出.so，不用指定so位置)\nif(gflags_ADDED)\n  message(STATUS \"gflags test2**********************\")\n  add_library(gflags INTERFACE IMPORTED GLOBAL) ## global导入， 解决cpm local scope include_directories不工作问题\n  add_library(gflags::gflags ALIAS gflags)\n  set_target_properties(\n    gflags PROPERTIES IMPORTED_LOCATION \"${gflags_SOURCE_DIR}/lib/libgflags.so\")\n  target_include_directories(gflags INTERFACE \"${gflags_SOURCE_DIR}/include\")\n  # target_link_directories(gflags INTERFACE \"${gflags_SOURCE_DIR}/lib\")\nendif()\n\n\n```\n\n1. 多个库 if(xxx_ADDED)只有一个库会调用，可以在 if 里面打印消息测试。不用`if(gflags_ADDED AND NOT TARGET gflags)`\n1. 注意区分`add_library(gflags SHARED IMPORTED GLOBAL)`和`libgflags.so`的区别，前者是 target, 后者是 so。为了区分两者， 可以使用`add_library(gflags SHARED IMPORTED GLOBAL) add_library(gflags::gflags ALIAS gflags)` target::target 来区分。\n\n1. [如果依赖的库有冲突， CPM 会有 WARNING](https://github.com/cpm-cmake/CPM.cmake/issues/175)\n\n```cmake\nCMake Warning at cmake/CPM.cmake:269 (message):\n  CPM: cpm-test2: requires a newer version of cpm-test1 (0.0.4) than\n  currently included ().\n```\n\n1. [解决库冲突方法](https://github.com/cpm-cmake/CPM.cmake#limitations)\n\n- 最外层添加依赖（因为 first version used)\n- lock file\n\n1. cpm funtion\n\n```cmake\nfunction(pg_add_lib name)\n  set(options \"\")\n  set(oneValueArgs PACK)\n  set(multiValueArgs INCLUDE_DIRS LIB_DIRS)\n  cmake_parse_arguments(ARG \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\"\n                        ${ARGN})\n  if(ARG_PACK)\n    set(PACK_NAME ${ARG_PACK})\n  else()\n    set(PACK_NAME ${name}.tar)\n  endif()\n  cpmaddpackage(\n    NAME ${name} URL\n    https://xxxxxxx/nfs/pkgs/${name}/${ARCH_PLAT_VENDOR}/${PACK_NAME}\n  )\n  if(${name}_ADDED)\n    if(ARG_INCLUDE_DIRS)\n      message(STATUS, \"ARG_INCLUDE_DIRS=\\\"${ARG_INCLUDE_DIRS}\\\"\")\n      foreach(INCLUDE_DIR ${ARG_INCLUDE_DIRS})\n        message(STATUS, \"INCLUDE_DIR=\\\"${INCLUDE_DIR}\\\"\")\n        list(APPEND INCLUDE_DIRS ${${name}_SOURCE_DIR}/${INCLUDE_DIR})\n      endforeach()\n    else()\n      list(APPEND INCLUDE_DIRS ${${name}_SOURCE_DIR}/include)\n    endif()\n    message(STATUS, \"INCLUDE_DIRS=\\\"${INCLUDE_DIRS}\\\"\")\n\n    if(ARG_LIB_DIRS)\n      message(STATUS, \"ARG_LIB_DIRS=\\\"${ARG_LIB_DIRS}\\\"\")\n      foreach(LIB_DIR ${ARG_LIB_DIRS})\n        message(STATUS, \"LIB_DIR=\\\"${LIB_DIR}\\\"\")\n        list(APPEND LIB_DIRS ${${name}_SOURCE_DIR}/${LIB_DIR})\n      endforeach()\n    else()\n      list(APPEND LIB_DIRS ${${name}_SOURCE_DIR}/lib)\n    endif()\n    message(STATUS, \"LIB_DIRS=\\\"${LIB_DIRS}\\\"\")\n\n    foreach(LIB_DIR ${LIB_DIRS})\n      execute_process(\n        COMMAND ls\n        COMMAND sh -c \"awk '/.so\\$|.a\\$/{print \\$0}'\"\n        COMMAND sh -c \"awk -F '.' '{print substr($1,4)}'\"\n        # COMMAND sh -c \"sort\" COMMAND sh -c \"uniq\"\n        WORKING_DIRECTORY ${LIB_DIR}\n        OUTPUT_VARIABLE LIBS\n        OUTPUT_STRIP_TRAILING_WHITESPACE)\n      message(STATUS, \"LIBS=${LIBS}\")\n      string(REPLACE \"\\n\" \";\" LIBS \"${LIBS}\")\n      foreach(LIB ${LIBS})\n        message(STATUS, \"LIB=\\\"${LIB}\\\"\")\n        if(NOT TARGET ${LIB})\n          find_library(\n            ${LIB}_PATH\n            NAMES ${LIB}\n            PATHS \"${LIB_DIR}\"\n            NO_DEFAULT_PATH)\n          message(STATUS, \"LIB_PATH=\\\"${${LIB}_PATH}\\\"\")\n          add_library(${LIB} UNKNOWN IMPORTED GLOBAL)\n          add_library(${name}::${LIB} ALIAS ${LIB})\n          set_target_properties(${LIB} PROPERTIES IMPORTED_LOCATION\n                                                  \"${${LIB}_PATH}\")\n          target_include_directories(${LIB} INTERFACE ${INCLUDE_DIRS})\n        endif()\n      endforeach()\n    endforeach()\n  endif()\nendfunction(pg_add_lib)\n```\n\n1. 适应 windows, 去除 awk 依赖\n\n```cmake\nfunction(pg_add_third_party_lib name)\n  set(options \"\")\n  set(oneValueArgs PACK)\n  set(multiValueArgs INCLUDE_DIRS LIB_DIRS)\n  cmake_parse_arguments(ARG \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\"\n                        ${ARGN})\n  if(ARG_PACK)\n    set(PACK_NAME ${ARG_PACK})\n  else()\n    set(PACK_NAME ${name}.tar)\n  endif()\n  cpmaddpackage(\n    NAME ${name} URL\n    https://xxx/nfs/pkgs/${name}/${ARCH_PLAT_VENDOR}/${PACK_NAME}\n  )\n  if(${name}_ADDED)\n    if(ARG_INCLUDE_DIRS)\n      foreach(INCLUDE_DIR ${ARG_INCLUDE_DIRS})\n        if(EXISTS \"${${name}_SOURCE_DIR}/${INCLUDE_DIR}\")\n          list(APPEND INCLUDE_DIRS ${${name}_SOURCE_DIR}/${INCLUDE_DIR})\n        endif()\n      endforeach()\n    else()\n      list(APPEND INCLUDE_DIRS ${${name}_SOURCE_DIR}/include)\n    endif()\n\n    if(ARG_LIB_DIRS)\n      foreach(LIB_DIR ${ARG_LIB_DIRS})\n        list(APPEND LIB_DIRS ${${name}_SOURCE_DIR}/${LIB_DIR})\n      endforeach()\n    else()\n      list(APPEND LIB_DIRS ${${name}_SOURCE_DIR}/lib)\n    endif()\n\n    foreach(LIB_DIR ${LIB_DIRS})\n      # shared libs\n      execute_process(\n        COMMAND ls\n        # COMMAND sh -c \"awk '/.so\\$/{print \\$0}'\" COMMAND sh -c \"awk -F '.'\n        # '{print substr($1,4)}'\"\n        WORKING_DIRECTORY ${LIB_DIR}\n        OUTPUT_VARIABLE LIBS\n        OUTPUT_STRIP_TRAILING_WHITESPACE)\n      string(REPLACE \"\\n\" \";\" LIBS \"${LIBS}\")\n      foreach(LIB ${LIBS})\n        string(REGEX MATCH \"lib.*\\.so$\" LIB ${LIB})\n        if(LIB)\n          get_filename_component(LIB ${LIB} NAME_WE)\n          string(REPLACE \"lib\" \"\" LIB \"${LIB}\")\n          message(STATUS \".......lib=${LIB}\")\n          if(NOT TARGET ${LIB})\n            add_library(${LIB} SHARED IMPORTED GLOBAL)\n            add_library(${name}::${LIB} ALIAS ${LIB})\n            set_target_properties(${LIB} PROPERTIES IMPORTED_LOCATION\n                                                    \"${LIB_DIR}/lib${LIB}.so\")\n            target_include_directories(${LIB} INTERFACE ${INCLUDE_DIRS})\n          endif()\n        endif()\n      endforeach()\n\n      # static libs\n      execute_process(\n        COMMAND ls\n        # COMMAND sh -c \"awk '/.a\\$/{print \\$0}'\" COMMAND sh -c \"awk -F '.'\n        # '{print substr($1,4)}'\"\n        WORKING_DIRECTORY ${LIB_DIR}\n        OUTPUT_VARIABLE LIBS\n        OUTPUT_STRIP_TRAILING_WHITESPACE)\n      string(REPLACE \"\\n\" \";\" LIBS \"${LIBS}\")\n      foreach(LIB ${LIBS})\n        string(REGEX MATCH \"lib.*\\.so$\" LIB ${LIB})\n        if(LIB)\n          get_filename_component(LIB ${LIB} NAME_WE)\n          string(REPLACE \"lib\" \"\" LIB \"${LIB}\")\n          message(STATUS \".......lib=${LIB}\")\n          if(NOT TARGET ${LIB})\n            add_library(${LIB} STATIC IMPORTED GLOBAL)\n            add_library(${name}::${LIB} ALIAS ${LIB})\n            set_target_properties(${LIB} PROPERTIES IMPORTED_LOCATION\n                                                    \"${LIB_DIR}/lib${LIB}.a\")\n            target_include_directories(${LIB} INTERFACE ${INCLUDE_DIRS})\n          endif()\n        endif()\n      endforeach()\n    endforeach()\n  endif()\nendfunction(pg_add_third_party_lib)\n```\n\n1. final\n\n```cmake\ninclude(cmake/CPM.cmake)\nfunction(pg_add_third_party_lib name)\n  set(options \"\")\n  set(oneValueArgs PACK)\n  set(multiValueArgs INCLUDE_DIRS LIB_DIRS)\n  cmake_parse_arguments(ARG \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\"\n                        ${ARGN})\n  if(ARG_PACK)\n    set(PACK_NAME ${ARG_PACK})\n  else()\n    set(PACK_NAME ${name}.tar)\n  endif()\n  cpmaddpackage(\n    NAME ${name} URL\n    https://mirrors.phigent.io/nfs/pkgs/${name}/${ARCH_PLAT_VENDOR}/${PACK_NAME}\n  )\n  # if(${name}_ADDED)\n  if(ARG_INCLUDE_DIRS)\n    foreach(INCLUDE_DIR ${ARG_INCLUDE_DIRS})\n      if(EXISTS \"${${name}_SOURCE_DIR}/${INCLUDE_DIR}\")\n        list(APPEND INCLUDE_DIRS ${${name}_SOURCE_DIR}/${INCLUDE_DIR})\n      endif()\n    endforeach()\n  else()\n    list(APPEND INCLUDE_DIRS ${${name}_SOURCE_DIR}/include)\n  endif()\n\n  if(ARG_LIB_DIRS)\n    foreach(LIB_DIR ${ARG_LIB_DIRS})\n      list(APPEND LIB_DIRS ${${name}_SOURCE_DIR}/${LIB_DIR})\n    endforeach()\n  else()\n    list(APPEND LIB_DIRS ${${name}_SOURCE_DIR}/lib)\n  endif()\n\n  foreach(LIB_DIR ${LIB_DIRS})\n    # shared libs\n    execute_process(\n      COMMAND ls\n      WORKING_DIRECTORY ${LIB_DIR}\n      OUTPUT_VARIABLE LIBS\n      OUTPUT_STRIP_TRAILING_WHITESPACE)\n    string(REPLACE \"\\n\" \";\" LIBS \"${LIBS}\")\n    foreach(LIB ${LIBS})\n      string(REGEX MATCH \"lib.*\\.so$\" LIB ${LIB})\n      if(LIB)\n        string(LENGTH ${LIB} STR_LEN)\n        math(EXPR STR_LEN \"${STR_LEN} - 6\")\n        string(SUBSTRING ${LIB} 3 ${STR_LEN} LIB)\n        if(NOT TARGET ${LIB})\n          add_library(${LIB} SHARED IMPORTED GLOBAL)\n          add_library(${name}::${LIB} ALIAS ${LIB})\n          set_target_properties(${LIB} PROPERTIES IMPORTED_LOCATION\n                                                  \"${LIB_DIR}/lib${LIB}.so\")\n          target_include_directories(${LIB} INTERFACE ${INCLUDE_DIRS})\n        endif()\n      endif()\n    endforeach()\n\n    # static libs\n    execute_process(\n      COMMAND ls\n      WORKING_DIRECTORY ${LIB_DIR}\n      OUTPUT_VARIABLE LIBS\n      OUTPUT_STRIP_TRAILING_WHITESPACE)\n    string(REPLACE \"\\n\" \";\" LIBS \"${LIBS}\")\n    foreach(LIB ${LIBS})\n      string(REGEX MATCH \"lib.*\\.a$\" LIB ${LIB})\n      if(LIB)\n        string(LENGTH ${LIB} STR_LEN)\n        math(EXPR STR_LEN \"${STR_LEN} - 5\")\n        string(SUBSTRING ${LIB} 3 ${STR_LEN} LIB)\n        if(NOT TARGET ${LIB})\n          add_library(${LIB} STATIC IMPORTED GLOBAL)\n          add_library(${name}::${LIB} ALIAS ${LIB})\n          set_target_properties(${LIB} PROPERTIES IMPORTED_LOCATION\n                                                  \"${LIB_DIR}/lib${LIB}.a\")\n          target_include_directories(${LIB} INTERFACE ${INCLUDE_DIRS})\n        endif()\n      endif()\n    endforeach()\n  endforeach()\n  # endif()\nendfunction(pg_add_third_party_lib)\n```\n\n1. 版本管理\n\n```cmake\nset(CPM_FUNCTIONS_VERSION 0.1)\nset(CPM_DOWNLOAD_LOCATION \"${CMAKE_SOURCE_DIR}/cmake/pg_cpm_functions.cmake\")\n\nif(EXISTS ${CPM_DOWNLOAD_LOCATION})\n  include(${CPM_DOWNLOAD_LOCATION})\nendif()\n\nif(NOT (CPM_FUNCTIONS_VERSION VERSION_EQUAL CURRENT_CPM_FUNCTIONS_VERSION))\n  message(\n    STATUS\n      \"CURRENT_CPM_FUNCTIONS_VERSION ${CURRENT_CPM_FUNCTIONS_VERSION} not equal to CPM_FUNCTIONS_VERSION ${CPM_FUNCTIONS_VERSION}}\"\n  )\n  message(\n    STATUS\n      \"Downloading https://xxxxcpm/functions/v${CPM_FUNCTIONS_VERSION}/pg_cpm_functions.cmake to ${CPM_DOWNLOAD_LOCATION}\"\n  )\n  file(\n    DOWNLOAD\n    https://xxxxxx/functions/v${CPM_FUNCTIONS_VERSION}/pg_cpm_functions.cmake\n    ${CPM_DOWNLOAD_LOCATION})\nendif()\n\ninclude(${CPM_DOWNLOAD_LOCATION})\nmessage(\n  STATUS \"CURRENT_CPM_FUNCTIONS_VERSION=\\\"${CURRENT_CPM_FUNCTIONS_VERSION}\\\"\")\n```\n\n## Links\n\n1. [使用 CPM 管理 CMake C++工程中的外部依赖库](https://blog.csdn.net/davidhopper/article/details/121030549)\n"},{"title":"Clang","url":"/2022/07/07/Clang/","content":"\n## base\n\n1. `-Wall`：启用大多数警告。这是开发中常用的选项，可以帮助发现潜在的代码问题。\n1. `-Wextra`：启用额外的警告，比 -Wall 更严格。\n1. `-Werror`：将所有警告当作错误处理。这意味着任何警告都会导致编译失败，迫使开发者修复这些潜在的问题\n\n## clang VS gcc\n\n1. clang 优势\n   - 编译速度更快\n   - 编译产出更小\n   - 出错提示更友好\n   - 内置有静态分析工具\n   - 专注\n\n## cmake 使用\n\n1. env\n\n```sh\nexport CC=clang\nexport CXX=clang++\n```\n\n1. cmake\n\n```sh\ncmake -DCMAKE_C_COMPILER=clang  -DCMAKE_CXX_COMPILER=clang++ ..\n```\n\n## [include-what-you-use](https://github.com/include-what-you-use/include-what-you-use)\n\n1. 检查在头文件中用了哪些 symbol\n1. `sudo ln -s /usr/bin/python3 /usr/bin/python`\n1. `iwyu_tool.py -p build/` build 下有 compile_commands.json, 分析工程\n1. fix_includes.py 修复 include\n1. build\n\n```sh\n# git clone git@github.com:include-what-you-use/include-what-you-use.git\n# cd include-what-you-use\n# git checkout 0.14\n# mkdir build && cd build\n# cmake -G \"Unix Makefiles\" -DCMAKE_PREFIX_PATH=/usr/lib/llvm-10 ../\n# make && make install\n# bin/include-what-you-use ../../cpp_sandbox/io/read_shape/test.cpp\n```\n\n## links\n\n1. [linux 下 Clang 和 gcc 的区别](https://cloud.tencent.com/developer/article/1449757)\n"},{"title":"Bazel","url":"/2022/07/05/Bazel/","content":"\n## docker\n\n1. `docker pull cockroachdb/bazel:latest-do-not-use`\n1. [安装脚本](https://bazel.build/install/ubuntu?hl=zh-cn#run-installer)\n\n## tutorial\n\n1. [c++ base samples](https://bazel.build/start/cpp?hl=zh-cn)\n1. [c++ tutorials](https://bazel.build/tutorials/cpp-use-cases?hl=zh-cn)\n\n## links\n\n1. [参考文档: 构建百科全书， 测试百科全书，命令行参考文档，查询参考文档](https://bazel.build/reference?hl=zh-cn)\n1. [简介](https://bazel.build/about/intro?hl=zh-cn)\n1. [build system](https://bazel.build/basics?hl=zh-cn)\n1. [概念](https://bazel.build/concepts/build-ref?hl=zh-cn)\n1. [基础知识](https://bazel.build/build/style-guide?hl=zh-cn)\n1. [最佳做法](https://bazel.build/configure/best-practices?hl=zh-cn)\n1. [配置 BUILD](https://bazel.build/configure/attributes?hl=zh-cn)\n","tags":["Tools","Bazel"],"categories":["Tools","Bazel"]},{"title":"Ninja","url":"/2022/07/05/Ninja/","content":"\n## basic\n\n1. `sudo apt-install ninja-build`\n1. `cmake .. -G Ninja`\n1. 除了加上`-G Ninja`使用方式与`make`一致\n\n```sh\nBUILD_TYPE=Release\nBUILD_DIR=build_gpu_tensorrt\nINSTALL_DIR=${BUILD_DIR}/$(basename \"$PWD\")_$(echo ${BUILD_TYPE} | tr '[:upper:]' '[:lower:]')\nBUILD_SYSTEM=Ninja\nif ! [ -x \"$(command -v ninja)\" ]; then\n    BUILD_SYSTEM='Unix Makefiles'\nfi\n\ncmake -G \"${BUILD_SYSTEM}\" -S . -B ${BUILD_DIR} \\\n    -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \\\n    -DUSE_API_V2=OFF \\\n    -DUSE_ASCEND=OFF \\\n    -DUSE_NEUWARE=OFF \\\n    -DUSE_GPU=ON \\\n    -DUSE_TENSORRT=ON \\\n    -DUSE_GPU_PRE_PROCESS=ON \\\n    -DDEBUG_INPUT_OUTPUT=OFF \\\n    -DCMAKE_VERBOSE_MAKEFILE=ON \\\n    # -DCMAKE_C_COMPILER=clang-10 \\\n    # -DCMAKE_CXX_COMPILER=clang++-10 \\\n    -DARCH_PLAT_VENDOR=x86_64-ubuntu-linux-gcc9.3.0 \\\n    $@\ncmake --build ${BUILD_DIR} -j4\ncmake --install ${BUILD_DIR} --prefix ${INSTALL_DIR}\n```\n\n1. ninja color output\n\n```cmake\nif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n    add_compile_options (-fdiagnostics-color=always)\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\")\n    add_compile_options (-fcolor-diagnostics)\nendif ()\n```\n\n1. 错误信息绝对路径\n\n## Link\n\n1. [wikipedia](<https://zh.m.wikipedia.org/zh-hans/Ninja_(%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F)>)\n"},{"title":"数据落盘","url":"/2022/07/04/数据落盘/","content":"\n## basic\n\n1. ![经典图](https://img-blog.csdnimg.cn/2020091210500712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpZXlpaHVhMTk5NA==,size_16,color_FFFFFF,t_70#pic_center)\n\n## Links\n\n1. [数据落盘机制](https://blog.csdn.net/xieyihua1994/article/details/108545746)\n"},{"title":"Model-deploy","url":"/2022/06/30/Model-deploy/","content":"\n## pgpredict\n\n1. 负责模型推理\n1. 接口:\n   - load model\n   - set input data\n   - forward\n   - get output data\n\n## dcv-cpp\n\n1. 负责将全流程（前后处理+模型推理）运行起来（单路）\n\n## sdk\n\n1. 负责模型相关业务逻辑（多路)\n"},{"title":"gitlab","url":"/2022/06/30/gitlab/","content":"\n## base usage\n\n1. `grep`\n1. `find file`\n1. `edit in Web IDE`\n1. `history` direct to branch commit\n1. `Permalink`\n1. `commits tags branch Storage` behind project name\n1. `snippets`\n1. `Use wiki`\n\n## [DevOps lifecycle](https://about.gitlab.com/stages-devops-lifecycle/value-stream-analytics/)\n\n1. [中文文档](https://gitlab.cn/stages-devops-lifecycle/)\n\n## [value-stream-analytics](https://about.gitlab.com/stages-devops-lifecycle/value-stream-analytics/)\n\n1. On the left sidebar, select `Analytics > Value stream`.\n\n## merge request\n\n## code review\n\n## issue\n\n### issue board\n\n## milestone\n\n## Package Registry\n\n## links\n\n1. [基于 GitLab 的工作流程设计](https://zhuanlan.zhihu.com/p/38774185)\n1. [GitLab Flow 介绍](https://docs.gitlab.cn/jh/topics/gitlab_flow.html#gitlab-flow-%E4%BB%8B%E7%BB%8D)\n1. [GitLab Flow 的 11 条规则](http://dockone.io/article/2350)\n","tags":["gitlab"],"categories":["Tools","gitlab"]},{"title":"magit","url":"/2022/06/24/magit/","content":"\n## basic\n\n1. `C-h m` 查看 magit 快捷键\n1. `$` 查看具体命令及历史\n1. `S-tab`\n1. `M-2` magit-section-show-level-2-all\n1. `y` show branchs and tags\n1. `du` and `ds`: diff unstaged and staged\n1. `X` reset: 撤销，commit 不保存记录\n1. `V` revert: 撤销， 保存 commit 撤销记录\n1. `AA` + `commit id`: cherry pick 将某次提交应用到当前分支\n\n## commit\n\n1. 修改： `c` => `w` => `C-c C-c`\n1. 合并： magit: rebase `r` =>`i` => `C-c C-c` => `f .. f` => `C-c C-c`\n1. `ce` Extend 当前 Staged 的文件合并到上一次提交中 git commit –amend –no-edit\n1. `ca` Amend 只修改上次提交的日志 git commit –amend\n\n## tag\n\n1. `tt`: create tag\n1. `pt`: push all tags\n\n## stash\n\n1. 单一文件：\n   - stage\n   - `zi`\n\n## command (such as: add a new file in a directory)\n\n1. `!` run git command\n1. `!!` run git command in current repo root path\n"},{"title":"Cpp awesome src","url":"/2022/05/19/Cpp-awesome-src/","content":"\n## links\n\n1. [chromium](https://github.com/chromium/chromium)\n1. [taskflow](https://github.com/taskflow/taskflow)\n"},{"title":"taskflow","url":"/2022/05/19/taskflow/","content":"\n## 调度框架实现\n\n1. [queue 示意图](https://excalidraw.com/#json=TDm5o05q9INkFNkP9Xcu-,s4EkPpKyeCgTF4nqCC6fAQ)\n\n## 心得\n\n1. 顶点是函数，边是数据\n1. 所谓 flow 是指计算顺序，数据并不会移动。\n1. 顶点和边组成 DAG\n1. DAG 需要调度器来运行\n1. 各框架：\n   - vitis ai runtime: op 是顶点，tensor 是边, runner 是调度器\n   - dpx flow: module(forward?) 是顶点，message 是边, engine 是调度器\n   - taskflow: Node 是顶点，Executor 是调度器\n   - CGraph:\n   - sogou workflow:\n   - tensorflow:\n   - pytorch:\n1. CGraph 中的[claster](http://www.chunel.cn/archives/cgraph-loop-introduce)和 flow 中的 module 很像, 继承自 group，由多个 functionNode 线性组合而成。执行 cluster 的时候，内部的 node 依次顺序执行。简而言之就是可以依次完成多个功能。\n1. flow 是异步事件驱动的运行模式，使用异步回调方式，feed msg 后执行完 workflow 后调用回调函数。\n1. taskflow 也是异步模式，都有 observer, 执行完后调用回调函数，观察者模式。 tf::ObserverInterface 和 RunObserver\n   q1. 顶点需要注册到图中, 并设定依赖关系。\n\n## 先学习图，再来学 taskflow\n\n## 有向无环图（DAG, Directed Acyclic Graph）\n\n1. [纯序员给你介绍图化框架的简单实现——循环逻辑](http://www.chunel.cn/archives/cgraph-loop-introduce)p\n1. [纯序员给你介绍图化框架的简单实现——执行逻辑](http://www.chunel.cn/archives/cgraph-run-introduce)\n1. [大数据工作流任务调度--有向无环图(DAG)之拓扑排序](https://dolphinscheduler.apache.org/zh-cn/blog/DAG.html)\n\n## links\n\n1. [oneTBB](https://github.com/oneapi-src/oneTBB)\n1. [taskflow](https://github.com/taskflow/taskflow)\n1. [tutorial](https://taskflow.github.io/taskflow/pages.html)\n1. [Building and Installing](https://taskflow.github.io/taskflow/install.html)\n1. [Learning from Examples](https://taskflow.github.io/taskflow/Examples.html)\n1. [TaskFlow 代码阅读笔记](https://zhuanlan.zhihu.com/p/438678706)\n1. [CGraph](https://github.com/ChunelFeng/CGraph)\n1. [workflow](https://github.com/sogou/workflow)\n1. [gparallel](https://github.com/galois-advertising/gparallel)\n"},{"title":"windows-docker","url":"/2022/04/26/windows-docker/","content":"\n## install\n\n1. [install git](https://git-scm.com/download/win)\n1. [Visual Studio Code Remote Containers Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)\n\n## NOTES\n\n1. 安装完 docker 后可以在 windows WLS2 ubuntu 下使用\n"},{"title":"windows WSL2","url":"/2022/04/26/docker-windows/","content":"\n## [install WSL2](https://docs.microsoft.com/zh-cn/windows/wsl/install)\n\n1. [update kernel](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)\n1. [install manual](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual)\n1. [install windows terminal](https://docs.microsoft.com/zh-CN/windows/terminal/install)\n"},{"title":"windows WSL2","url":"/2022/04/26/windows-WSL2/","content":"\n## NOTE\n\n1. [run-emacs-in-graphical-display](https://github.com/hubisan/emacs-wsl#run-emacs-in-graphical-display)\n1. [gui-apps](https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps)\n1. wsl 里可以直接显示，如 opencv show， gpuplot\n1. [WSL 2 配置代理 clash](https://solidspoon.xyz/2021/02/17/%E9%85%8D%E7%BD%AEWSL2%E4%BD%BF%E7%94%A8Windows%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/) 配置 WSL2 使用 Windows 代理上网 有用\n\n## [install WSL2](https://docs.microsoft.com/zh-cn/windows/wsl/install)\n\n1. [update kernel](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)\n1. [install manual](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual)\n1. [install windows terminal](https://docs.microsoft.com/zh-CN/windows/terminal/install)\n1. [内存限制](https://www.cnblogs.com/yyfh/p/16526955.html)\n\n## WSL2 ubuntu usage\n\n1. `/mnt/c` windows C 盘 mount 路径\n1. `explorer.exe .` 在 wsl 中打开 windows 资源管理器\n1. `cd ~/ && explorer.exe .` 查看 wsl 路径\n1. `explorer.exe *.jpg` 查看图片\n1. explorer.exe 可以用默认方式打开各类文件 `alias open='explorer.exe'`\n1. samba mount(fast)\n\n```sh\nsudo mkdir -p /data0/users/xiyang.jia/d\nsudo mount.cifs //10.31.1.225/share /data0/users/xiyang.jia/d -o user=xiyang.jia\n```\n\n1. [mount(slow)](https://linuxnightly.com/mount-and-access-hard-drives-in-windows-subsystem-for-linux-wsl/)\n\n```sh\nsudo mkdir -p /data0/users/xiyang.jia/\nsudo mount -t drvfs Z: /data0/users/xiyang.jia/\n```\n\n## [windows terminal](https://github.com/microsoft/terminal) 美化\n\n1. 超高效： win + \\` 打开一半 windows terminal, 然后使用 win + f 全屏，后边切换都是全屏， 使用 tmux，可以连接服务器\n   - windows terminl\n   - wsl + tmux\n   - server\n   - sevver + docker\n   - 需要解决 ssh 经常断开问题 [link](https://blog.csdn.net/qq_15505637/article/details/80881770)\n     - `sudo /etc/init.d/ssh restart`\n   - tmux-resurrect 回复环境\n1. 如何设置 win 快捷键？\n1. C-- and C-+ 放大或缩小\n1. [官方设置教程](https://docs.microsoft.com/zh-CN/windows/terminal/install)\n1. [zenburn 主题](https://github.com/agkozak/windows-terminal-zenburn)\n1. [口袋妖怪适合 zenburn 背景的壁纸](https://wallpaperaccess.com/full/1644661.jpg)\n1. [口袋妖怪壁纸](https://wallpaperaccess.com/awesome-gengar)\n1. [口袋妖怪壁纸黑](https://wallpaperaccess.com/black-pokemon)\n1. [ubuntu 每一版壁纸汇总](http://ubuntu.ecchi.ca/wallpapers/)\n1. [ubuntu 壁纸](https://wallpaperaccess.com/ubuntu)\n1. [windows 壁纸](https://wallpaperhub.app/creators/genrolecaspe)\n1. [windows 壁纸 2](https://wallpaperhub.app/wallpapers/?tags=windows)\n1. [close scroll bar](https://github.com/microsoft/terminal/issues/3878#issuecomment-735253417)\n1. [themes](https://windowsterminalthemes.dev/)\n1. [programmer backgroud](https://wallpapers.com/wallpapers/4k-programming-codes-in-black-screen-cl72lv0j7uvh4bmy.html)\n"},{"title":"sphinx-doc","url":"/2022/04/18/sphinx-doc/","content":"\n## base\n\n1. install sphinx and theme\n\n```sh\n% pip install Sphinx\n% pip install sphinx-rtd-theme\n```\n\n1. `sphinx-quickstart` start a project\n1. `make html` build doc\n1. `make man` build man doc\n\n## Links\n\n1. [sphinx-doc/sphinx](https://github.com/sphinx-doc/sphinx)\n1. [简明教程](https://iridescent.ink/HowToMakeDocs/Basic/Sphinx.html#sphinx)\n1. [restructuredtext 语法](https://iridescent.ink/HowToMakeDocs/Basic/reST.html#restructuredtext)\n1. [文档托管网站 readthedocs.org](https://readthedocs.org/)\n1. [中文文档](https://sphinx-docs.readthedocs.io/zh_CN/latest/)\n1. [mkdocs](https://github.com/mkdocs/mkdocs/)\n1. [几款文档框架：Mkdocs、Sphinx、Teadocs、docsify](https://blog.csdn.net/m0_46521785/article/details/119812280)\n"},{"title":"onnx","url":"/2022/04/14/onnx-md/","content":"\n## base\n\n1. onnx 支持设置明确 batch size. By default, TensorFlow does not set an explicit batch size. [link](https://docs.nvidia.com/deeplearning/tensorrt/archives/tensorrt-861/quick-start-guide/index.html#onnx-export)\n1. why onnx?\n   ![onnx 流程](https://pic2.zhimg.com/80/v2-3214168ce95096026d2079623342317d_720w.webp)\n1. ONNX （Open Neural Network Exchange）\n1. ONNX 文件不仅仅存储了神经网络模型的权重，同时也存储了模型的结构信息以及网络中每一层的输入输出和一些其它的辅助信息。\n1. ONNX 使用的是 Protobuf 这个序列化数据结构去存储神经网络的权重信息。\n1. onnx 实现了一个 python 运行时，可用于评估 ONNX 模型和评估 ONNX 操作。目的是阐明 ONNX 的语义并帮助理解和调试 ONNX 工具和转换器。它无意用于生产，性能也不是目标\n1. ONNX 是强类型的，其定义不支持隐式强制转换。\n\n## tools\n\n### netron\n\n1. netron 查看 weights 需要点击+\n1. netron 点击 input 或 output 可以显示模型整体信息\n1. netron 左侧菜单栏可以点击 toggle names, weights, attributes\n\n### [PaddlePaddle/VisualDL](https://github.com/PaddlePaddle/VisualDL/tree/develop)\n\n### [zetane](https://github.com/zetane/viewer)\n\n1. can load onnx model and show intermediate results when the model is executed. 查看模型中间结果\n\n### [onnx2py.py](https://github.com/microsoft/onnxconverter-common/blob/master/onnxconverter_common/onnx2py.py)\n\n1. creates a python file from an ONNX graph. This script can create the same graph. It may be modified by a user to change the graph.\n\n### [onnx-tool 可以统计计算量，每层输出 shape](https://github.com/ThanatosShinji/onnx-tool/blob/main/README_CN.md)\n\n1. `python3 -m onnx_tool -m profile -i tensorrt/resnet50/model.onnx`\n\n### [pytorch-OpCounter](https://github.com/Lyken17/pytorch-OpCounter)\n\n### [polygraph](https://github.com/NVIDIA/TensorRT/tree/main/tools/Polygraphy/)\n\n1. `polygraphy inspect model tensorrt/resnet50/model.onnx`\n\n## links\n\n1. [官方介绍](https://onnx.ai/onnx/intro/concepts.html)\n1. [netron.app](https://netron.app/)\n1. [onnx 介绍](https://zhuanlan.zhihu.com/p/346511883)\n1. [onnx/models](https://github.com/onnx/models)\n1. [Operators](https://github.com/onnx/onnx/blob/main/docs/Operators.md)\n1. [ops 变化](https://onnx.ai/onnx/operators/index.html)\n1. [支持 onnx 的训练和推理框架](https://onnx.ai/supported-tools.html#deployModel)\n\n## model conver5\n\n### pytorch\n\n1. [pytorch docker](https://hub.docker.com/r/pytorch/pytorch)\n1. [(OPTIONAL) EXPORTING A MODEL FROM PYTORCH TO ONNX AND RUNNING IT USING ONNX RUNTIME](https://pytorch.org/tutorials/advanced/super_resolution_with_onnxruntime.html)\n1. 需要!pip install onnx onnxruntime Pillow\n\n```sh\nimport torchvision.models as models\nmodel = models.resnet50(pretrained=True)\n    if torch.cuda.is_available():\n        model.cuda()\ntorch.onnx.export(......)\n```\n"},{"title":"AI-models","url":"/2022/04/13/AI-models/","content":"\n## model zoo\n\n### caffe\n\n1. [SnailTyan/caffe-model-zoo](https://github.com/SnailTyan/caffe-model-zoo)\n\n### onnx\n\n1. [onnx/models](https://github.com/onnx/models)\n\n### pytorch\n\n1. [Cadene/pretrained-models.pytorch](https://github.com/Cadene/pretrained-models.pytorch)\n1. [pytorch official](https://pytorch.org/vision/stable/models.html)\n"},{"title":"AI-chip-performance","url":"/2022/04/11/AI-performance/","content":"\n## throughput and latency\n\n1. throughput：吞吐量一般指相当一段时间内测量出来的系统单位时间处理的任务数或事务数。如：1s 处理 10 帧图片 (10FPS)\n1. latency: 执行一次任务需要的时间。如：处理一帧图片耗时 10ms\n1. Throughput – successful transactions per second\n1. Latency – response time per transaction\n\n## base\n\n1. `计算芯片的峰值算力` 理论计算得出的、理想状况下的峰值算力。具体通过计算核的主频、核数量、单核运算能力等来输出理论峰值，与实际场景中的真实有效处理能力有很大差距。\n1. `计算芯片的有效算力` 设备在实际运作过程中能真实输出的算力。比如 ResNet50 在浮点 16 位精度下，推理一次的计算量是 7.8Gflops 左右，芯片每秒钟处理的 ResNet50 的帧率乘以 7.8G 就是真实有效的输出算力。如果推理帧率是 400fps，真实算力是 400\\*7.G=3Tflops。\n1. `计算芯片的有效利用率` 代表了芯片真实输出的运算能力。其计算方式为：真实有效的输出算力/理论算力。计算结果值越高，表明该芯片工作越高效。实际应用场景中，多数传统架构计算芯片，有效利用率一般在 30%左右，而新型架构的计算芯片，芯片有效利用率可以到 50%以上。领启 KA200 异构众核、存算一体芯片有效利用率可达 60%以上。\n   - 利用率： 模型计算量 \\* FPS / 芯片性能\n   - VCK190 133T, tf_resnetv1_50_imagenet_224_224_6.97G, 1421FPS, 使用率：6.97 \\* 1421 / 1000 / 133 = 7.4%\n1. `计算芯片对主流神经网络的支持程度` 下一代人工智能有两个不同的发展线路图，一个是以深度学习算法为代表的传统计算科学，一个是以生物神经网络为代表脑科学。多数计算芯片只能支持二者之一。是否能将二者兼并支持，也是衡量计算芯片的核心指标之一，异构融合是达到这一指标的重要途径之一。\n1. `芯片能效比` 计算方式为：典型网络（如 ResNet50）的推理能力/芯片的功耗，单位：推理帧率（fps/w）。\n1. `芯片的性价比` 每平方毫米推理的帧率数，计算方式为：典型网络（如 ResNet50）的推理能力/芯片的面积。\n1. 多`batch`会增加模型计算量\n1. 浮点转定点会降低计算量，可能剪枝优化\n1. NCHW 和 NHWC 会影响性能\n\n## 模型计算量\n\n### caffe\n\n1. [netscope](https://dgschwend.github.io/netscope/#/editor)\n1. [quickstart](https://dgschwend.github.io/netscope/quickstart.html)\n1. 复制 prototxt 内容, `shift + enter`: 查看计算量\n\n### onnx\n\n1. [onnx-opcounter](https://github.com/gmalivenko/onnx-opcounter) 需要模型结构，只有 pt 文件不行\n\n### pytorch\n\n1. [pytorch-OpCounter](https://github.com/Lyken17/pytorch-OpCounter)\n1. [mmdetection](https://github.com/open-mmlab/mmdetection/blob/master/README_zh-CN.md)\n\n### tensorflow\n\n## 芯片性能\n\n1. [地平线 J2](https://www.horizon.ai/journey2.html)\n   - 4TOPS\n   - 2W\n1. [J3](https://www.horizon.ai/journey3.html)\n   - 5TOPS\n   - 2.5W\n   - 16nm\n1. [J5](https://www.horizon.ai/journey5.html)\n   - 128TOPS\n   - 30W\n1. [Nvidia Xavier](https://www.nvidia.cn/autonomous-machines/embedded-systems/jetson-orin/) 比较 Jetson Orin 和 Jetson Xavier 的规格\n   - 21-32TOPS\n   - 10-40W\n   - 12nm\n1. [Nvidia Orin](https://www.nvidia.cn/autonomous-machines/embedded-systems/jetson-orin/) 比较 Jetson Orin 和 Jetson Xavier 的规格\n   - 70-274TOPS\n   - 10-60W\n   - 8nm\n1. [Xilinx Versal ACAP VC1902(VCK190)]()\n   - 133TOPS\n   - 7ns\n1. [昇腾（HUAWEI Ascend) 910](https://www.hisilicon.com/cn/products/Ascend/Ascend-910)\n   - FP16: 320TFLOPS\n   - INT8: 640TOPS\n   - 310W\n   - 7nm\n1. [特斯拉 FSD 计算平台]()\n   - 144TOPS\n   - 单芯片 72TOPS\n   - 72W\n1. [Mobileye EQ4 High](https://www.mobileye.com/eyeq-chip/)\n   - 2TOPS\n   - 28nm\n1. [Mobileye EQ5 High]()\n   - 16TOPS\n   - 7nm\n1. [Mobileye EQ6 High]()\n   - 34TOPS\n   - 7nm\n\n## links\n\n1. [jetson xavier params](https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-xavier-series/)\n1. [jetson parms](https://developer.nvidia.com/embedded/jetson-modules)\n1. [TOPS GOPS FLOPS](https://zhuanlan.zhihu.com/p/337618803)\n1. [指标](https://wuchenxu.com/2021/10/02/computing-power-metrices/)\n1. [J5 官方介绍](https://www.horizon.ai/journey5.html)\n1. [link1](https://auto.gasgoo.com/a/70266230.html)\n1. [jetson-benchmark](https://developer.nvidia.com/embedded/jetson-benchmarks)\n1. [deep-learning-performance-training-inference](https://developer.nvidia.com/deep-learning-performance-training-inference)\n1. [orin performance](https://developer.nvidia.com/blog/delivering-server-class-performance-at-the-edge-with-nvidia-jetson-orin/)\n1. [orin 产品系列](https://www.nvidia.cn/autonomous-machines/embedded-systems/jetson-orin/)\n1. [VCK190 性能](https://github.com/Xilinx/Vitis-AI/tree/master/models/AI-Model-Zoo#performance-on-vck190)\n1. [地平线 MAPS](https://new.qq.com/omn/20220127/20220127A06JD900.html)\n1. [中信车载芯片调研](https://img3.gelonghui.com/pdf/bc70f-43194a12-e915-4416-9ffa-2e241931ae61.pdf)\n1. [亿欧网调研](https://pdf.dfcfw.com/pdf/H3_AP202112301537477959_1.pdf?1640871632000.pdf)\n1. [艾瑞咨询-中国智能驾驶行业研究报告](https://pdf.dfcfw.com/pdf/H3_AP202112061533188037_1.pdf?1639041416000.pdf)\n"},{"title":"ChangeLog","url":"/2022/04/08/ChangeLog/","content":"\n## links\n\n1. [如何维护更新日志](https://keepachangelog.com/zh-CN/1.0.0/)\n1. [mmsegmentation](https://github.com/open-mmlab/mmsegmentation/blob/master/docs/en/changelog.md)\n1. [glog](https://github.com/google/glog/blob/master/ChangeLog)\n"},{"title":"clang-tidy","url":"/2022/04/07/clang-tidy/","content":"\n## [clang-tidy AST 静态检查工具](https://clang.llvm.org/extra/clang-tidy/)\n\n## basic\n\n1. 见 cpp-debug.md lint\n1. 需要 compile_commands.json\n\n## [C++静态检查工具总结](https://blog.csdn.net/u013377887/article/details/108651945)\n","tags":["Tools","Clang Tidy"],"categories":["Tools","Clang"]},{"title":"gtest","url":"/2022/04/02/gtest/","content":"\n## basic\n\n1. 断言是成对的，测试同一件事，但对当前函数有不同的影响。\n   - ASSERT\\_ \\*版本在失败时会生成致命错误，并中止当前函数。\n   - EXPECT\\_ \\*版本生成非致命性故障，不会中止当前函数。\n   - 通常优先使用 EXPECT* \\*，因为它们允许在测试中报告多个故障。但是，如果失败时函数继续运行没有意义，则应使用 ASSERT* \\*。\n1. gtest_main.a 有什么用？可以不用写自己的 main 函数，链接 libgtest_main.a 就可以了。\n1. CMakeLists.txt\n\n```sh\nfind_package(GTest REQUIRED)\ninclude_directories(${GTEST_INCLUDE_DIRS})\ntarget_link_libraries(xxx ${GTEST_LIBRARIES})\n```\n\n## NOTE\n\n1. `enable_testing()` 需要在第一级 CMakeLists.txt 里，否则`make test`不生效\n1. `make test`: gtest 想要被 make test 发现需要[link](https://google.github.io/googletest/quickstart-cmake.html)\n1. `Testing/Temporary/LastTest.log` 为`make test`结果\n\n```cmake\ninclude(GoogleTest)\ngtest_discover_tests(hello_test)\n```\n\n## report (xml json html)\n\n1. gtest 结果 xml 可以显示到 ci pipeline 结果中去 [link](https://docs.gitlab.com/ee/ci/unit_test_reports.html)\n\n```yaml\nstages:\n  - test\n\ncpp:\n  stage: test\n  script:\n    - ./gtxxx --gtest_output=xml:report.xml\n\n  artifacts:\n    when: always\n    reports:\n      junit:\n        - report.xml\n        - fail.xml\n```\n\n1. ./gtxxx --gtest_output=xml:filename\n\n1. `make test`\n\n```\n  ::testing::GTEST_FLAG(output) = \"xml:test2.xml\";\n  ::testing::GTEST_FLAG(output) = \"json:test2.json\";\n  ::testing::InitGoogleTest(&argc, argv);\n```\n\n1. [to html](https://blog.csdn.net/Neil4/article/details/104484792)\n\n## links\n\n1. [cmake 集成](https://google.github.io/googletest/quickstart-cmake.html)\n\n## samples\n\n1. 通用框架: 添加 gtest 不用修改 CMakeLists.txt\n\n```cmake\nenable_testing() # 需要在第一级 CMakeLists.txt 里，否则`make test`不生效\n\nset(gtest-source-pattern \"gtest/*.cpp\")\nfile(GLOB gtest-sources ${gtest-source-pattern})\n\nadd_executable(gtests)\ntarget_sources(gtests PRIVATE ${gtest-sources})\ntarget_include_directories(gtests\n                           PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/gtest/)\ntarget_link_libraries(gtests PRIVATE gtest ${COMMON_LIB})\n\nadd_test(fcw::gtests gtests)\n\n```\n\n1. main\n\n```c++\n#include \"gtest/gtest.h\"\n\nint main(int argc, char** argv) {\n  ::testing::GTEST_FLAG(output) = \"xml:report.xml\";\n  // ::testing::GTEST_FLAG(output) = \"json:test2.json\";\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n```\n\n### yaml gtest CMakeLists.txt\n\n1. NOTE: use pattern\n\n```cmake\nfind_package(Threads REQUIRED)\n\nset(gtest_force_shared_crt ON CACHE BOOL \"\" FORCE)\nset(BUILD_MOCK ON CACHE BOOL \"\" FORCE)\nset(CMAKE_POLICY_DEFAULT_CMP0048 NEW)\n\nadd_subdirectory(\n  \"${CMAKE_CURRENT_SOURCE_DIR}/gtest-1.11.0\"\n  \"${CMAKE_CURRENT_BINARY_DIR}/prefix\")\n\ninclude_directories(SYSTEM \"${CMAKE_CURRENT_SOURCE_DIR}/gtest-1.11.0/googletest/include\")\n\nset(test-new-api-pattern \"new-api/*.cpp\")\nset(test-source-pattern \"*.cpp\" \"integration/*.cpp\" \"node/*.cpp\")\nif (CMAKE_VERSION VERSION_GREATER 3.11)\n  list(INSERT test-new-api-pattern 0 CONFIGURE_DEPENDS)\n  list(INSERT test-source-pattern 0 CONFIGURE_DEPENDS)\nendif()\n\nfile(GLOB test-new-api-sources ${test-new-api-pattern})\nfile(GLOB test-sources ${test-source-pattern})\n\nadd_executable(yaml-cpp-tests \"\")\ntarget_sources(yaml-cpp-tests\n  PRIVATE\n    ${test-new-api-sources}\n    ${test-sources})\ntarget_include_directories(yaml-cpp-tests\n  PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/integration\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    ${PROJECT_SOURCE_DIR}/src)\ntarget_compile_options(yaml-cpp-tests\n  PRIVATE\n    $<$<CXX_COMPILER_ID:Clang>:-Wno-c99-extensions -Wno-variadic-macros -Wno-sign-compare>\n    $<$<CXX_COMPILER_ID:GNU>:-Wno-variadic-macros -Wno-sign-compare>)\ntarget_link_libraries(yaml-cpp-tests\n  PRIVATE\n    Threads::Threads\n    yaml-cpp\n    gmock)\n\nset_property(TARGET yaml-cpp-tests PROPERTY CXX_STANDARD_REQUIRED ON)\nif (NOT DEFINED CMAKE_CXX_STANDARD)\n  set_target_properties(yaml-cpp-tests PROPERTIES CXX_STANDARD 11)\nendif()\n\n\nadd_test(yaml-cpp::test yaml-cpp-tests)\n\nif (build-windows-dll)\n  add_custom_command(\n    TARGET yaml-cpp-tests\n    POST_BUILD COMMAND ${CMAKE_COMMAND} -E\n    copy_if_different \"$<TARGET_FILE:yaml-cpp>\" \"$<TARGET_FILE_DIR:yaml-cpp-tests>\")\nendif()\n\n```\n\n## links\n\n1. [doctest](https://github.com/doctest/doctest)\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"自动驾驶专业术语","url":"/2022/03/31/自动驾驶专业术语/","content":"\n## [缩写](https://blog.csdn.net/LEON1741/article/details/89510034)\n\n1. `OTA`: over the air\n1. `FCW`: forward collision warning 前车碰撞预警\n1. `TTC`: time to collision 碰撞时间\n1. `NVS`: Night Vision System 夜视系统\n1. `NOA` “自动辅助导航驾驶（Navigate on Autopilot）”的中文翻译也有人叫“按导航辅助驾驶”或“领航辅助功能”，本质意思是，把“导航”和“辅助驾驶”结合。在原来 L2 辅助驾驶的基础上（如车道线保持、自动跟车），加上车机的导航信息（如百度地图），自动变道，实现从 A 点到 B 点的自动驾驶。\n1. `OEM` 又称主机厂，OEM 是英文 Original equipment manufacturer 的缩写。\n1. `DCU` (Domain Control Unit）域控制器\n1. `ECU`（Electronic Control Unit）电子控制单元\n1. `V2X`（Vehicle to everything）\n1. `TSN`（Time-Sensitive Network）\n1. `AUTOSAR`（AUTomotive Open System Architecture）\n1. `EEA` (Electrical/Electronic Architecture) 电子电气架构\n1. `SOME/IP` Scalable service-Oriented Middleware over IP。即“运行于 IP 之上的可伸缩的面向服务的中间件”\n1. `AUTOSAR` (AUTomotive Open System ARchitecture)\n1. `DDS` (Data Distribution Service,数据分发服务)\n1. `RTPS` (Real-Time Publish Subscribe)\n1. `FOV` (field of view) 视场; 在光学仪器或传感器的情况下，视场是检测器对电磁辐射敏感的立体角 [link](https://blog.csdn.net/weixin_33358099/article/details/112102463?spm=1001.2101.3001.6650.6&utm_medium=distribut)\n\n## 其他\n\n1. 标定：\n\n## Links\n\n1. [汽车软件研报](https://pdf.dfcfw.com/pdf/H3_AP202202221548462770_1.pdf?1645518929000.pdf)\n1. [华为 MDC 智能驾驶计算平台白皮书](https://www-file.huawei.com/-/media/corporate/pdf/news/intelligent-driving-computing-platform-whitepaper-new.pdf?la=zh)\n1. [软件定义汽车（2）-软件中间件（Autosar 为例）](https://zhuanlan.zhihu.com/p/261291971)\n1. [国内主机整车 EEA 架构汇总](https://zhuanlan.zhihu.com/p/561699068)\n1. [深度分析汽车芯片的现状与发展（一）汽车电子电气架构的变革](https://zhuanlan.zhihu.com/p/460683077)\n1. [深度分析汽车芯片的现状与发展（二）域控制器时代](https://zhuanlan.zhihu.com/p/461714692)\n1. [深度分析汽车芯片的现状与发展（三）ADAS/AD 域控制器及芯片平台分析](https://zhuanlan.zhihu.com/p/462675111)\n1. [深度分析汽车芯片的现状与发展（四）整车控制域](https://zhuanlan.zhihu.com/p/464930132)\n"},{"title":"eigen","url":"/2022/03/26/eigen/","content":"\n## basic\n\n1. gdb 调试 [printer](https://gitlab.com/libeigen/eigen/-/blob/master/debug/gdb/printers.py)\n1. vector 转 tensor [link](https://stackoverflow.com/a/44664806) [link1](https://blog.csdn.net/weareu/article/details/86486682)\n1. Tensor 转 vector\n\n```c++\ntemplate <typename Tensor> static std::vector<float> run(const Tensor &tensor) {\n  typedef typename Eigen::internal::remove_const<typename Tensor::Scalar>::type\n      Scalar;\n  typedef typename Tensor::Index Index;\n  const Index total_size = Eigen::internal::array_prod(tensor.dimensions());\n  std::vector<float> result;\n\n  if (total_size > 0) {\n    Eigen::Map<const Eigen::Array<Scalar, Eigen::Dynamic, 1>> array(\n        const_cast<Scalar *>(tensor.data()), total_size);\n    std::cout << array[0] << std::endl;\n    for (auto i = 0u; i < total_size; ++i) {\n      result.push_back(array[i]);\n    }\n\n    // os << array;                                                                                                                                         }\n  return result;\n};\n```\n\n1. 头文件和编译选项\n\n```\n#include <eigen3/Eigen/Eigen>\nfind_package(Eigen3 REQUIRED)\n```\n\n1. 矩阵默认[按列存储](https://eigen.tuxfamily.org/dox/group__TopicStorageOrders.html)， 按行需要指定\n\n```c++\n  Eigen::Matrix<double, 4, 4, Eigen::RowMajor> cam_intra;\n```\n\n1. 常用数据结构：\n\n   - Vector3d: `auto col = Eigen::Vector3d(0, 0, 0);`\n   - RowVector4d: `auto row = Eigen::RowVector4d(0, 0, 0, 1);`\n   - MatrixXd: `Eigen::MatrixXd tmp(3, 4);`\n   - Matrix: `Eigen::Matrix<double, 4, 4, Eigen::RowMajor> cam_intra;`\n   - Map: `auto T_cab2cam = Eigen::Map<Eigen::Vector3d>(std_vector.data());`\n\n1. 矩阵相乘： `A * B`\n1. 矩阵求逆： `A.inverse()`\n1. [矩阵取列：](https://eigen.tuxfamily.org/dox/group__TutorialBlockOperations.html) `A.col()`\n1. 矩阵取行： `A.row()`\n\n## basci module\n\n1. Matrix init\n\n```c++\nEigen::Matrix3d R_e2cab;\n  R_e2cab << 0, 0, -1,  //\n      0, 1, 0,          //\n      1, 0, 0;          //\n\n```\n\n1. std::vecotr to Eigen::Vecotr or Eigen::Matrix\n\n```\nauto R_cab2cam_tmp = Eigen::Map<Eigen::RowVector3d>(v_R_cab2cam.data());\nauto cam_k = Eigen::Map<Eigen::Matrix<double, 3, 3, Eigen::RowMajor>>(v_cam_k.data());\n\n```\n\n1. Eigen::Vecotr or Eigen::Matrix to std::vector\n\n```c++\n\n std::vector<double> vec_cam_intra(\n      cam_intra.data(), cam_intra.data() + cam_intra.rows() * cam_intra.cols());\n```\n\n1. Matrix concat\n\n```c++\nEigen::MatrixXd cab2cam_tmp(3, 4);\nauto col_tmp = Eigen::RowVector4d(0, 0, 0, 1);\nEigen::MatrixXd cab2cam(4, 4);\ncab2cam << cab2cam_tmp, col_tmp;\n\nEigen::MatrixXd cab2cam_tmp(4, 3);\nauto col_tmp = Eigen::Vector3d(0, 0, 1);\nEigen::MatrixXd cab2cam(4, 4);\ncab2cam << cab2cam_tmp, col_tmp;\n\n```\n\n1. Matrix slice ([block](https://eigen.tuxfamily.org/dox/group__TutorialBlockOperations.html))\n\n```c++\nEigen::Matrix<double, 4, 4, Eigen::RowMajor> cam2ego;\nEigen::Matrix<double, 3, 3, Eigen::RowMajor> R_cam2ego = cam2ego.block(0, 0, 3, 3);\nEigen::Vector3d T_cam2ego = cam2ego.block(0, 3, 3, 1);\n\n```\n\n## links\n\n1. [gitlab repo](https://gitlab.com/libeigen/eigen.git)\n1. [getting started](https://eigen.tuxfamily.org/dox/GettingStarted.html)\n\n## sample\n\n```c++\n#include <glog/logging.h>\n#include <yaml-cpp/yaml.h>\n\n#include <eigen3/Eigen/Eigen>\n#include <fstream>\n#include <iostream>\n#include <vector>\n\nvoid GetPgCamParm(const std::string camera_param, const std::string cali_param,\n                  const std::string result_param) {\n  YAML::Node cam_info = YAML::LoadFile(camera_param);\n  YAML::Node cb_xyz = YAML::LoadFile(cali_param);\n\n  // cam_k\n  std::vector<double> v_cam_k;\n  if (cam_info[\"mtx\"][\"data\"]) {\n    v_cam_k = cam_info[\"mtx\"][\"data\"].as<std::vector<double>>();\n  } else {\n    LOG(FATAL) << \"Can't get cam_info[\\\"mtx\\\"][\\\"data\\\"]\";\n  }\n  auto cam_k =\n      Eigen::Map<Eigen::Matrix<double, 3, 3, Eigen::RowMajor>>(v_cam_k.data());\n  VLOG(2) << \"\\ncam_k:\\n\" << cam_k;\n\n  // cam_intra\n  auto col = Eigen::Vector3d(0, 0, 0);\n  Eigen::MatrixXd tmp(3, 4);\n  tmp << cam_k, col;\n  auto row = Eigen::RowVector4d(0, 0, 0, 1);\n  Eigen::Matrix<double, 4, 4, Eigen::RowMajor> cam_intra;\n  cam_intra << tmp, row;\n  VLOG(2) << \"\\ncam_intra:\\n\" << cam_intra;\n\n  // R_e2cab\n  Eigen::Matrix3d R_e2cab;\n  R_e2cab << 0, 0, -1,  //\n      0, 1, 0,          //\n      1, 0, 0;          //\n  VLOG(2) << \"\\nR_e2cab:\\n\" << R_e2cab;\n\n  // T_e2cab\n  Eigen::Vector3d T_e2cab;\n  if (cb_xyz[\"boarad2ego\"]) {\n    T_e2cab << cb_xyz[\"boarad2ego\"]['x'].as<double>(),\n        cb_xyz[\"boarad2ego\"]['y'].as<double>(),\n        cb_xyz[\"boarad2ego\"]['z'].as<double>();\n  } else {\n    LOG(FATAL) << \"Can't get cb_xyz[\\\"boarad2ego\\\"]\";\n  }\n  VLOG(2) << \"\\nT_e2cab:\\n\" << T_e2cab;\n\n  // ego2cab\n  Eigen::MatrixXd ego2cab_tmp(3, 4);\n  ego2cab_tmp << R_e2cab, T_e2cab;\n  VLOG(2) << \"\\nego2cab_tmp:\\n\" << ego2cab_tmp;\n\n  // R_cab2cam\n  std::vector<double> v_R_cab2cam;\n  if (cam_info[\"rvec\"][\"data\"]) {\n    v_R_cab2cam = cam_info[\"rvec\"][\"data\"].as<std::vector<double>>();\n  } else {\n    LOG(FATAL) << \"Can't get cam_info[\\\"rvec\\\"][\\\"data\\\"]\";\n  }\n  auto R_cab2cam_tmp = Eigen::Map<Eigen::RowVector3d>(v_R_cab2cam.data());\n  double n_norm = R_cab2cam_tmp.norm();\n  Eigen::AngleAxisd rotation_vector(n_norm, R_cab2cam_tmp / n_norm);\n  Eigen::Matrix3d R_cab2cam = rotation_vector.toRotationMatrix();\n  VLOG(2) << \"\\nR_cab2cam:\\n\" << R_cab2cam;\n\n  // T_cab2cam\n  std::vector<double> v_T_cab2cam;\n  if (cam_info[\"tvec\"][\"data\"]) {\n    v_T_cab2cam = cam_info[\"tvec\"][\"data\"].as<std::vector<double>>();\n  } else {\n    LOG(FATAL) << \"Can't get cam_info[\\\"tvec\\\"][\\\"data\\\"]\";\n  }\n  auto T_cab2cam = Eigen::Map<Eigen::Vector3d>(v_T_cab2cam.data());\n  VLOG(2) << \"\\nT_cab2cam:\\n\" << T_cab2cam;\n\n  // cab2cam\n  Eigen::MatrixXd cab2cam_tmp(3, 4);\n  cab2cam_tmp << R_cab2cam, T_cab2cam;\n  auto col_tmp = Eigen::RowVector4d(0, 0, 0, 1);\n  Eigen::MatrixXd cab2cam(4, 4);\n  cab2cam << cab2cam_tmp, col_tmp;\n  VLOG(2) << \"\\ncab2cam:\\n\" << cab2cam;\n\n  // ego2cab\n  Eigen::MatrixXd ego2cab(4, 4);\n  ego2cab << ego2cab_tmp, col_tmp;\n  VLOG(2) << \"\\nego2cab:\\n\" << ego2cab;\n\n  // cam2ego\n  Eigen::MatrixXd cam2ego = (cab2cam * ego2cab).inverse();\n  VLOG(2) << \"\\ncam2ego:\\n\" << cam2ego;\n  LOG(INFO) << \"\\ncam2ego row:\\n\" << cam2ego.row(0);\n  LOG(INFO) << \"\\ncam2ego row:\\n\" << cam2ego.col(0);\n\n  // get results\n  LOG(INFO) << \"\\nintrinsic: \\n\" << cam_intra;\n  std::vector<double> vec_cam_intra(\n      cam_intra.data(), cam_intra.data() + cam_intra.rows() * cam_intra.cols());\n\n  Eigen::Matrix<double, 3, 3, Eigen::RowMajor> R_cam2ego =\n      cam2ego.block(0, 0, 3, 3);\n  LOG(INFO) << \"\\nR_cam2ego: \\n\" << R_cam2ego;\n  std::vector<double> vec_R_cam2ego(\n      R_cam2ego.data(), R_cam2ego.data() + R_cam2ego.rows() * R_cam2ego.cols());\n\n  Eigen::Vector3d T_cam2ego = cam2ego.block(0, 3, 3, 1);\n  LOG(INFO) << \"\\nT_cam2ego: \\n\" << T_cam2ego;\n  std::vector<double> vec_T_cam2ego(\n      T_cam2ego.data(), T_cam2ego.data() + T_cam2ego.rows() * T_cam2ego.cols());\n\n  // save result to yaml\n  YAML::Node config;\n  // test[\"camera\"][\"v_cam_k\"].push_back(v);\n  // note: push_back and = are not same\n  config[\"camera\"][\"intrinsic\"] = vec_cam_intra;\n  config[\"camera\"][\"cam2ego_R\"] = vec_R_cam2ego;\n  config[\"camera\"][\"cam2ego_t\"] = vec_T_cam2ego;\n  std::ofstream fout(result_param);\n  fout << config;\n}\n\nint main(int argc, char *argv[]) {\n  GetPgCamParm(\"camera_params.yaml\", \"cali_board2vehicle_xyz.yaml\",\n               \"pg_cam2_param.yaml\");\n  return 0;\n}\n\n```\n","tags":["Eigen"],"categories":["Program"]},{"title":"yaml","url":"/2022/03/26/yaml/","content":"\n## opencv 对数\n\n1. python\n\n```python\n`cv2.FileStorage(\"output.yml\", cv2.FILE_STORAGE_WRITE).write(\"mat\", mat)`\n\n\nfs = cv2.FileStorage(\"predict_benz_trajectory_v2_crop.yml\", cv2.FILE_STORAGE_WRITE)\nfs.write(\"Q\", Q.astype(np.float32))\nfs.write(\"traj_out_wid\", traj_out_wid)\nfs.release()\n```\n\n2. C++\n\n```c++\ncv::FileStorage ymlfile(\"predict_benz_trajectory_v2_crop.yml\",                                                                                                                                                                                                                          cv::FileStorage::READ);\nif(!fs.isOpened()){\n        std::cout << \"Cannot open config file!\" << std::endl;\n        return -1;\n}\ncv::Mat disparity;\nymlfile[\"disparity\"] >> disparity;\nfloat traj_wid = (float)ymlfile[\"ground_traj_wid\"];\n\n\n  cv::Mat Q_mat;\n  cv::FileNode node = ymlfile[\"Q\"];\n  if (node.empty()) {\n    std::cerr << \"Key not found in yaml file\" << std::endl;\n  }\n  if (node.type() == cv::FileNode::MAP && node.size() > 0) {\n    node >> Q_mat;\n    if (Q_mat.type() == CV_64F) {\n      Q_mat.convertTo(Q_mat, CV_32F);\n    }\n  } else {\n    std::cerr << \"Node is not an opencv mat  or is empty\" << std::endl;\n  }\n\n```\n\n3. numpy and vector\n\n```\nimport cv2\nimport numpy as np\nnp_array = np.array([[1, 2, 3], [4, 5, 6]], dtype='float32')\nfs = cv2.FileStorage('output.xml', cv2.FileStorage_WRITE)\nfs.write('my_array', np_array)\nfs.release()\n```\n\n```\nstd::vector<float> vec;\nvec.assign((float*)mat.datastart, (float*)mat.dataend);\n```\n\n### 读写\n\n1. yaml-cpp\n1. [opencv cv::FileStorage](https://blog.csdn.net/learning_tortosie/article/details/97815514)\n\n### Links\n\n1. [github](https://github.com/jbeder/yaml-cpp)\n1. [tutorial](https://github.com/jbeder/yaml-cpp/wiki/Tutorial)\n\n### sample\n\n```c++\n#include <yaml-cpp/yaml.h>\n\n#include <fstream>\n#include <iostream>\n#include <vector>\n\nint main(int argc, char *argv[]) {\n\n\n  YAML::Node config = YAML::LoadFile(\"config.yaml\");\n\n  std::vector<double> intrinsic;\n  if (config[\"camera\"][\"intrinsic\"]) {\n    intrinsic = config[\"camera\"][\"intrinsic\"].as<std::vector<double>>();\n    for (auto i = 0u; i < intrinsic.size(); ++i) {\n      std::cout << intrinsic[i] << std::endl;\n    }\n  }\n\n  std::vector<double> cam2ego_R;\n  if (config[\"camera\"][\"cam2ego_R\"]) {\n    cam2ego_R = config[\"camera\"][\"cam2ego_R\"].as<std::vector<double>>();\n    for (auto i = 0u; i < cam2ego_R.size(); ++i) {\n      std::cout << cam2ego_R[i] << std::endl;\n    }\n  }\n\n  std::vector<double> cam2ego_t;\n  if (config[\"camera\"][\"cam2ego_t\"]) {\n    cam2ego_t = config[\"camera\"][\"cam2ego_t\"].as<std::vector<double>>();\n    for (auto i = 0u; i < cam2ego_t.size(); ++i) {\n      std::cout << cam2ego_t[i] << std::endl;\n    }\n  }\n\n  std::ofstream fout(\"./out.yaml\");\n  fout << config;\n\n  YAML::Node test;\n  // test[\"camera\"][\"intrinsic\"].push_back(v);\n  // note: push_back and = are not same\n  test[\"camera\"][\"intrinsic\"] = intrinsic;\n  test[\"camera\"][\"cam2ego_R\"] = cam2ego_R;\n  test[\"camera\"][\"cam2ego_t\"] = cam2ego_t;\n  std::ofstream fout1(\"./test.yaml\");\n  fout1 << test;\n  return 0;\n}\n\n```\n\n```yaml\ncamera:\n  intrinsic:\n    - 1888.7618313608834\n    - 0\n    - 968.83548164132105\n    - 0\n    - 0\n    - 1896.5639945248038\n    - 547.4612962459845\n    - 0\n    - 0\n    - 0\n    - 1\n    - 0\n    - 0\n    - 0\n    - 0\n    - 1\n  cam2ego_R:\n    - 0.034896920649101944\n    - 0.015135626613007833\n    - 0.99927629698862219\n    - -0.99939075949347744\n    - 0.0010902662284327418\n    - 0.034884404167777945\n    - -0.00056147988681672133\n    - -0.99988485586850695\n    - 0.015164452300128389\n  cam2ego_t:\n    - 1.84679730821996\n    - -0.089090448031248784\n    - 1.3980633087528846\n```\n","tags":["YAML"],"categories":["Program"]},{"title":"samba","url":"/2022/03/18/samba/","content":"\n## install\n\n```sh\nsudo apt-get install samba\n\n```\n\n## config\n\n```\nsudo vim /etc/samba/smb.conf\n\n[share]\n     path = /home/jiaxiyang/share\n     available = yes\n     valid users = jiaxiyang\n     read only = no\n     browsable = yes\n     public = yes\n     writable = yes\n```\n\n## add user\n\n```\nsudo smbpasswd -a jiaxiyang\n```\n\n## restart\n\n### ubuntu\n\n```\nsudo /etc/init.d/samba restart\nsudo /etc/init.d/smbd restart\n```\n\n### centos\n\n```\nsudo systemctl start smb.service\nsudo systemctl restart smb\n```\n\n## link\n\n### ubuntu\n\n```\nsudo mount.cifs //10.10.0.61/jiaxiyang/ samba_16 -o user=jiaxiyang\n```\n\n### windows\n\n```\n映射网络驱动器\n\\\\ipaddr\\share\nNOTE: share is [share] in smb.conf\n```\n"},{"title":"Cuda","url":"/2022/03/10/Cuda/","content":"\n## Note\n\n1. CUDA 流表示一个 GPU 操作队列，该队列中的操作将以添加到流中的先后顺序而依次执行。\n1. stream 作用：在 Stream 的帮助下，CUDA 程序可以有效地将内存读取和数值运算并行，从而提升数据的吞吐量。 [link](https://zhuanlan.zhihu.com/p/51402722)\n   由于 GPU 和 CPU 不能直接读取对方的内存，CUDA 程序一般会有一下三个步骤：1）将数据从 CPU 内存转移到 GPU 内存，2）GPU 进行运算并将结果保存在 GPU 内存，3）将结果从 GPU 内存拷贝到 CPU 内存。\n1. cuda7 可以开启每个线程有一个默认 stream, 之前每个设备有一个 stream [gpu-pro-tip-cuda-7-streams-simplify-concurrency/](https://developer.nvidia.com/zh-cn/blog/gpu-pro-tip-cuda-7-streams-simplify-concurrency/)\n1. GPU 函数耗时统计不能只记录一次的，GPU 可能做一些准备工作，教训： nppiResize_8u_C3R 不管大小第一次运行耗时都很大 The cuda context is lazily initialized\n1. unified memory cpu 访问时需要同一个线程。不同线程会 bus error。\n\n## cuda grammer\n\n1. `<<< M , T >>>` Which indicate that a kernel launches with a grid of M thread blocks. Each thread block has T parallel threads.\n1. `vectorAdd<<<blocksPerGrid, threadsPerBlock>>>`\n1. 可以认为 M, T 对应图片的 H, W; 一个 thread 对应一个像素点；一个 block 对应一行，一个 grid 对应一张图片\n1. `int tid = blockIdx.x * blockDim.x + threadIdx.x; => int index = h * W + w;`\n\n## cuda info\n\n1. [查看 cuda core](https://linuxconfig.org/how-to-get-cuda-cores-count-on-linux)\n   `cd /usr/local/cuda-11.4/samples/1_Utilities/deviceQuery && make && ./deviceQuery`\n1. bandwith test\n   `cd /usr/local/cuda-11.4/samples/1_Utilities/bandwidthTest && make && ./bandwidthTest`\n\n## samples\n\n1. [hello world](https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/)\n1. `/usr/local/cuda-11.4/samples` tree -L 2\n1. `/usr/local/cuda-10.2/samples/0_Simple/vectorAdd`\n1. `nvprof ./vectorAdd` 查看 kenerl 耗时\n\n## profiling\n\n1. `nvprof`\n1. nsight: `nsys profile`\n\n## link\n\n1. [Unified Memory for CUDA Beginners](https://developer.nvidia.com/blog/unified-memory-cuda-beginners/)\n1. [Maximizing Unified Memory Performance in CUDA](https://developer.nvidia.com/blog/maximizing-unified-memory-performance-cuda/)\n","tags":["Cuda"],"categories":["Program","Cuda"]},{"title":"Doxygen","url":"/2022/03/03/Doxygen/","content":"\n## base\n\n1. markdown 添加 [toc] 为 html 生成目录\n1. 参考 opencv\n1. [multi projects](https://stackoverflow.com/a/57979732)\n1. 可以用 cmake 生成 doxygen 配置 [link](https://github.com/opencv/opencv/blob/17234f82d025e3bbfbf611089637e5aa2038e7b8/doc/Doxyfile.in)\n1. [templates](https://github.com/doxygen/doxygen/tree/master/templates)\n\n## theme\n\n1. [doxygen-awesome-css](https://github.com/jothepro/doxygen-awesome-css)\n1. [效果](https://jothepro.github.io/doxygen-awesome-css/index.html)\n\n## doxygen config\n\n1. `sudo apt install doxygen`\n1. `doxygen -g <config-name>` 产生配置文件，默认为 Doxyfile `-s` 生成不带注释的配置文件\n1. `doxygen <config-name>` 生成文档\n1. UML 生成 svg 图片\n1. 生成 UML, 需要修改配置文件, 以下改为 YES\n\n```\nRECURSIVE\nHAVE_DOT\nUML_LOOK\nEXTRACT_ALL\n```\n\n1. `INLINE_SOURCES`标签。如果设置为 YES，可以将源代码直接包含到文档中。\n1. `OUTPUT_LANGUAGE` = 改为 Chinese\n1. `HTML_TIMESTAMP`标签设置为 YES，则每个生成的 HTML 页面的页脚将包含生成页面的日期和时间。将此设置为“是”有助于显示上次运行 doxygen 的时间，从而显示文档是否最新。\n1. `GENERATE_TREEVIEW` 标签用于指定是否应生成树状索引结构以显示分层信息。\n1. `PROJECT_NAME`\n1. `PROJECT_NUMBER`\n1. `PROJECT_LOGO` 首页左侧图标\n1. `EXTRACT_STATIC` 如果设置为 YES，一个文件的所有静态成员都将包含在文档中。\n1. `EXTRACT_PRIVATE` 如果设置为 YES，一个类的所有私有成员都将包含在文档中。\n1. `IMAGE_PATH` 修复 markdown 生成网页时 doc 出错问题\n1. `INPUT` 标签是输入的源码文件的目录, 空格分开 例如： `INPUT = README.md include/pg`\n1. 输出 color [link](https://github.com/jothepro/doxygen-awesome-css/blob/main/docs/customization.md#doxygen-generator)\n\n```sh\nHTML_COLORSTYLE_HUE    = 209\nHTML_COLORSTYLE_SAT    = 255\nHTML_COLORSTYLE_GAMMA  = 113\n```\n\n## pdf\n\n1. `sudo apt-get install texlive-full texlive-latex-base` [link](https://tex.stackexchange.com/a/481681)\n1. `cd latex && make`\n1. `doxygen -w latex header.tex footer.tex doxygen.sty` 先生成默认配置，修改 doxygen.config 指定`LATEX_HEADER = header.tex` [link](https://stackoverflow.com/a/16222657)\n1. 修改 refman.tex 来改变 pdf 生成\n1. `sed -i \"s/Doxygen/xx xx/\" refman.tex`修改制作者名字\n1. 中文问题 `\\begin{CJK}{UTF8}` 换成 `\\begin{CJK}{gbsn}` [link](https://www.cnblogs.com/zyl910/archive/2013/06/02/doxygen_pdf_chinese.html)\n1. 空页问题： `COMPACT_LATEX` to YES\n1. 换页问题： `\\doxysection` 之前加 `\\newpage`\n1. refman.tex 处理\n\n```sh\nsed -i \"/fancyfoot/d\" latex/refman.tex\nsed -i \"/fancyhead/d\" latex/refman.tex\nsed -i '/{fancyplain}/a\\\\\\cfoot{\\\\thepage}' latex/refman.tex\nsed -i '/{fancyplain}/a\\\\\\rhead{}' latex/refman.tex\nsed -i '/{fancyplain}/a\\\\\\lhead{}' latex/refman.tex\nsed -i '/doxysection/i\\\\\\newpage' latex/refman.tex\nsed -i \"s/Doxygen 1.8.17/PhiGent Robotics/\" latex/refman.tex\nsed -i \"s/{min}/{gbsn}/\" latex/refman.tex\n```\n\n1. `\\pagestyle{fancyplain}` 删除之后页眉页脚不再有横杠 `\\pagestyle{plain}`\n\n## notes\n\n1. 不要在有 build 的目录下\n1. 如果想生成详细的 UML 图，需要设置`EXTRACT_STATIC` `EXTRACT_PRIVATE`为 YES\n\n## 文档解析\n\n1. Class Hierarchy 可以查看类层级关系\n\n## links\n\n1. [fossies doxygen lists](https://fossies.org/dox/all.html)\n1. [getting start](https://www.doxygen.nl/manual/starting.html)\n1. [参数详解](https://www.guyuehome.com/35640)\n1. [使用 doxygen 的项目](https://doxygen.nl/projects.html)\n1. [deepstream doxygen](https://docs.nvidia.com/metropolis/deepstream/sdk-api/index.html)\n1. [ion](https://google.github.io/ion/base_2logging_8h.html)\n1. [opencv tutorial](https://docs.opencv.org/4.x/d9/df8/tutorial_root.html)\n1. [opencv config](https://github.com/opencv/opencv/blob/17234f82d025e3bbfbf611089637e5aa2038e7b8/doc/Doxyfile.in)\n1. [templates](https://github.com/doxygen/doxygen/tree/master/templates)\n","tags":["Doxygen"],"categories":["Program"]},{"title":"UML","url":"/2022/03/03/UML/","content":"\n## UML 介绍\n\n1. [历史](https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/)\n1. 图表可大致分为结构性图表和行为性图表两种。结构性图表显示了系统在不同抽象层次和实现层次上的静态结构以及它们之间的相互关系。结构性图表中的元素表示系统中具意义的概念，可能包括抽象的、现实的和實作的概念。\n1. 结构性图表有七种类型：\n   - 类图 (Class Diagram)\n   - 组件图 (Component Diagram)\n   - 部署图 (Deployment Diagram)\n   - 对象图 (Object Diagram)-\n   - 包图 (Package Diagram)\n   - 复合结构图 (Composite Structure Diagram)\n   - 轮廓图 (Profile Diagram)\n1. 行为性图表显示了系统中对象的动态行为 ，可用以表达系统随时间的变化。行为性图表有七种类型：\n   - 用例图 (Use Case Diagram)\n   - 活动图 (Activity Diagram)\n   - 状态机图 (State Machine Diagram)\n   - 序列图 (Sequence Diagram)\n   - 通訊圖 (Communication Diagram)\n   - 交互概述图 (Interaction Overview Diagram)\n   - 时间图 (Timing Diagram)\n\n## 图种类\n\n1. class diagram 类图\n2. sequence diagram 时序图\n3. flow chart 流程图\n\n### class diagram\n\n### [sequence diagram](https://www.woshipm.com/ucd/607593.html)\n\n#### 关系\n\n![关系](https://pica.zhimg.com/v2-941a070601f399d992125ef31261637e_1440w.jpg?source=172ae18b)\n\n<!-- prettier-ignore -->\n| 名字     | 图形                     | 说明                                 | 其他                                                                               |\n|:---------|:-------------------------|:-------------------------------------|:-----------------------------------------------------------------------------------|\n| 实现关系 | 空心三角和虚线组成的箭头 | 实现类指向接口                       | 类似 rust trait                                                                    |\n| 泛化关系 | 空心三角和实线组成的箭头 | 从子类指向父类                       | \"is a\"                                                                             |\n| 关联关系 | 带箭头的实线             | 指向被关联的对象                     | 一个对象含有另一个对象的引用                                                       |\n| 依赖关系 | 带虚线的箭头             | 使用方指向被使用方                   | \"use a\", 弱关联关系,<br>构造器或方法中的局部变量、方法或构造器的参数、方法的返回值 |\n| 聚合关系 | 空心菱形加实线箭头       | 空心菱形在整体一方，箭头指向部分一方 | \"has a\", 具有各自的生命周期                                                        |\n| 组合关系 | 实心菱形加实线箭头       | 实心菱形在整体一方，箭头指向部分一方 | \"contains a\" 强聚合, 作为整体的对象负责部分的对象的生命周期                        |\n\n<!-- prettier-ignore -->\n## mermaid\n\n## [mermaid](https://github.com/mermaid-js/mermaid)\n\n1. [在线 server](https://mermaid.live/)\n1. [cheat sheet](https://jojozhuang.github.io/tutorial/mermaid-cheat-sheet/)\n1. markdown 支持\n1. theme `%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#ffcccc', 'edgeLabelBackground':'#ffffee', 'tertiaryColor': '#fff0f0', 'fontFamily': 'verdana'}}}%%`\n1. [theming](https://mermaid-js.github.io/mermaid/#/theming)\n1. 可以用 graph 画关系图[bitcoin sample](https://github.com/bitcoin/bitcoin/blob/master/doc/design/libraries.md#L36)\n1. gatte 图也好用\n1. github 用 chrome 插件[markdown-diagrams](https://chrome.google.com/webstore/detail/markdown-diagrams/pmoglnmodacnbbofbgcagndelmgaclel)可以生成图片, 密集图片截屏效果不好\n1. `%%{init: {'securityLevel': 'loose', 'theme':'base'}}%%` 设置主题\n1. `%%{init:{\"themeVariables\": { \"fontSize\": \"30px\" }}}%%` 设置字体大小\n1. `%%{init:{'theme':'neutral', \"themeVariables\": { \"fontSize\": \"20px\" }}}%%`\n1. [字体设置只支持几种图，其他不支持](https://github.com/mermaid-js/mermaid/issues/3033)\n1. sequence\n\n```mermaid\n{% mermaid sequenceDiagram %}\nAlice->>John: Hello John, how are you?\nloop Healthcheck\n    John->>John: Fight against hypochondria\nend\nNote right of John: Rational thoughts!\nJohn-->>Alice: Great!\nJohn->>Bob: How about you?\nBob-->>John: Jolly good!\n{% endmermaid %}\n```\n\n1. flow chart 支持 [fontawesome](https://fontawesome.com/icons)\n\n```mermaid\nclassDiagram\n    user ..> image\n    image ..> MediaProc\n    MediaProc <|-- ImgProcImpl\n    ImgProcImpl ..> ImageFrame : 代理\n    ImageFrame <|-- ImageFrameImpl\n    ImageFrameImpl <|-- BpuImageFrame\n\n    class MediaProc{\n      <<interface>>\n      +Crop()\n      +Resize()\n      +CvtColor()\n      +Decode()\n      +Encode()\n    }\n\n    class ImgProcImpl{\n      +Crop()\n      +Resize()\n      +CvtColor()\n      +Decode()\n      +Encode()\n    }\n\n    class ImageFrame{\n      <<interface>>\n      +Crop()\n      +Resize()\n      +CvtColor()\n    }\n\n    class ImageFrameImpl{\n      +Crop()\n      +Resize()\n      +CvtColor()\n    }\n\n    class BpuImageFrame{\n      +Crop()\n      +Resize()\n      +CvtColor()\n    }\n\n```\n\n1. samples\n   - [fastapi](https://github.com/tiangolo/fastapi/blob/master/docs/en/docs/tutorial/dependencies/dependencies-with-yield.md#dependencies-with-yield-and-httpexception)\n   - [三次握手 config 中有中文支持](https://mermaid.live/edit#pako:eNqdVFFr01AU_iuX-6QYW9vabuvDQLoNYVKGKYIaH26Tk-ZCkhtvbqe1FMQndZsOhogwNycMBWHTFwU39M_YrG_-BW9605rNZk7zkNDvnPud85379XSxySzAVRzC3Tb4JsxR0uLEM3wkn4BwQU0aEF-gmkvBF3_iOvBl4ArnYArEW81zxXJZQ8VScfg6r4J1JgBx2nIEYnZCV0X9w4f9dyuoUVtC0fOd6MmKSlbhi7Ozir6q36yrADEFXSaSKd2PSpLZCavMvnCltnjiRLpTCyYSnSw7Jknlp2nAt04ql6Jj9X_TLQUrvUcHG9Hr7Z-Hq_311ejlZzWP_sHXow8rjWv64PtW9Gx3cnMJgK6C67J_mE4CqHMaqoG8TJua8piWhBahM3_fdIjfGkPD5DnmQwbn_8AZlzBx0hnij3VaG35rNHCA6wGYGlqgPg0dsDI4ToUzrvxsIz5eOEPoZPck_5tyOe0fF-yhfUYtSmsg5Q1lldg_Q-dELz5Ga3s_Dt8Mvm1kyJur6yja3h3svx3sf4k-PTpF18Ta0eZa_-lO_9V7RZLL5TKG8LtQbPKtzbMNY1iTxQZVYW1Ut7-3Gj1eT7EavjoxerCGPeAeoZZcaN04ZmDhgAcGlpeKbcYhFAbWUpEbhFPSdCGMU7qKLs70xQLxqNuJ4dujKgZuUA9CVId76DrziJ9wqZjO2twceoXaaIkzA6vYHS1Nq9MHSTuFQiBUTs_we7J30hZM7_gmrgreBg23A0sOKVnIuGoTNxyj8xYVjI9BlxEL5M8uFp0gXuctGgpJaTLfpq0Yb3NXwo4QQVjN5-NwrkWF027mTOblQ2o5cqc7yzOVfKVYmSbFElSmSqRcKllmszAzbRcvF2xr6lKhSHCvp2G5-m8xNuqq9ws-JjhZ)\n\n## [plantuml](https://github.com/plantuml/plantuml)\n\n1. [在线 server](http://www.plantuml.com/plantuml/uml/)\n1. [本地 plantuml-server](https://github.com/plantuml/plantuml-server)\n   - `docker run -d -p 10093:8080 plantuml/plantuml-server:jetty`\n   - `docker run -d -p 10093:8080 -e THE_ENV_VARIABLE=THE_ENV_VALUE plantuml/plantuml-server:jetty`\n1. [pdf guide](https://plantuml.com/zh/guide)\n1. [class](https://plantuml.com/zh/class-diagram)\n1. [时序图](https://plantuml.com/zh/sequence-diagram)\n1. [java-design-patterns](https://github.com/iluwatar/java-design-patterns)\n1. [puml config file demo](https://github.com/iluwatar/java-design-patterns/blob/master/factory-method/etc/factory-method.urm.puml)\n1. markdown gitlab github 不支持， 用[markdown-diagrams](https://chrome.google.com/webstore/detail/markdown-diagrams/pmoglnmodacnbbofbgcagndelmgaclel)来支持浏览器显示\n\n1. test plantuml\n\n```puml\n@startuml\nobject Object01\nobject Object02\nobject Object03\nobject Object04\nobject Object05\nobject Object06\nobject Object07\nobject Object08\n\nObject01 <|-- Object02\nObject03 *-- Object04\nObject05 o-- \"4\" Object06\nObject07 .. Object08 : some labels\n@enduml\n```\n\n## [dot language](https://graphviz.org/doc/info/lang.html)\n\n1. [dot 命令源码](https://gitlab.com/graphviz/graphviz/-/tree/main/cmd/dot)\n1. `sudo apt-get install graphviz`\n1. [维基介绍](https://zh.wikipedia.org/zh-cn/DOT%E8%AF%AD%E8%A8%80)\n1. [属性](https://itopic.org/graphviz.html)\n1. [samples](http://www.graphviz.org/gallery/)\n1. [Graphviz 使用教程](https://www.zywvvd.com/notes/tools/graphviz/graphviz/)\n1. sample\n\n```dot\ndigraph test123 {\n        pack=8\n        subgraph cluster0 {\n          packmode=array\n          x y x0 y0 x1\n          subgraph cluster1 {\n            m n\n          }\n        }\n        b [shape=box];\n        c [label=\"helloenworld\",color=blue,fontsize=24,\n             fontname=\"Palatino-Italic\",fontcolor=red,style=filled];\n        a -> z\n        x -> z\n        a -> b -> c;\n        a -> {x y};\n        edge [style=dashed,color=red];\n        b -> x;\n}\n```\n\n## doxygen 生成 UML\n\n## links\n\n1. [关系](https://www.cnblogs.com/shindo/p/5579191.html)\n1. [基于 SOME/IP 的 AP AUTOSAR 实战](https://www.51fusa.com/client/information/informationdetail/id/1561.html)\n1. [适合程序员的 UML 绘图工具](https://juejin.cn/post/6844904039902085134)\n","tags":["UML"],"categories":["Program"]},{"title":"Nvidia-NPP","url":"/2022/03/02/Nvidia-NPP/","content":"\n## notes\n\n1. need `sudo` to run exe\n1. `export CUDACXX=/usr/local/cuda/bin/nvcc` when build cuda\n1. CMakeLists.txt: `CUDA_ADD_EXECUTABLE(resize resize.cpp)`\n\n## yuyv 2 rgb\n\n1. [link](https://stackoverflow.com/a/71473363) nvcc 替换成 g++也可用\n\n## basic\n\n1. install path: `/usr/local/cuda-xxx/`\n1. [函数名称中简写的意义](https://docs.nvidia.com/cuda/npp/nppi_conventions_lb.html)\n1.\n\n```\n\"A\" if the image is a 4 channel image this indicates the result alpha channel is not affected by the primitive.\n\"Cn\" the image consists of n channel packed pixels, where n can be 1, 2, 3 or 4.\n\"Pn\" the image consists of n separate image planes, where n can be 1, 2, 3 or 4.\n\"C\" (following the channel information) indicates that the primitive only operates on one of the color channels, the \"channel-of-interest\". All other output channels are not affected by the primitive.\n\"I\" indicates that the primitive works \"in-place\". In this case the image-data pointer is usually named pSrcDst to indicate that the image data serves as source and destination at the same time.\n\"M\" indicates \"masked operation\". These types of primitives have an additional \"mask image\" as as input. Each pixel in the destination image corresponds to a pixel in the mask image. Only pixels with a corresponding non-zero mask pixel are being processed.\n\"R\" indicates the primitive operates only on a rectangular \"region-of-interest\" or \"ROI\". All ROI primitives take an additional input parameter of type NppiSize, which specifies the width and height of the rectangular region that the primitive should process. For details on how primitives operate on ROIs see: Region-of-Interest (ROI).\n\"Sfs\" indicates the result values are processed by fixed scaling and saturation before they're written out.\n```\n\n1. [image malloc functions](https://docs.nvidia.com/cuda/npp/nppi__support__functions_8h_source.html)\n1. [resize function](https://docs.nvidia.com/cuda/npp/nppi__geometry__transforms_8h_source.html)\n1. [npp utils](https://github.com/NVIDIA/cuda-samples/tree/master/Common/UtilNPP)\n1. [cvtcolor](https://docs.nvidia.com/cuda/npp/group__image__color__model__conversion.html)\n\n## samples\n\n1. [NVIDIA-CUDALibrarySamples](https://github.com/NVIDIA/CUDALibrarySamples.git)\n1. [simple sample](https://blog.51cto.com/u_15357586/3790330)\n1. [malloc sample](https://sourcegraph.com/github.com/PacktPublishing/Learn-CUDA-Programming/-/blob/Chapter08/08_cuda_libs_and_other_languages/05_npp/imageFilter.cpp)\n\n## Links\n\n1. [main page](https://docs.nvidia.com/cuda/npp/index.html)\n"},{"title":"Gitlab-CI","url":"/2022/02/15/Gitlab-CI/","content":"\n## badges\n\n1. 显示 build 状态\n1. [what-are-gitlab-badges](https://www.benjaminrancourt.ca/what-are-gitlab-badges/)\n\n## format check\n\n```shell\ncheck-format:\n  image:\n    name: witekio/clang-format-checker\n    entrypoint: [\"\"]\n  script:\n    - run-clang-format.py -r src\n```\n\n## [include](https://docs.gitlab.com/ee/ci/yaml/#includelocal)\n\n1. 可以 include local file, private project and remote file。\n\n## [release artifacts](https://gitlab.phigent.io/help/user/project/releases/index)\n\n1. [release-artifacts-using-gitlab-cicd](https://crypt.codemancers.com/posts/2021-08-31-release-artifacts-using-gitlab-cicd/#generating-the-artifacts)\n1. [gitlab release 和 artifactory 结合](https://gitlab.phigent.io/help/user/project/releases/index#use-a-generic-package-for-attaching-binaries)\n   - notes: 注意 tag-name， ci 跑完之后会打 tag，然后又会运行 ci, 总共会跑两次\n   - 不能缺少 tag-name， 使用 rules: - if: $CI_COMMIT_TAG, 只有打 tag 的时候才运行\n   - [401 error](https://kinsta.com/knowledgebase/401-error/)\n1. 删除 tag 就能删除 release 对应内容\n1. gitlab release comment 支持 markdown 和 mermaid\n\n## pipeline\n\n1. [trigger other pipeline](https://docs.gitlab.com/ee/ci/triggers/)\n1. 前面加 dot，可以隐藏 job [link](https://docs.gitlab.com/ee/ci/jobs/#hide-jobs)\n\n## [ssh](https://docs.gitlab.com/ee/ci/ssh_keys/)\n\n1. 区分多种执行方式：\n   - shell: 需要 runenr\n   - docker: 在 docker 下执行，不需要指定 runner\n   - ssh\n1. [example](https://gitlab.com/gitlab-examples/ssh-private-key/-/blob/master/.gitlab-ci.yml)\n1. [ssh-key 要求](https://gitlab.com/gitlab-examples/ssh-private-key/-/issues/1#note_48526556)\n1. 需要在 deploy 机器上生成 ssh， private key 作为变量传入配置中\n1. shell 需要在 runner 机器上秘钥对，把公钥复制到部署板子上 `ssh-copy-id -i ~/.ssh/id_rsa.pub xxx@xxx`\n\n## [runner](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section)\n\n1. 可以 reset token [link](https://docs.gitlab.com/runner/commands/#gitlab-runner-reset-token)\n1. gitlab repo ci 配置可以显示安装 runner 命令\n1. [commands](https://docs.gitlab.com/runner/commands/)\n1. `gitlab-ci-multi-runner list` list runners\n1. `gitlab-ci-multi-runner status`\n1. `/etc/gitlab-runner/` 配置路径\n1. 注册 project for runner:\n   - `gitlab-runner register`\n   - `gitlab-runner verify` 如果是感叹号执行这条命令\n   - `gitlab-runner unregister --name test-runner` 删除 runner\n1. 使用 [shared runner](https://docs.gitlab.com/ee/ci/runners/runners_scope.html):\n   - 需要 admin 用户\n   - group 下默认有\n1. Group runners:This project does not belong to a group and cannot make use of group runners. 只需要 group tocken 就好\n\n## script\n\n1. 所有 job 都执行\n\n```\ndefault:\n  before_script:\n    - echo \"Execute this script in all jobs that don't already have a before_script section.\"\n\njob1:\n  script:\n    - echo \"This script executes after the global before_script.\"\n\njob:\n  before_script:\n    - echo \"Execute this script instead of the global before_script.\"\n  script:\n    - echo \"This script executes after the job's `before_script`\"\n```\n\n## deploy\n\n1. `sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r ./build $CUSTOM_USERNAME@$CUSTOM_IP:/var/www/html` sshpass 设置 ci 变量\n1. `sshpass -p $PASSWORD sshpass -p root rsync -avz -e \"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\" -r ./build $CUSTOM_USERNAME@$CUSTOM_IP:/var/www/html`\n\n## prefill variables\n\n1. [how to use prefill variables](https://gitlab.com/gitlab-org/gitlab/-/issues/300106)\n1. 两种方式：\n   - yml 文件中\n   ```yaml\n   variables:\n   PASSWORD:\n     value: \"123456\"\n     pdescription: \"password\"\n   CUSTOM_USERNAME:\n     value: \"petalinux\"\n     description: \"username\"\n   ```\n   - project CI/CD variable settings\n\n## [workflow](https://docs.gitlab.com/14.8/ee/ci/yaml/workflow.html)\n\n## keys\n\n### needs\n\n1. 可以用来串联 stage\n1. 传递 stage 文件需要 [link](https://docs.gitlab.com/ee/ci/yaml/index.html#needsartifacts)\n1. 可以看 pipeline efficiency [link](https://docs.gitlab.com/ee/ci/pipelines/pipeline_efficiency.html)\n1. [DAG](https://docs.gitlab.com/ee/ci/directed_acyclic_graph/)\n\n## rules\n\n1. [rules 模板](https://github.com/gitlabhq/gitlabhq/blob/2ea638391497c495798e0bab7c704af112789299/.gitlab/ci/rules.gitlab-ci.yml)\n1. 只手动编译， 有个按键可以执行所有 job\n\n```yaml\n.rules:if-tag-or-manual:\n  rules:\n    - <<: *if-tag\n    - when: manual\n\n.rules:always:\n  rules:\n    - when: always\n      allow_failure: true\n\n## fix mr detach issue\nworkflow:\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n      when: never\n    - when: always\n\nstages:\n- build\n- test\n\nBuild::GPU_ubuntu20.04:\n  extends:\n    .rules:if-tag-or-manual\n\n```\n\n1. 在 mr 时自动运行全流程，or 手动选择要编译的平台\n\n```yaml\n\n.if-tag: &if-tag\n  if: '$CI_COMMIT_TAG'\n\n.if-merge-request: &if-merge-request\n  if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n\n.if-tag-or-mr: &if-tag-or-mr\n  if: '$CI_COMMIT_TAG'\n  if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n\n.rules:if-tag-or-mr-or-manual:\n  rules:\n    - <<: *if-tag-or-mr\n    - when: manual\n\n.rules:always:\n  rules:\n    - when: always\n\nstages:\n- build\n- test\n\nBuild::GPU_ubuntu20.04:\n  extends:\n    .rules:if-tag-or-mr-or-manual\n\nBuild::Vitis:\n  extends:\n    .rules:if-tag-or-mr-or-manual\n\n```\n\n1. [workflowrules 控制整个 pipeline](https://docs.gitlab.com/ee/ci/yaml/#workflowrules)\n\n```yaml\nworkflow:\n  rules:\n    - if: $CI_COMMIT_TITLE =~ /-draft$/\n      when: never\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n```\n\n1. when, can only be always or never when used with workflow. 不能 when: manual, 不支持\n1. 可以设置一个伪 job， manual 触发，后续 job 依赖伪 job\n1. 完善解决方案： 使用 [temlate](https://github.com/GNOME/gnome-shell/blob/4bbf6d497d34793693e5ac24fbe23854b481002b/.gitlab-ci.yml#L41)\n1. [avoid-duplicate-pipelines](https://docs.gitlab.com/ee/ci/jobs/job_control.html#avoid-duplicate-pipelines)\n\n```\n rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n```\n\n1. [default-rules(>=14.3)](https://docs.gitlab.com/ee/ci/jobs/job_control.html#reuse-rules-in-different-jobs)\n\n## Notes\n\n1. [split-long-commands](https://docs.gitlab.com/ee/ci/yaml/script.html#split-long-commands)\n1. gtest 结果 xml 可以显示到 ci pipeline 结果中去 [link](https://docs.gitlab.com/ee/ci/unit_test_reports.html)\n\n```yaml\nstages:\n  - test\n\ncpp:\n  stage: test\n  script:\n    - ./gtxxx --gtest_output=xml:report.xml\n\n  artifacts:\n    when: always\n    reports:\n      junit:\n        - report.xml\n        - fail.xml\n```\n\n1. cache 时相同的 Key path 文件内容要完全一样，否则不能 cache\n1. deploy 两种方式：\n   - runner shell Executor: 交叉编译后传到板子上执行\n   - runner ssh Executor: 登录到板子，Mount 服务器执行(板子存储受限，不可重复，慢)\n1. `sudo su - gitlab-runner` ssh board 时要进入 runner 服务器 gitlab-runner 用户\n1. 如果想在板子上运行脚本，需要 ssh 执行器[link](https://blog.csdn.net/lihao21/article/details/109820904)\n1. ssh 后跟在远端执行的命令\n\n```\nscript:\n    - echo \"ssh board......................\"\n    - ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@10.31.1.170 \"whoami\"\n```\n\n1. [修改 runner build 位置 builds_dir](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section) 配置路径`/etc/gitlab-runner/`或`~/.gitlab-runner/`\n\n## Links\n\n1. [Gitlab-ci:从零开始的前端自动化部署](https://zhuanlan.zhihu.com/p/184936276)\n1. [GitLab CI/CD](https://docs.gitlab.com/ee/ci/)\n1. [Enable Debug logging](https://docs.gitlab.com/ee/ci/variables/index.html#enable-debug-logging)\n1. [List all environment variables](https://docs.gitlab.com/ee/ci/variables/index.html#list-all-environment-variables)\n1. [CI/CD templates](https://docs.gitlab.com/ee/ci/examples/#cicd-templates)\n1. [Using SSH keys with GitLab CI/CD](https://docs.gitlab.com/ee/ci/ssh_keys/)\n1. [概念](https://segmentfault.com/a/1190000006120164)\n1. [gitlab 中文文档](https://docs.gitlab.cn/jh/ci/variables/)\n1. [test reports](https://gitlab.phigent.io/help/ci/unit_test_reports)\n1. [搭建一个使用 GitLab CI 的项目](https://juejin.cn/post/6847902219837292558)\n1. [Gitlab-Runner 原理与实现](https://blog.csdn.net/yejingtao703/article/details/83065591)\n\n## samples\n\n1. gitlab release + jfrog artifactory（如果 docker 有问题，通过 artifacts 传递文件， 在 release 传文件和配置链接）\n\n```yaml\nstages:\n  - build\n  - release\n\nvariables:\n  TEST_FILE0: \"test0-${PACKAGE_VERSION}-${CI_COMMIT_TAG}\"\n  TEST_FILE1: \"test1-${PACKAGE_VERSION}-${CI_COMMIT_TAG}\"\n  PACKAGE_VERSION: \"1.2.3\"\n  PACKAGE_REGISTRY_URL: \"http://artifacts.xxx.io/artifactory/dcv-cpp\"\n\ndefault:\n  before_script:\n    - JFROG_USER=release\n    - JFROG_PASSWD=xxx\n    - |\n      push_to_jfrog() {\n          FILE=$1;\n          JFROG_PATH=http://artifacts.xxx.io/artifactory/$2;\n          MD5=$(md5sum $FILE | awk '{print $1}');\n          curl -u\"${JFROG_USER}:${JFROG_PASSWD}\" -T $FILE -H \"X-Checksum-MD5:${MD5}\" -L \"${JFROG_PATH}\";\n      }\n\nbuild:\n  stage: build\n  image: hub.xxx.io/avp/cuda11.3.1-trt8.0.3.4-ros2-desktop-ubuntu20.04:v2.0\n  tags:\n    - phigent_runner_gpu\n  script:\n    - echo $CI_COMMIT_TAG\n    - mkdir bin\n    - echo \"${TEST_FILE0}\" > bin/${TEST_FILE0}\n    - echo \"${TEST_FILE1}\" > bin/${TEST_FILE1}\n    - |\n      if [ \"$CI_COMMIT_TAG\" != '' ]; then\n        push_to_jfrog bin/${TEST_FILE0} dcv-cpp/${CI_COMMIT_TAG}/${TEST_FILE0}\n        push_to_jfrog bin/${TEST_FILE1} dcv-cpp/${CI_COMMIT_TAG}/${TEST_FILE1}; fi\n\nrelease:\n  tags:\n    - phigent_runner_gpu\n  stage: release\n  image: registry.gitlab.com/gitlab-org/release-cli:latest\n  rules:\n    - if: $CI_COMMIT_TAG\n  script:\n    - |\n      release-cli create --name \"Release $CI_COMMIT_TAG\" --tag-name $CI_COMMIT_TAG \\\n        --assets-link \"{\\\"name\\\":\\\"${TEST_FILE0}\\\",\\\"url\\\":\\\"${PACKAGE_REGISTRY_URL}/${CI_COMMIT_TAG}/${TEST_FILE0}\\\"}\" \\\n        --assets-link \"{\\\"name\\\":\\\"${TEST_FILE1}\\\",\\\"url\\\":\\\"${PACKAGE_REGISTRY_URL}/${CI_COMMIT_TAG}/${TEST_FILE1}\\\"}\"\n```\n","tags":["Tools","CI"],"categories":["Tools","CI"]},{"title":"Image Process","url":"/2022/02/05/image_process/","content":"\n## 工具\n\n1. 7yuv 可以直接显示二进制格式图片 图片命名为 xxxx_960_576.yuv, 可以直接打开不用再输入尺寸\n\n## 视差图与深度图\n\n### 视差图\n\n1. [原理](https://blog.csdn.net/ppdyhappy/article/details/113618409)\n\n### 深度图\n\n### 视差图转深度图\n\n1. 公式: `depth[i] = f * b / disp[i]; ` f 为焦距，b 为基线\n1. [视差转深度](https://blog.nowcoder.net/n/947d9e8e6e3d41aa95d25e2daa9d14f6?from=nowcoder_improve)\n\n```\n#include <iostream>\n\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\nusing namespace std;\nusing namespace cv;\n\nconst double fx = 6.9972691554787775e+02;\nconst double baseline = 1 / 4.9899299400374328;\n\nint main(int argc, char** argv) {\n  Mat img = imread(\"disparity.png\", 0);\n  cout << img.type() << endl;\n  cout << \"fx: \" << fx << endl;\n  cout << \"baseline: \" << baseline << endl;\n  Mat depth(img.rows, img.cols, CV_32F);  //深度图\n  cout << depth.type() << endl;\n  //视差图转深度图\n  for (int row = 0; row < depth.rows; row++) {\n    for (int col = 0; col < depth.cols; col++) {\n      float d = img.ptr<uchar>(row)[col];\n\n      if (d == 0) continue;\n\n      depth.ptr<float>(row)[col] = fx * baseline / d;\n    }\n  }\n  imwrite(\"depth.png\", depth);\n  // Mat depth_8u1 = depth.clone();\n  Mat depth_8u1;\n  depth.convertTo(depth_8u1, CV_8U);\n  Mat color_mat;\n  applyColorMap(depth_8u1, color_mat, COLORMAP_TURBO);\n  imwrite(\"color_depth.png\", color_mat);\n}\n\n```\n\n## opencv 函数\n\n1. `.convert`类型转换 `depth.convertTo(depth_8u1, CV_8U);`\n1. `applyColorMap` 灰度图转彩色(深度彩色输出) `applyColorMap(depth_8u1, color_mat, COLORMAP_TURBO);`\n1. 获取 cv::Mat 矩阵元素 ` mat.ptr<float>(row)[col] = camera_f * camera_b / d;`\n\n## vector to rgb jpg\n\n```\n    std::vector<char> source_out(w * h * 3)\n    cv::Mat img(h, w, CV_8UC3);\n    for (unsigned int row_ind = 0; row_ind < h; ++row_ind) {\n      for (unsigned int col_ind = 0; col_ind < w; ++col_ind) {\n        img.at<cv::Vec3b>(row_ind, col_ind) =\n            cv::Vec3b(source_out[(row_ind * w + col_ind) * 3 + 2],\n                      source_out[(row_ind * w + col_ind) * 3 + 1],\n                      source_out[(row_ind * w + col_ind) * 3 + 0]);\n      }\n    }\n    cv::imwrite(\"output.jpg\", img);\n```\n\n## opencv 多张图片同事显示\n\n1. [OpenCV 一个窗口同时显示多张图片](https://python.iitter.com/other/302393.html)\n\n```\nstatic cv::Mat concat_images(std::vector<cv::Mat> imgs) {\n  using namespace cv;\n  const int MAX_PIXEL = 540;\n  int imgs_num = imgs.size();\n  auto sqrt_value = std::sqrt(imgs_num);\n  Size first_img_size = imgs[0].size();\n  int max_pixel = std::max(first_img_size.height, first_img_size.width);\n  double prop = max_pixel < MAX_PIXEL ? (double)max_pixel / (double)MAX_PIXEL\n                                      : (double)MAX_PIXEL / (double)max_pixel;\n  Size std_size(first_img_size.width * prop, first_img_size.height * prop);\n  VLOG(1) << \"std size: \" << std_size;\n\n  int img_cols = (sqrt_value - (int)sqrt_value == 0.0)\n                     ? std::floor(sqrt_value)\n                     : std::floor(sqrt_value) + 1;\n  VLOG(1) << \"img_cols:  \" << img_cols;\n  Mat tmp_img;\n  Point2i location(0, 0);\n  Mat result(std_size.height * ((imgs_num - 1) / img_cols + 1),\n             std_size.width * img_cols, imgs[0].type());\n  VLOG(1) << \"concat image size: \" << result.size();\n  for (int i = 0; i < imgs_num; i++) {\n    location.x = (i % img_cols) * std_size.width;\n    location.y = (i / img_cols) * std_size.height;\n    resize(imgs[i], tmp_img, std_size, prop, prop, INTER_LINEAR);\n    tmp_img.copyTo(result(Rect(location, std_size)));\n  }\n  return result;\n}\n\n```\n\n## 双线性 resize\n\n1. [示意图](https://excalidraw.com/#json=eOxeValvEDgQU1IrMOjU_,arZv-AnyFoupAOXfEKY1-w)\n2. [双线性插值算法（C++实现）](https://www.freesion.com/article/6921829775/)\n","tags":["Algorithm"],"categories":["Algorithm"]},{"title":"Debug","url":"/2022/02/03/Cpp-debug/","content":"\n## NOTE\n\n1. 没 link 报`undefined reference to`, link 但没 found `target was not found`\n1. 二进制依赖时， 需要先 find_package(glog REQUIRED), 否则\n   - op PRIVATE 依赖 glog: undefined reference to 错误, 未传递出 glog 依赖 （静态链接的可以 PRIVATE 依赖)\n   - op PUBLIC 依赖 glog: target was not found 错误, 传递出 glog 依赖\n1. `gcc/g++  --verbose`显示编译过程\n1. strip 是一个在 Unix-like 操作系统中用于删除或剥离目标文件或对象文件的符号信息的工具。\n   - 删除符号表信息：符号表包含了源代码中的函数和变量的名称。\n   - 删除调试信息：debug section 被删除\n1. function tracing 只需要 symbols，不需要 debug symbols（gcc -g）。strip 之后不能跟踪\n1. 动态符号（.dynsym）vs. 局部符号（.symtab）， .symtab 包含.dynsym; 可以用命令 strip 来手动去掉局部符号表， strip 前后用`readelf -s ./test`看, strip 只去除了.symtab\n1. strip 之后 gdb 不能使用 function 名字加断点\n1. debug info 作用：\n   - 将内存地址映射到具体某行源代码\n   - 调用栈展开（stack unwinding）\n1. 在 C++中，如果函数有指定返回类型，但在实际代码中没有返回值或者在所有路径上都没有返回值，那么它的行为是未定义的（Undefined Behavior）。根据 C++标准，未定义的行为可能导致任何结果，包括程序崩溃、生成错误的结果或者在某些情况下看起来像是“正常工作”。\n1. `addr2line`其功能是将函数地址解析成文件名或行号的工具。 [addr2line debug](https://cloud.tencent.com/developer/article/1974629)\n1. 查看 debug 模式：gdb `l` and `info source`\n1. `-DCMAKE_BUILD_TYPE=RelWithDebInfo` release 模式编译，带 debug info\n1. `-DCMAKE_CXX_FLAGS=\"-g\"` cmake 编译选项添加 debug info； release 模式也适用\n1. gcc 选项顺序很重要，如果两个选项冲突，则以后一个为准。可以用`-O3 -fno-inline-functions`既使用-O3 的功能又关闭函数内嵌功能。\n\n<!-- more -->\n\n1. 踩内存就指访问了不应该访问的内存地址\n1. 火焰图可以看调用关系\n1. multidefination 可能是在头文件中定义了函数，多个文件 include 函数, 导致多重定义\n1. segmantation fault 和 bus error 均是内存地址访问导致的问题，\n   - segmantation fault 是写了只读区域或访问了不能访问区域\n   - bus error 是访问地址未对齐\n1. `调试要用 debug 模式，性能测试用 release`\n1. crash 排查:\n   - 引用空指针\n   - 使用未初始化的内存\n   - 释放后使用，也就是使用悬垂指针\n   - 缓冲区溢出，比如数组越界\n   - 非法释放已经释放过的或者未分配的指针\n1. static 变量编译顺序，sample: dmlc 注册后处理函数时，如果注册分布在不同文件，需要先声明全局 static 变量后才能 register。 声明文件要在注册文件前执行。解决方法：专门找一个文件，先声明，后注册。\n1. debug 是编译 -DCMAKE_BUILD_TYPE=Debug， 否则 gdb 显示信息不全\n1. export LD_LIBRARY_PATH=xxxx:xxxx:xxx:$LD_LIBRARY_PATH, $LD_LIBRARY_PATH 放后面，否则容易链接到其他版本库\n1. 因为 assert 是一种 debug 工具，而 release 不是 debug，所以不启用。\n1. `NDEBUG` 这个编译宏可以控制是否启用 assert，如果定义了就不会执行\n1. debug 模式 assert 会出错， release 无问题，因为 assert 不起作用 [link](https://murphypei.github.io/blog/2020/01/assert-debug-release)\n\n```c++\nfor (i = 0; i < 100; ++i) {\n  int status = do_something ();\n  assert (status == 0);\n}\n\n// 不要写成这样\nfor (i = 0; i < 100; ++i)\n  assert (do_something () == 0);\n```\n\n## 未定义的行为\n\n1. 行为\n   - 在函数中遗漏返回语句（如果函数声明了返回类型）\n   - 读取或写入非法的内存地址\n   - 整数除以零\n   - 整数溢出\n   - 对 null 指针进行解引用\n   - 对已经释放的内存进行操作\n1. 结果\n   - 程序崩溃\n   - 程序正常运行，但生成错误的结果\n   - 程序看似正常运行，但在后台有潜在的错误或安全问题\n   - 在不同的编译器、不同的平台或不同的编译器优化级别下，有不同的行为\n\n## debug 和 releae 模式行为不一致\n\nC++在 Debug 和 Release 模式下运行不一致，可能由多种原因造成。以下是一些常见的原因：\n\n1. **未初始化的变量**：在 Debug 模式下，一些编译器会自动初始化变量（如将指针设置为 null 或整数设置为零），但在 Release 模式下，编译器通常不会这么做。如果你的代码依赖于这些自动初始化的行为，那么在 Release 模式下可能会出现问题。\n2. **内存越界访问**：Debug 模式通常包含额外的内存检查，例如检测数组越界访问。然而，Release 模式为了提高性能，通常不包含这些检查。如果你的代码中存在内存越界访问，可能在 Debug 模式下不会出现问题，但在 Release 模式下会导致各种未定义行为。\n3. **断言（assert）语句**：断言在 Debug 模式下是启用的，可以帮助找出不满足预期条件的情况。但在 Release 模式下，为了提高性能，通常会禁用断言。因此，一些在 Debug 模式下由于断言而被发现的问题，在 Release 模式下可能会被忽视。\n4. **优化**：Release 模式通常会开启更多的编译优化。这些优化有时可能会暴露出在 Debug 模式下不会出现的问题，特别是当代码包含未定义行为或者对于优化的假设不正确时。\n5. **多线程竞态条件**：在 Debug 模式下，线程的调度和执行速度可能与 Release 模式有所不同。如果代码中存在依赖于特定线程执行顺序的竞态条件，这种条件在 Debug 模式下可能永远不会出现，但在 Release 模式下就可能出现。\n   要解决这种问题，首先需要确定问题出现的具体位置。然后，检查是否存在上述问题，如未初始化的变量、内存越界、断言、错误的编译优化假设或多线程竞态条件等。使用静态代码分析工具、动态内存检查工具或者并发问题检查工具等也可以帮助找出问题的原因。\n\n## 对数\n\n1. opencv yml 文件\n1. dump to file\n1. gdbserver + gdb + vscode\n1. gdb script to dump binary + tools(转为 float， 对比数值) 工具一键获取\n1. 自动比对功能， [ref](https://github.com/Xilinx/Vitis-AI/blob/29c76cb5c29eaebb31c553572bbad56228b27c17/src/vai_runtime/vart/dpu-runner/src/dpu_runner_base_imp.cpp#L457)\n\n## 常见错误\n\n### 链接错误\n\n1. [C++ 链接库顺序导致的符号未定义问题](https://murphypei.github.io/blog/2019/06/link-sort)\n1. `nm -C _.a/_.so` 查看库里符号 `-C` Decode low-level symbol names into user-level names\n1. 链接顺序： 从右到左\n\n### `bus error`\n\n1. Bus errors are rare nowadays on x86 and occur when your processor cannot even attempt the memory access requested, typically:\n\n   - using a processor instruction with an address that does not satisfy its alignment requirements. such as: 0x000000003, 4Bytes 对齐\n\n2. A bus error is trying to access memory that `can't possibly be there`. You've used an address that's meaningless to the system, or the wrong kind of address for that operation.\n\n3. x86 机器不设置就不会 bus_error [link](https://stackoverflow.com/a/8412760)\n\n### `segmentation fault`\n\n1. Segmentation faults occur when accessing memory which does not belong to your process. They are very common and are typically the result of:\n   - using a pointer to something that was deallocated.\n   - using an uninitialized hence bogus pointer.\n   - using a null pointer.\n   - overflowing a buffer.\n2. A segfault is accessing memory that you're `not allowed to access`. It's read-only, you don't have permission, etc...\n3. 主要与指针相关值相关, 未初始化，初始化为 nullptr\n\n### file leak: `Too many open files`\n\n1. file leak, not close\n1. `watch cat /proc/sys/fs/file-nr` get the current number of open files\n1. find open files limit per process: `ulimit -n`\n1. count all opened files by all processes: `lsof | wc -l`\n1. get maximum allowed number of open files: `cat /proc/sys/fs/file-max`\n1. `lsof -u xiyang.jia | wc -l` or `lsof | wc -l` to see how many files are open.\n1. Please note that `lsof | wc -l` sums up a lot of duplicated entries (forked processes can share file handles etc).\n   That number could be much higher than the limit set in `/proc/sys/fs/file-max`.\n   To get the current number of open files from the Linux kernel's point of view, do this:\n   `cat /proc/sys/fs/file-nr`\n   Example: This server has 40096 out of max 65536 open files, although lsof reports a much larger number:\n\n```\n# cat /proc/sys/fs/file-max\n65536\n# cat /proc/sys/fs/file-nr\n40096   0       65536\n# lsof | wc -l\n521504\n```\n\n## libs\n\n### errno\n\n```c++\n#include <errno.h>\n\nauto fp = fopen(\"/sys/class/gpio/gpio3/value\", \"r\");\nif (!fp) {\n  LOG(INFO) << \"strerror(errno)=\" << strerror(errno);\n}\n\n```\n\n1. NOTE: errno is key word, should not use be a variable\n1. errno is a preprocessor macro used for error indication\n\n### errno command\n\n1. `sudo apt install errno`\n1. errno -l\n\n## info\n\n1. `cat /proc/xxxx/status` 查看进程信息\n\n## crash 命令\n\n## [lldb](https://lldb.llvm.org/)\n\n1. [GDB to LLDB command map](https://lldb.llvm.org/use/map.html)\n\n## [GDB 使用](https://sourceware.org/gdb/current/onlinedocs/gdb.html/)\n\n1. [100 个小技巧](https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-entry.html)\n1. [100-gdb-tips](https://github.com/hellogcc/100-gdb-tips)\n1. [gdb-a-quick-guide-to-make-your-debugging-easier](https://johnysswlab.com/gdb-a-quick-guide-to-make-your-debugging-easier/)\n1. [原理](https://zhuanlan.zhihu.com/p/336922639)\n1. [入门指南](https://www.yanbinghu.com/2019/04/20/41283.html)\n\n### 常用\n\n1. `(good) generate-core-file or gcore` 让被调试的进程产生 core dump 文件，记录现在进程的状态，以供以后分析; `gdb <program> <core_file>` or `gdb <porgam> => core <core_file>`\n1. `gcore $(pidof processname)` 命令行直接执行产生 coredump `-a`产生更详细信息\n1. `directory dir` 设置源文件查找路径(类似 include，设置到最后一级, 适合找单一文件, 或者把所有文件放到一个文件夹里)\n1. `(good) set substitute-path /from /to` 映射源码位置， `show substitute-path`查看映射表,`info sources`查看源码路径 `info source`查看 Compilation directory\n1. `(good) info proc all` 查看当前进程各种信息，包括 pid， 调试的命令, 是否 coredump, threads nums 等\n1. `set step-mode on`默认情况下，gdb 不会进入不带调试信息的函数。可以执行`set step-mode on`命令，这样 gdb 就不会跳过没有调试信息的函数, 可以使用调试汇编程序的办法去调试函数\n1. `info functions add` 列出 add 函数\n1. dump binary memory max_scores_dump.bin max_scores_vec.data() max_scores_vec.data()+max_scores_vec.size() 保存内存内容到文件, 可以配合脚本 dump 文件\n1. show env and show path 查看环境变量和 path\n1. gdb 调试时打不上断点，要使用 LD_PRELOAD 先加载动态库，找不到文件所在动态库，使用 speedscope\n1. sharedlibrary libxxx.so 加载库 libxxx.so\n1. help or help xxx 查看帮助\n1. `set logging file xxx; set trace-commands on;set logging on` 保存 log\n1. `start` 自动停止到 main\n1. until or u 函数里运行到第几行， 比打断点再运行效率高很多\n1. i b, i s, i w\n1. i locals or i lo 打印局部变量(i 不能打印单独变量)\n1. bt full or i s full 显示各个函数的局部变量值\n1. p xx 打印单个变量\n1. `x/40i 0x400000` `disassemble 0x4004e9,0x40050c` 查看.text 反汇编内容， i 表示 instruction。`info files`查看.text 地址\n1. x [/Nuf ] expr: examine memory at address expr; 打印内存\n1. x/12wf &test[0]: 打印 test 开始 12 个 float 内存\n1. x/16gf Q.data 打印 double\n1. x/12bx 打印二进制, 方便对数\n1. x/12bu 打印二进制, 8 位无符号\n1. display expr: show value of expr each time program stops\n1. set print pretty on 打印 class， 一个变量一行\n1. i functions\n1. `frame` 查看当前运行堆栈, 包含运行哪一行, bt 之后可以回溯栈上变量\n1. `up n or down n` 命令向上或向下选择函数堆栈帧，其中 n 是层数\n1. c-x a 可以快速看哪一行，再按一遍\n1. bt 可以显示运行到哪一行, l -1 或 l +1 显示当前行前后代码, l function\n1. b Foo::Foo 构造函数打断点\n1. b \\*0x1111 地址打断点\n1. save breakpoints test.bk && source test.bk 保存和加载断点\n1. 在程序入口处打断点, 先 readelf -h xxx 读入口地址，然后 b \\* 设置断点 [link](https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-entry.html), 火焰图也可以看调用关系\n1. `info files` 获取各 section 地址\n1. info files 获取入口地址，b \\*地址或 b \\_start\n1. `info proc mappings` 查看进程的内存映射信息, 配合 info files 使用\n1. info sources 获取源码路径, 可用于 debug 具体使用到的头文件， 如 json 使用系统默认，未使用 cpm 依赖的\n   - gcc -H 编译选项可以列出来用到的头文件 [link](https://stackoverflow.com/a/60570938)\n1. (good)`i source` 列出`当前文件`各种信息，包括编译选项，路径等\n1. b \\_start 然后 ni 看指令执行\n1. shell ls 或 !ls 在 gdb 中执行 shell 命令\n1. whatis xxx 打印变量类型，\n1. ptype xxx or pt xxx 打印详细信息，xxx 可以是变量也可以是类型名\n1. ptype + p sizeof() 查看类型占内存大小\n1. p object 直接打印对象，可以看出具体内存分配\n1. gdb -x gdb-script.txt --args ./my_program\n   or (gdb) source gdb-script.txt 执行命令集合\n1. 脚本里#号是注释\n1. set var x = value 程序运行可设置变量值\n\n### 图形化\n\n1. `(good)gdb -tui program`，或者运行 gdb 过程中使用`C-x a`组合键, 使用图形界面输出历史会不好查看\n1. `layout split or c-x 2` 如果既想显示源代码，又想显示汇编代码\n1. `layout asm`显示汇编\n1. `layout regs`显示寄存器\n1. winheight src -5 调整窗口\n\n### [shoart key](https://sourceware.org/gdb/onlinedocs/gdb/TUI-Keys.html)\n\n1. C-x s [single mode](https://sourceware.org/gdb/onlinedocs/gdb/TUI-Single-Key-Mode.html#TUI-Single-Key-Mode)\n1. C-x o Change the active window.\n1. c-n c-p next/previous history\n\n### base\n\n1. show endian 查看大小端\n1. 特别是当你在构建环境(build 目录)下调试程序的时候，可以直接运行 make：\n1. set var a = 1 改变变量值\n1. p func2::b 打印 func2 函数中变量 b 值\n1. p 'static-1.c'::var 打印文件中的变量\n1. i files 查看程序 elf 信息\n1. print sizeof(Type) 打印变量或类型占用内存 size\n1. .gdbinit gdb 配置文件\n1. 编译要加 -g [link](https://zhuanlan.zhihu.com/p/74897601)\n1. readelf -S xxx|grep debug 查看有没有 debug 段\n1. file xxx 查看有没有 stripped (编译不能加 -s), 也可以看到有没有 debug\n1. -fkeep-inline-functions 调试内联，编译的程序会变大很多\n1. set logging file log.txt, set logging on, set logging overwrite on 记录执行 log\n1. gdb -q 启动时不显示版本等信息\n1. gdb --args xxx ... && r 或 gdb xxx && set args ... && r 或 gdb xxx && r ...\n1. show env xxx 显示环境变量\n1. bt 或 i s(info stack) 显示程序栈 backtrace\n1. l 或 l + 向下显示源码， l - 向上显示源码，l 1,100 打印 1 到 100 行， l xxx:10 显示文件 xxx 第 10 行, l funciton 显示函数，\n1. bt 可以显示运行到哪一行, l -1 或 l +1 显示当前行前后代码\n1. step/finish 进入/返回函数 [link](https://wizardforcel.gitbooks.io/100-gdb-tips/content/finish-and-return.html)\n1. tb 如果想让断点只生效一次，可以使用“tbreak”命令\n1. source script 执行脚本中的命令\n1. p/x c 十六进制打印\n1. d 删除所有断点\n1. watch expr\n1. set print array-indexes on 打印数组下标\n1. i args 显示函数参数\n1. i locals 打印局部变量\n1. i sharedlibrary 显示共享链接库\n1. whatis xxx 打印变量类型， ptype xxx 打印详细信息，\n1. set history filename ~/.gdb_history， set history save on 保存历史\n1. shell ls 或 !ls 在 gdb 中执行 shell 命令\n1. 可以直接执行 cd 和 pwd\n1. 远程调试：\n1. emacs gdb-many-window, gdb 多窗口调试\n\n### [汇编调试](https://wizardforcel.gitbooks.io/100-gdb-tips/content/patch-program.html)\n\n1. trick: `layout split` => `layout regs` => `info files` => `b *start_adress` => `ni` 一步一步查看寄存器\n1. `ni` 下一条汇编指令\n1. `si` step by machine instructions rather than source lines\n1. `disassemble` 显示汇编\n1. `disassemble /m main` 将函数代码和汇编指令映射起来\n1. `disassemble /r main` 添加 16 进制信息\n1. `disassemble /mr main`\n1. `set disassemble-next-line on` 显示下一条汇编\n1. `display /3i $pc` 显示 pc 对应的后 3 条汇编指令, 一直显示`d display`删除\n1. `i line 13` 显示汇编地址\n1. `disassemble 0x4004e9,0x40050c`根据地址显示汇编\n1. `disassemble [Start],[End]`\n1. `disassemble [Function],+[Length]` 配合`info functions`使用\n1. `disassemble [Address],+[Length]`\n1. `b *main+12`函数偏移来打断点\n1. `p $pc`显示 PC 值\n1. `set var $pc=0x11111`设置 PC 值 or `jump line or jump *address`\n1. `set write on` and `disassemble /mr drawing` and `set variable *(short*)0x400651=0x0ceb` 修改二进制\n1. `info registers ` or `info all-registers` all 也显示向量寄存器\n\n### [~/.gdbinit](https://github.com/gdbinit/Gdbinit/blob/master/gdbinit)\n\n```\n# 保存历史命令\nset history filename ~/.gdb_history\nset history save on\n\n# 退出时不显示提示信息\nset confirm off\n\n# 按照派生类型打印对象\nset print object on\n\n# 打印数组的索引下标\nset print array-indexes on\n\n# 每行打印一个结构体成员\nset print pretty on\n```\n\n### funcutions\n\n1. gcc 自带 python stdlib 支持: 非常有用\n\n```python\npython\nimport glob\nsys.path.insert(0, glob.glob('/usr/share/gcc/python')[0])\nfrom libstdcxx.v6.printers import register_libstdcxx_printers\nregister_libstdcxx_printers (None)\nend\n```\n\n1. [打印 c++容器](https://wizardforcel.gitbooks.io/100-gdb-tips/content/print-STL-container.html)\n1. [print vector](https://stackoverflow.com/a/25499805)\n\n### 多线程\n\n1. gdb attach [pid], 如果卡死另外一个窗口打开\n1. info threads\n1. thread <thread id> 查看出问题 thread\n1. bt\n1. thread apply all bt 打印所有线程信息\n1. thread apply 1-2 bt 打印线程 1-2 堆栈信息\n\n### gdbserver\n\n1. `gdbserver --multi  :2000 ./test1`可以多次运行程序\n1. `gdbserver --once  :2000 ./test1` 运行一次就退出\n1. `gdbserver --attach  :2000 <pid>` 运行一次就退出\n1. why? 编译信息和路径都在 host 端，板端源码路径会有问题, 比如只读系统\n1. on client: `gdbserver :8000 ./test <args>`\n1. on host: `gdb: target remote <ip>:8000`\n1. c 开始，不能用 s\n1. 跨平台使用 gdb-multiarch， 或找相同 aarch 开开发机， cgdb 无 gdb-mutltiarch\n1. host 有源码就行, target 端不需要源码\n1. detach 断开链接\n1. jump \\_start 重新执行\n1. First, you need to have a copy of the program you want to debugput onto the target system. The program can be stripped to savespace if needed, as gdbserver doesn't care about symbols. All symbol handling is taken care of by the GDB running on the host system.\n\n## [gdbgui](https://github.com/cs01/gdbgui)\n\n1. 可以绘图： expression， 记录历史值\n1. memory view\n1. `sudo pip install gdbgui`\n1. `gdbgui -g gdb-multiarch` 使用 gdbserver\n1. `--port`可能不好使\n1. vnc 下调试用, 不是很流程\n1. `gdbgui --port 8080 --gdb-cmd=\"gdb -x gdbcmds.txt\"`\n\n## [seer](https://github.com/epasveer/seer)\n\n## [gdb-dashboard](https://github.com/cyrus-and/gdb-dashboard)\n\n1. `wget -P ~ https://git.io/.gdbinit` 只需要配置文件\n1. `help dashboard`\n1. `dashboard xxx` 可以选择打开和关闭 item 显示\n1. `dashboard` 到 dashboard\n1. `dashboard -layout !assembly breakpoints !expressions !history !memory !registers source stack threads variables`\n1. 竖屏显示会非常有用\n\n## [rr](https://github.com/rr-debugger/rr)\n\n1. gdb 回放\n\n## vscode C++调试\n\n1. 打不上断点，看下 info sharedlibrary 是否加载， Syms Read 是否为 yes, 注意配置文件中的 cwd 路径, 要与 board 板子上库的相对位置路径一致\n1. [vscode gdb gdbserver 关系](https://excalidraw.com/#json=5TP0xwb0oD-C3RgVJIvjW,YzWZI8S8UEP_-nFMxL-rxA)\n1. [source file map](https://code.visualstudio.com/docs/cpp/launch-json-reference#_sourcefilemap) 用于 gdbserver, 指定源码位置\n1. 安装 c/c++插件\n1. [教程](https://code.visualstudio.com/docs/cpp/config-linux) 生成 task.json（编译) 和 lauch.json (执行)\n1. [debug 教程](https://code.visualstudio.com/docs/editor/debugging)\n1. [settings 配置](https://code.visualstudio.com/docs/getstarted/settings)\n1. .vscode 配置文件下可以改 build 和执行 exe\n1. cmake 工程使用：命令来编译， lauch.json 配置执行环境\n1. [VsCode + gdb + gdbserver 远程调试 C++程序](https://blog.csdn.net/u014552102/article/details/122793256)\n   - 其中\"program\"是要被调试的程序在 vmware 中的路径 程序要和板子上一致\n   - \"cmd\"是要被调试的程序在 vmware 中的目录\n   - \"miDebuggerPath\" 是我们刚刚编译出来的 aarch64-buildroot-linux-gnu-gdb 在 vmware 中的路径\n   - \"miDebuggerServerAddress\"对应我们刚刚在板子上执行的 gdbserver 指令\n1. 注意不同 arch 要用 gdb-multiarch\n1. C-S-d 快速 debug\n1. debug console 中可以输入命令：`-exec info registers`\n1. gcc c++ stl 支持： `/usr/share/gcc/python/libstdcxx`, 需配置.gdbinit\n1. debug 点到变量上就会有值输出\n1. 可以选择 stack，看改 stack 各变量值\n1. terminal 下使用 tmux，否则容易断开\n1. 可以配置 compile_commands.json\n1. 配置快捷键，左手单独操作\n1. `open disassembly view`打开汇编窗口\n1. 选中字符 然后 add to watch\n1. debug variables 如果嵌套比较深，可以用`-exec print xxx`来看结果\n1. `Debug: start without debugging` debug 模式不进入断点，直接运行\n1. `Debug: run to cursor` 运行到当前 cursor\n1. `Debug: add logpoint`研究一下\n1. `compile_commands.json` 可以精准跳转，能帮助定位编译中的问题，如：json 头文件找错地方， 多重 include\n   - 也可以先编译一个 debug 程序 gdb info sources 看具体用到了哪个路径下的文件。\n1. 通过命令行 `-exec p xxx` 来完全显示变量\n1. 先打开 log， 然后执行命令，关闭 log， 搜索 [link](https://stackoverflow.com/a/41965636)\n\n### debug console\n\n1. 可以输入 gdb 命令，加`-exec`\n1. [intro](https://code.visualstudio.com/docs/editor/debugging)\n1. 可以进行算术运算\n1. 可以直接输入变量名\n\n## emacs gdb 使用\n\n1. emacs gdb-many-window, gdb 多窗口调试\n1. M-x gdb-many-windows and then gdb\n1. If the variable gdb-many-windows is nil (the default), M-x gdb normally displays only the GUD interaction buffer.\n1. NOTE: -g and not -O3(优化会跳过某些代码)\n1. gdb reload file: `file build/test` 不用重新加载， r 时自动重新加载。\n\n## [cgdb](https://github.com/cgdb/cgdb.git)\n\n1. [快捷键](https://cgdb.github.io/docs/CGDB-Mode.html#CGDB-Mode)\n1. esc 源码 i gdb commond\n1. `esc s` scroll mode in the GDB mode.\n1. o open the file dialog. debug 编译用到的所有源码，可用于定位头文件路径问题, 与`info sources`列出的文件相同，不过每行一个文件，更方便看\n\n1. [web](http://cgdb.github.io/)\n1. 两个窗口，一个显示源码，一个显示 gdb 信息.\n1. - - 调整窗口\n\n## strace\n\n1. strace - trace system calls and signals\n1. `strace -f -e file perf report 2>&1 | grep tips.txt` 可用于定位问题\n1. `strace -p $pid` 跟踪正在运行的进程\n\n## [Sanitizers](https://github.com/google/sanitizers)\n\n1. [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)\n   - 出错了会有两个线程信息，看信息对应的源码可以看到 data race 位置\n   - [bug 类型](https://github.com/google/sanitizers/wiki/ThreadSanitizerDetectableBugs)\n   - [输出信息说明](https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat)\n1. To enable continue-after-error, compile with `-fsanitize-recover=address` and then run your code with `ASAN_OPTIONS=halt_on_error=0`. [link](https://github.com/google/sanitizers/wiki/AddressSanitizer#faq)\n1. [Memory error checking in C and C++: Comparing Sanitizers and Valgrind](https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind)\n1. sanitizer 消毒剂\n1. tools\n   - AddressSanitizer (detects addressability issues) and LeakSanitizer (detects memory leaks)\n   - ThreadSanitizer (detects data races and deadlocks) for C++ and Go\n   - MemorySanitizer (detects use of uninitialized memory)\n   - HWASAN, or Hardware-assisted AddressSanitizer, a newer variant of AddressSanitizer that consumes much less memory\n   - UBSan, or UndefinedBehaviorSanitizer\n1. `-fsanitize=thread` 多线程数据竞争编译之后运行会报警告 [sample](https://github.com/jiaxiyang/cpp_sandbox/blob/d2e077877f1a3dae47215540429b679bcf032c54/concurrency/atomic/atomic1.cpp)\n1. `-DCMAKE_CXX_FLAGS=\"-fsanitize=address(thread) -g -lasan\"` cmake 编译选项, 加了-lasan 就不需要 LD_PRELOAD\n\n```\nLD_PRELOAD=libasan.so\n```\n\n1. cmake address\n\n```cmake\nif(WITH_COMPILER_ASAN)\n    add_compile_options(-fsanitize=address)\n    link_libraries(asan)\nendif(WITH_COMPILER_ASAN)\n```\n\n## [core dump](https://www.jianshu.com/p/e38a3f1cf7f7)\n\n1. `(good) generate-core-file or gcore` 让被调试的进程产生 core dump 文件，记录现在进程的状态，以供以后分析; `gdb <program> <core_file>` or `gdb <porgam> => core <core_file>`\n1. 当程序意外终止时，系统将进程的地址空间内容及终止时的一些信息转存到 core 文件里。\n1. `file core.xxx`: ELF 64-bit LSB core file\n\n```\n% ulimit -c unlimited\n% ulimit -a\n% echo 1 > /proc/sys/kernel/core_uses_pid\n% echo '/tmp/core_%t_%p' > /proc/sys/kernel/core_patter\n% gdb ./build/heimdallr-app /tmp/core_1643444420_1426\n% bt\n% info frame\n% p symbol\n\n# 多线程\n% info threads\n% thread apply all bt\n\n```\n\n## [Valgrind](http://senlinzhan.github.io/2017/12/31/valgrind/)\n\n1. Release 模式快很多\n1. [常见问题](https://valgrind.org/docs/manual/faq.html)\n1. [quick start](https://valgrind.org/docs/manual/quick-start.html)\n1. [manual](https://valgrind.org/docs/manual/manual.html)\n1. [内存泄漏解释](https://blog.csdn.net/weixin_42144707/article/details/117642613?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-117642613-blog-126759520.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-117642613-blog-126759520.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1)\n1. [错误解释](https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs)\n1. [工具解释](https://learnku.com/articles/46663)\n1. [DEBUG 神器 valgrind 之 memcheck 报告分析](https://blog.csdn.net/jinzeyu_cn/article/details/45969877)\n1. 编译程序时，需要加上-g 选项\n1. `sudo apt-get install libc6-dbg` # system libs should not stripped\n1. 编译加`-g`没有调试信息需要安装`valgrind-dbg`\n1. `--num-callers=10`调整 stack size\n1. `LD_PRELOAD=xxxx.so or --keep-debuginfo=yes` 定位 so 中的内存泄漏 [link](https://stackoverflow.com/a/13136609)\n\n### install\n\n```\n% wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2\n% bzip2 -d valgrind-3.13.0.tar.bz2\n% tar -xf valgrind-3.13.0.tar\n% cd valgrind-3.13.0\n% ./configure && make\n% sudo make install\n\n# 交叉编译: NOTE: 开发板上路径要与--prefix安装路径一致\n% export CC=/opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc\n% export CXX=/opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-g++\n% export LD=/opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ld\n% export AR=/opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ar\n% export CPP=/opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-cpp\n% cd valgrind-3.13.0\n% ./configure --host=aarch64-linux-gnu --target=aarch64-linux-gnu --prefix=/userdata/valgrind CFLAGS=-static\n% make -j8\n% sudo make install\n```\n\n### command\n\n1. `valgrind --log-file=test_memcheck.log --tool=memcheck --leak-check=full ls` : no summary\n1. `valgrind --log-file=test_memcheck.log --leak-check=full ls`\n1. `valgrind --log-file=test_memcheck.log --leak-check=full --show-leak-kinds=all ls`\n\n## procrank\n\n1. VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）\n1. RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）\n1. PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）\n1. USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）\n\n## [jeprof](https://phantom9999.github.io/posts/361305b0.html)\n\n1. [jemalloc 的 heap profiling](https://www.yuanguohuo.com/2019/01/02/jemalloc-heap-profiling/)\n1. [jemalloc 检查 c++服务内存泄漏](https://juejin.cn/post/7041453881255018504)\n1. 内存增长不一定是代码里 new 了没有 delete 造成内存泄漏，还可能是消费能力不足导致内存堆积\n1. 如果发现某数据结构内存增加，多在日志中打印其 size 看看\n\n## Static application security testing (SAST) 静态扫描工具\n\n1. [lists](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C,_C++)\n1. [C++静态检查工具总结](https://blog.csdn.net/u013377887/article/details/108651945)\n\n### [lint](https://blog.csdn.net/you_shou/article/details/51199293)\n\n1. 在计算机科学中，lint 是一种工具程序的名称，它用来标记源代码中，某些可疑的、不具结构性（可能造成 bug）的段落。它是一种静态程序分析工具，最早适用于 C 语言，在 UNIX 平台上开发出来。后来它成为通用术语，可用于描述在任何一种计算机程序语言中，用来标记源代码中有疑义段落的工具。\n1. apt search lint 可以搜索各种 lint， 如 shellcheck， yamllint\n\n### [clang-tidy AST 静态检查工具](https://clang.llvm.org/extra/clang-tidy/)\n\n1. 提供 run-clang-tidy 脚本用于实现对整个项目的文件做检查，用起来非常的方便。Runs clang-tidy over all files in a compilation database.\n1. `run-clang-tidy -quiet -use-color` 需要 compile_commands.json\n1. `run-clang-tidy -p build_path -header-filter=.*` 指定编译路径； build_path 下包含 compile_commands.json\n1. `clang-tidy test.cpp -checks=-*,clang-analyzer-*,-clang-analyzer-cplusplus*` will disable all default checks (-_) and enable all clang-analyzer-_ checks except for clang-analyzer-cplusplus\\* ones.\n1. `clang-tidy -list-checks` 列出所有的 check\n1. `clang-tidy -checks=\"-*,misc-unused-using-decls\" path/to/simple.cc --` 找出 simple.cc 中所有没有用到的 using declarations. 后面的`--`表示这个文件不在 compilation database 里面，可以直接单独编 l 译；\n1. `clang-tidy -checks=\"-*,misc-unused-using-decls\" -fix path/to/simple.cc --`找出 simple.cc 中所有没有用到的 using declarations 并自动 fix(删除掉)\n1. `clang-tidy -checks=\"-*,misc-unused-using-decls\" path/to/project/a.cc` 找出 a.c 中没有用到的 using declarations. 这里需要 path/to/project/compile_commands.json 存在\n1. [check list](https://clang.llvm.org/extra/clang-tidy/checks/list.html)\n1. [.clang-tidy](https://github.com/llvm/llvm-project/blob/main/.clang-tidy)\n1. `clang-tidy --dump-config`查看当前配置\n\n### [cppcheck](https://github.com/danmar/cppcheck)\n\n### [cpplint](https://github.com/cpplint/cpplint)\n\n1. An open-source tool that checks for compliance with Google's style guide for C++ coding.\n1. 它可以检测代码是否符合 Google 的编码规范，会把不符合规范的地方都指出来。\n1. `cpplint --recursive my_project_directory`\n1. [github clang-format-check](https://github.com/marketplace/actions/clang-format-check)\n\n## shared_ptr 调试\n\n1. 注意析构顺序，变量没被析构，memory pool 就被析构了，导致内存泄漏\n\n```c++\nclass ...{\n  std::shared_ptr<hbSysMem> output_mem_; // 还未加到memory pool\n  pg::utils::MemoryPool<hbSysMem> mem_pool_; //先析构了\n}\n```\n\n1. 注意 deleter， 可能会被改变，如： memory pool 改变传进去的 deleter\n1. use_count()打印引用次数\n\n## links\n\n1. [Writing a Linux Debugger](https://github.com/TartanLlama/minidbg)\n","tags":["Debug"],"categories":["Program","Cpp"]},{"title":"Links","url":"/2021/11/29/Links/","content":"\n## Usefull Tools\n\n1.  [`搜代码`：sourcegrah](https://sourcegraph.com/)\n1.  [`搜文档`：readthedocs](https://readthedocs.org/)\n1.  [`搜名字`：codelf](https://unbug.github.io/codelf/)\n1.  [`搜图书`：创世纪图书馆](http://libgen.rs/)\n1.  [`搜文章`：SCI Hub](https://sci-hub.se/)\n1.  [`搜图片`：unsplash](https://unsplash.com/)\n1.  [`搜主题`：programmingfonts](https://www.programmingfonts.org/#ubuntu)\n\n<!-- more -->\n\n1.  [csv view server](https://jiaxiyang-streamlit-example-streamlit-app-t8698c.streamlit.app/)\n1.  [it-tools](https://it-tools.tech/)\n    - [text-diff](https://it-tools.tech/text-diff)\n    - [json-diff](https://it-tools.tech/json-diff)\n    - [json-prettify](https://it-tools.tech/json-prettify)\n1.  [discord](https://discord.com/app)\n1.  [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)\n1.  [build-your-own-x](https://github.com/codecrafters-io/build-your-own-x)\n1.  [system-design-primer(200K star)](https://github.com/donnemartin/system-design-primer)\n1.  [gradio 机器学习应用](https://github.com/gradio-app/gradio)\n1.  [图片共享](https://imgbb.com/)\n1.  [imgur](https://imgur.com/)\n1.  [Sage](https://poe.com/Sage)\n1.  [ChatGPT app](https://github.com/lencx/ChatGPT)\n1.  [chat.openai](https://chat.openai.com/)\n1.  [aicodehelper](https://aicodehelper.com/chat/index.html)\n1.  [在线 coding](https://code.meideng.dev/)\n1.  [性能分析：speedscope](https://www.speedscope.app/)\n1.  [代码仓库 fossies(可以设置 theme)](https://fossies.org/)\n1.  [fossies doxygen lists](https://fossies.org/dox/all.html)\n1.  [mermaid 在线 uml](https://mermaid.live/)\n1.  [plantUML 在线 uml](http://www.plantuml.com/plantuml/uml/)\n1.  [GraphvizOnline](https://dreampuf.github.io/GraphvizOnline)\n1.  [cheatsheat 汇总](https://devhints.io/)\n1.  [Linux man pages online](https://manned.org/)\n1.  [在线画图工具 excalidraw](https://excalidraw.com/)\n1.  [在线设计工具 canva](https://www.canva.com/)\n1.  [在线设计工具 express.adobe](https://express.adobe.com/zh-Hans-CN/sp)\n1.  [在线流程图 processon](https://www.processon.com/)\n1.  [在线代码运行](https://wandbox.org/)\n1.  [正则表达测试](https://regex101.com/)\n1.  [正则表达式解释](https://tool.oschina.net/uploads/apidocs/jquery/regexp.html)\n1.  [数学公式可视化](https://www.desmos.com/calculator?lang=zh-CN)\n1.  [mathjax](https://www.mathjax.org/#demo)\n1.  [color palettes](https://coolors.co/palettes/palettes)\n1.  [paperwithcode](https://paperswithcode.com/)\n1.  [在线 markdown](https://stackedit.io/)\n1.  [在线 LaTeX](https://www.overleaf.com/)\n1.  [在线抠图](https://picwish.cn/upload)\n1.  [在线 web2pdf](https://www.web2pdfconvert.com/)\n1.  [在线 image to ASCII art](https://manytools.org/hacker-tools/convert-images-to-ascii-art/)\n1.  [在线 string to ASCII art](http://patorjk.com/software/taag/#p=testall&c=c%2B%2B&f=3D%20Diagonal&t=PhiGent%20Heimdallr) Larry 3D\n1.  [fontawesome](https://fontawesome.com/icons)\n1.  [threejs 网页动画](https://threejs.org/examples/#webgl_animation_skinning_morph)\n1.  [北京时间，用于拍屏测延迟](http://www.daojishiqi.com/bjtime.asp)\n\n## C++\n\n1. [cling online](https://cppcli.net/)\n1. [cling the-interactive-c++-interpreter](https://github.com/root-project/cling/)\n1. [cpp.sh online cpp compiler](https://cpp.sh/)\n1. [modern-cpp-tutorial](https://github.com/changkun/modern-cpp-tutorial/blob/master/book/zh-cn/toc.md)\n1. [Awesome cpp](https://github.com/fffaraz/awesome-cpp#readme)\n1. [更快的 log spdlog](https://github.com/gabime/spdlog)\n1. [新 test 框架 Catch2](https://github.com/catchorg/Catch2)a\n1. [代码在线运行](https://www.techiedelight.com/generate-random-float-value-in-cpp/)\n1. [Compiler on line wandbox](https://wandbox.org)\n1. [CppInsights](https://cppinsights.io/)\n1. [Godbolt](https://godbolt.org/)\n1. [Cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)\n1. [modern-cpp-tutorial](https://github.com/changkun/modern-cpp-tutorial/tree/master/book/zh-cn)\n1. [modern-cpp-features](https://github.com/AnthonyCalandra/modern-cpp-features)\n1. [Bjarne Stroustrup](https://stroustrup.com/videos.html)\n1. [CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main)\n1. [CppCon](https://cppcon.org/)\n1. [Back to Basics](https://cppcon.org/b2b/)\n1. [Youtube CppCon video](https://www.youtube.com/user/CppCon/)\n1. [CppCon resources](https://github.com/CppCon)\n1. [Compiler explore](https://github.com/compiler-explorer/compiler-explorer)\n1. [Compiler explore video](https://www.youtube.com/watch?v=kIoZDUd5DKw)\n1. [Quick C++ benchmark](https://quick-bench.com/)\n1. [Compile support](https://en.cppreference.com/w/cpp/compiler_support)\n1. [Debug tools](https://github.com/CppCon/CppCon2019/blob/master/Presentations/modern_linux_cpp_debugging_tools__under_the_covers/modern_linux_cpp_debugging_tools__under_the_covers__greg_law_and_dewang_li__cppcon_2019.pdf)\n1. [Lifetime analysis for everyone](https://github.com/CppCon/CppCon2019/blob/master/Presentations/lifetime_analysis_for_everyone/lifetime_analysis_for_everyone__matthias_gehre_gabor_horvath__cppcon_2019.pptx)\n1. [Interview](https://github.com/huihut/interview)\n1. [CS-Notes](https://github.com/CyC2018/CS-Notes)\n1. [Factory pattern](https://blog.csdn.net/qq_38238296/article/details/79841395?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)\n\n## C++ Concurrent Programming\n\n1. [awesome-parallel-computing](https://github.com/taskflow/awesome-parallel-computing)\n1. [taskflow](https://github.com/taskflow/taskflow)\n1. [C++ Concurrency in action 2](https://b-ok.lat/book/3688262/d57395?dsource=recommend&regionChanged=&redirect=4729105)\n1. [C++ Concurrency in action Chinese](https://github.com/xiaoweiChen/CPP-Concurrency-In-Action-2ed-2019)\n1. [Back to basics locks and tasks](https://github.com/CppCon/CppCon2019/blob/master/Presentations/back_to_basics_atomics_locks_and_tasks/back_to_basics_atomics_locks_and_tasks__rainer_grimm__cppcon_2019.pdf)\n1. [thrust](https://github.com/thrust/thrust)\n1. [nebula](https://github.com/vesoft-inc/nebula)\n\n## Emacs\n\n1. [GNU Emacs](https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf)\n1. [Melpa](http://melpa.org/)\n1. [Emacs 黑客列表](https://manateelazycat.github.io/emacs/2019/05/12/emacs-hackers.html)\n1. [Emacs China](https://emacs-china.org/)\n1. [Tour Of Emacs](https://www.gnu.org/software/emacs/tour/index.html)\n1. [Awesome emacs](https://github.com/emacs-tw/awesome-emacs)\n1. [Purcell config](https://github.com/purcell/emacs.d)\n1. [Xah Lee](http://ergoemacs.org/emacs/emacs.html)\n1. [Zamansky Config](https://github.com/zamansky/dot-emacs)\n1. [Zamansky Tutorial](https://cestlaz.github.io/stories/emacs/)\n1. [My Config](https://github.com/jiaxiyang/100ms_dot_emacs)\n1. [My Leader Key](https://github.com/jiaxiyang/leader-key-mode/blob/master/leader-key-mode.el)\n1. [Wcy Config](https://github.com/wcy123/100ms_dot_emacs)\n1. [Emacs Pinky](http://ergoemacs.org/emacs/emacs_pinky_2020.html)\n1. [Org Mode](https://orgmode.org/)\n1. [Org Guide](https://orgmode.org/orgguide.pdf)\n1. [org card](https://orgmode.org/worg/orgcard.html)\n1. [Org Mode Chinese Tutorial](https://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html)\n\n## Haskell\n\n1. [learn you haskell book](http://learnyouahaskell.com/chapters)\n2. [haskell Tutorial](https://www.youtube.com/watch?v=02_H3LjqMr8)\n3. [Functors, Applicatives, And Monads In Pictures](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n\n## Rust\n\n1. [Rust 中文杂志](https://rustmagazine.github.io/rust_magazine_2021/)\n2. [陈天](https://www.zhihu.com/people/tchen/posts)\n3. [陈天 rust 培训](https://www.youtube.com/watch?v=ZVIlcsYaDZY)\n4. [Cheats](https://cheats.rs/)\n5. [Officail website](https://www.rust-lang.org/)\n6. [Official resource](https://www.rust-lang.org/learn)\n7. [Awesome Rust](https://github.com/rust-unofficial/awesome-rust#readme)\n8. [Rust learning](https://github.com/ctjhoa/rust-learning)\n9. [Forum](https://users.rust-lang.org/)\n10. [crates.io](https://crates.io/)\n11. [Rust book](https://doc.rust-lang.org/book/)\n12. [Rust book Chinese](http://120.78.128.153/rustbook/)\n13. [Editions](https://doc.rust-lang.org/edition-guide/editions/index.html)\n14. [The Rust Reference](https://doc.rust-lang.org/reference/index.html)\n15. [The Rustonomicon](https://doc.rust-lang.org/nomicon/index.html)\n16. [Cargo book](https://doc.rust-lang.org/cargo/)\n17. [Rust examples](https://doc.rust-lang.org/stable/rust-by-example/)\n18. [Rust examples Chinese](https://rust-by-example.budshome.com/index.html)\n19. [STD library](https://doc.rust-lang.org/std/index.html)\n20. [Rust with C](https://doc.rust-lang.org/stable/embedded-book/interoperability/index.html)\n21. [Rust online programming](https://play.rust-lang.org/)\n22. [Ferris pictures](https://rustacean.net/)\n23. [Rust gameboy](https://github.com/mohanson/gameboy)\n24. [Rust zhihu](https://www.zhihu.com/topic/19674381/intro)\n25. [Rust 张汉东](https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM)\n26. [Concept video](https://www.youtube.com/watch?v=SZvs15hC81U)\n27. [Youtube Rust channel](https://www.youtube.com/channel/UCaYhcUwRBNscFNUKTjgPFiA)\n\n## Cmake\n\n1. [Cmake Tutorial](https://cmake.org/cmake/help/v3.19/guide/tutorial/)\n1. [Cmake Buildsystem](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html)\n1. [Effective Modern Cmake](https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1)\n1. [Deniz Bahadir 2019](https://www.youtube.com/watch?v=y9kSr5enrSk)\n1. [Deniz Bahadir 2018 traditional and modern camke](https://www.youtube.com/watch?v=y7ndUhdQuU8)\n1. [Beniz Bahadir PPT](https://github.com/Bagira80/More-Modern-CMake)\n1. [OO Cmake](https://zhuanlan.zhihu.com/p/76975231)\n1. [Cmake Concept](https://ukabuer.me/blog/more-modern-cmake)\n\n## Cheatsheet\n\n1. [Gdb](http://users.ece.utexas.edu/~adnan/gdb-refcard.pdf)\n1. [Pdb](https://github.com/nblock/pdb-cheatsheet/releases/download/v1.2/pdb-cheatsheet.pdf)\n1. [Emacs](https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf)\n1. [Org mode](https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf)\n1. [Dired](https://www.gnu.org/software/emacs/refcards/pdf/dired-ref.pdf)\n1. [Vim](https://linuxhandbook.com/vim-cheat-sheet/)\n1. [Bash](https://github.com/zhouyiqi91/awesome-cheatsheets/blob/master/languages/bash.sh)\n1. [Tmux](http://comtronic.com.au/blog/wp-content/uploads/comtronic_cheatsheet_tmux_A4.pdf)\n1. [Github Git](https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf)\n1. [Matlab](http://sites.nd.edu/gfu/files/2019/07/cheatsheet.pdf)\n1. [Markdown](https://www.markdownguide.org/cheat-sheet/)\n1. [Oh my zsh](https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet)\n1. [Rust](https://cheats.rs/rust_cheat_sheet.pdf)\n\n## Git\n\n1. [git linus](https://www.youtube.com/watch?v=4XpnKHJAok8)\n1. [Git Book](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)\n1. [Git Book Chinese](https://git-scm.com/book/zh/v2)\n1. [Git Internals: the most important concept](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)\n1. [Useful Git Commands](https://zhuanlan.zhihu.com/p/132573100)\n\n## AI\n\n1. [Netron](https://github.com/lutzroeder/Netron)\n\n## Data Structures and Algorithms\n\n1. [算法动画](https://visualgo.net/zh)\n1. [Boost Graph Library(BGL)](https://www.boost.org/doc/libs/1_74_0/libs/graph/doc/)\n\n## Design Patterns\n\n1. [Microsoft Application Architecture Guide, 2nd Edition](<https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff650706(v=pandp.10)>)\n1. [Refactoring Guru](https://refactoring.guru/)\n1. [Picture of Design Patterns](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)\n1. [Awesome Design Patterns](https://github.com/DovAmir/awesome-design-patterns)\n\n## Awesome\n\n1. [Awesome](https://github.com/sindresorhus/awesome)\n\n## Code Style\n\n1. [C++](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/#)\n1. [Python](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/)\n1. [Shell](https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/)\n\n## Code Format\n\n1. All: [format-all](https://github.com/lassik/emacs-format-all-the-code)\n1. C/C++: [ClangFormat](https://clang.llvm.org/docs/ClangFormat.html)\n1. Rust: [rustfmt](https://github.com/rust-lang/rustfmt)\n1. Python: [black](https://github.com/ambv/black)\n1. Shell: [shfmt](https://github.com/mvdan/sh) (install from github release)\n1. Cmake: [cmake-format](https://github.com/cheshirekow/cmake_format)\n1. Markdown: [prettier](https://prettier.io/)\n\n## Code Analysis\n\n1. [Clang-tidy](http://clang.llvm.org/extra/clang-tidy/index.html)\n","tags":["Links"],"categories":["Summary"]},{"title":"resume","url":"/2021/10/05/resume/","content":"\n## links\n\n1. [rxresu.me](https://rxresu.me/)\n1. [Reactive-Resume](https://github.com/AmruthPillai/Reactive-Resume) 填写内容，自动生成简历\n1. [简历用语](https://github.com/resumejob/awesome-resume)\n1. [Orbit-Theme](https://github.com/xriley/Orbit-Theme)\n1. [Awesome-CV](https://github.com/posquit0/Awesome-CV) CV: Curriculum Vitae 个人简历\n1. [overleaf awesome-cv template](https://www.overleaf.com/latex/templates/awesome-cv/dfnvtnhzhhbm)\n1. [latexcv](https://github.com/jankapunkt/latexcv/tree/master/sidebar)\n1. [awesome-resume-for-chinese](https://github.com/dyweb/awesome-resume-for-chinese)\n"},{"title":"Programming experience","url":"/2021/10/03/Programming-experience/","content":"\n## NOTE\n\n1. 思路 first\n1. `Think twice, code once`\n1. 开发方式： windows wsl + docker\n\n## 工程组织\n\n1. 两种方式, 主要区别是 include 和 test 是不是和模块 src 在一个文件夹\n   - 一起：[参考 opencv](https://github.com/opencv/opencv)\n   - 分离：[参考 grpc](https://github.com/grpc/grpc)\n\n## Software Development Modules\n\n1. 基础功能\n   - 日志系统和调试系统\n   - 错误处理\n   - [测试](https://cs.lmu.edu/~ray/notes/unittesting/)：单元测试,集成测试,smoke test 系统测试，性能测试，回归测试，压力测试。通过无法证伪来证明正确性。\n   - samples/demo\n   - docs and docs tests\n   - changelog or release note [tensorrt release notes](https://docs.nvidia.com/deeplearning/tensorrt/release-notes/index.html) Ensure you are familiar with the NVIDIA TensorRT Release Notes for the latest new features and known issues.\n1. 重构\n   - 架构\n   - 易读\n   - 代码风格\n1. 性能\n   - profiling\n   - benchmarks\n   - 加速\n1. 支撑\n   - 版本控制\n   - CI/CD\n\n<!-- more -->\n\n## 重构\n\n1. 最重要的是重构的`节奏感`，小的步子可以更快的前进，请保持代码永远处于可工作状态。（chunye 就是这样)\n1. 重构前现有`测试`\n1. 小步修改\n1. 每次修改后就运行测试\n1. 每次重构就提交代码，push 前把修改合并成更有意义的提交\n1. 永远将函数的返回值命名为\"result\"\n1. 尽量`移除局部变量`，使用小函数替代（临时变量会带来麻烦）\n1. 重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模修改。重构过程中几乎`可以随时停下来，不影响软件功能`。\n1. 区分`重构`和`性能优化`；重构是为了让代码更容易理解，更容易改变。程序可能更快，也可能更慢。在性能优化是，只关心让程序运行的更快，代码可能更难理解和维护。\n1. 两顶帽子：`添加新功能`和`重构`。添加新功能时`不应该修改既有代码，只管添加新功能`，重构时`不能添加新功能，只管调整代码结构`\n1. 重构的主要功能：\n   - `改进软件设计`\n   - `使软件更容易理解`\n   - `帮助找到bug`\n   - `提高编程速度`\n1. 重构的`唯一目的就是让我们开发更快，用更少的工作量创造更大的价值`。\n1. 代码所有权边界：接口的使用者（用户）与声明者（作者）彼此独立，声明者无权修改使用者的代码。添加新接口，旧的接口标记为不推荐使用(deprecated)。接口会变得复杂。\n1. 重构和性能：有性能测试工具，发现最耗时代码进行优化\n\n## code of conduct\n\n1. [llvm code of conduct](https://llvm.org/docs/CodeOfConduct.html)\n\n## Principles of Software Engineering\n\n1. 迭代和重构。\n1. 自动化\n1. 可重复\n1. 学习性测试：使用第三方代码，第一步不要在生产代码中实验新东西，而是单独编写测试来浏览和理解第三方代码。区分学习和整合。\n1. 小步快跑，节奏\n1. KISS (Keep It Simple Stupid)\n1. DRY (Don’t Repeat Yourself) (generic programing, 提出重复代码公用....)\n1. `层次`(抽象接口组成):写代码思路不应该是树状，而应该是有层次的，抽象出来层次，屏蔽细节，只依赖上个层次，不关注更低级别的层次, 每一层都相当于一种语言，解决一类问题，这样的系统更健壮。见[sicp](https://www.youtube.com/watch?v=YCR03O5EUdI&list=PLkEwH_Z2WOlppy8oUfrGwFVlOuKyo3RO_&index=5)\n1. 抽象,控制复杂度， 黑盒抽象\n1. `边界，隔离`\n1. 具体规则：\n   - `命名规则`：类名是名词，方法名是动词。\n   - `函数规则`：尽可能短小，只做一件事，每个函数一个抽象层次，名字不怕长，尽量少参数，无 side effect.\n   - `类规则`：短小，单一权责，高内聚(方法和变量互相依赖）\n   - `系统设计规则`： 多写测试，不可重复，表达力(好名字，好结构...), 尽可能少的类和函数(和前三条冲突，优先级最低）\n1. 一键： 单个命令构建系统，单个命令运行所有测试\n1. 出错仔细看 log，调试步步为营\n1. 多看文档\n1. 记录工作日志\n1. 区分对内和对外，区别对待\n1. 不要重复造轮子\n1. YAGNI (You Aren’t Gonna Need It) [link](https://medium.com/swlh/6-principles-of-software-engineering-that-every-developer-should-know-7868f362b633)\n1. 高内聚，低耦合\n1. 正交\n1. 分离`控制和逻辑`。`控制`：与业务逻辑无关的代码或系统的控制，如：多线程，异步，部署等，`逻辑`：业务逻辑，即解决用户问题的逻辑。\n1. 权衡\n1. 实用易用\n1. SOLID 原则\n   - `单一职责原则 SRP` 一个类只做一件事\n   - `开闭原则 OCP` 软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的\n   - `里氏替换原则 LSP` 子类应该可以完全替代父类，也就是说在使用继承时，只扩展新功能，不要破坏父类原有的功能。\n   - `接口隔离原则 ISP` 客户端不应该依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将该接口拆分，让实现类只依赖自己需要的接口。\n   - `依赖倒置原则 DIP` 细节应该依赖与抽象，抽象不应该依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。\n\n## Theories of Programming Languages\n\n1. SICP\n1. [book](https://people.cs.uchicago.edu/~blume/classes/aut2008/proglang/text/offline.pdf)\n1. [程序设计语言原理](https://www.jb51.net/books/163654.html) [英文版本](http://www.sci.brooklyn.cuny.edu/~chuang/books/sebesta.pdf)\n1. 通用的编程语言模型: 基本元素(过程和数据)，组合的方法(函数，结构体，类)，抽象的方法\n\n## [The Study of Programming Languages](https://cs.lmu.edu/~ray/notes/plstudy/)\n\n## [Programming paradigm](https://en.wikipedia.org/wiki/Comparison_of_programming_languages)\n\n1. [Functional Programming](https://www.info.ucl.ac.be/~pvr/paradigms.html)\n2. Object Oriented Programming\n3. Imperative programming\n4. Procedural programming\n5. Generic\n6. Reflective\n7. Event-drive\n8. [paper Programming Paradigms for Dummies](https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf)\n\n## [Programming Language Concepts](https://cs.lmu.edu/~ray/notes/plconcepts/)\n\n1. Structure (Syntax 句法)\n2. Meaning (Semantics 语义)\n3. Names, Binding, and Scope (Declarations)\n4. Evaluation (Expressions)\n5. Execution (Control Flow)\n6. Types\n7. Functional Abstraction (Subroutines and Coroutines)\n8. Data Abstraction (Objects and Modules)\n9. Concurrency\n10. Metaprogramming\n11. [link](https://cs.lmu.edu/~ray/classes/pl/)\n\n## Language Features [王垠 如何掌握所有的程序语言](http://www.yinwang.org/blog-cn/2017/07/06/master-pl)\n\n1. 编程语言取舍：[link](https://rustmagazine.github.io/rust_magazine_2021/chapter_4/rust-to-system-essence-lang.html)\n   - `性能`：编译或解释语言，并发\n   - `安全`： 内存安全(GC 或 RAII,所有权), 并发安全,类型安全\n   - `表达力`：泛型，宏\n2. Compiled language or Interpreted language\n3. Purely functional, Side effect\n4. Statically typed or Dynamically typed\n5. Statement and Expression\n6. Type inference\n7. pattern matching\n8. Lazy\n9. RAII or GC (Performance)\n10. Safety(memory-safety and thread-safety)\n11. Abstraction Level\n12. Zero-cost Abstraction\n13. Multi-paradigm\n14. Packages Management\n15. Concurrency Mechanisms\n\n## Rust 例子\n\n![概念层次图](https://static001.infoq.cn/resource/image/2d/91/2d36b45f6905a13a310e6447778ca391.jpg)\n\n## 思维模式\n\n1. 官方资料 first\n1. `3W`: what, why, how [dds introduction about](https://www.dds-foundation.org/what-is-dds-3/#)\n   - 查看各种技术先看 about\n1. `5W2H`: 原因（为什么 Why）、对象（是什么 What）、地点（在哪里 Where）、时间（什么时候 When）、人员（是谁 Who）、方法（怎么做 How）、程度（How much）\n1. `可重复`和`自动化`是非常重要的思维工作方式。版本管理 git, Jenkins, docker, CI, Rust Cargo.lock 文件, emacs tmux 插件, 软件一条命令安装(自动化，可重复), 代码风格 fmt 是自动化也是风格可重复，work log(可重复）。\n1. `effect`和`side effect副作用`。`纯函数`的行为只依赖它的接口。非纯函数副作用：引起环境，上下文的改变。[side effect](https://wangji.pro/%E6%9C%89%E5%85%B3%E6%B3%9B%E5%87%BD%E7%BC%96%E7%A8%8B%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86-effect-%E5%92%8C-side-effect/) 指的是那些任何主动或被动地对“非当前局部环境变量”的访问的操作。注意，“非当前局部环境变量”不仅仅包括访问全局变量和静态变量。这个操作可能非常广泛，甚至不局限于变量，还包括访问外部 IO，执行某些特殊指令，以非正常返回的方式引起的主动或被动出栈（比如异常）等行为。\n1. 多用纯函数，非纯函数会增加系统状态，使系统复杂化，容易出问题。组合爆炸\n1. [monad](http://www.ruanyifeng.com/blog/2015/07/monad.html)\n\n## Programming experience\n\n1. c++中接口类可以以 I(interface 开头)，例如 tensorrt 的接口类，这种命名方式帮助开发者清晰地区分接口和实现，以及其他非接口类型的类。\n1. 项目进度管理很重要，计划制定相当于思路，无思路特别乱\n1. 排期也相当于思路, 做事要排期，职业规划也需要排期, 思路清晰事半功倍\n1. 无思路不写代码，思路不明确就开始写是自欺欺人，如刷题的思路\n1. `接口`注释相当于 leetcode 刷题时的`思路`，.cpp 相当于思路的具体实现。具体实现根本记不得，但接口或思路看一下就知道功能或实现方法\n1. 接口多用结构体，灵活性更好\n1. [命名法：驼峰、下划线、匈牙利](https://www.cnblogs.com/linuxAndMcu/p/11280748.html)\n1. `sample + 注释` 学习方法\n1. 学习语法的时候，写一些 sample code 并注释上关键点，积累起来。 类似 cppreference\n1. 多看 man\n1. 知识点要对应例子，如 sandbox 举例\n1. 写脚本时要先屏蔽外界变量，将外界变量转化为内部变量。\n1. 区分好静态概念和动态概念：如 graph 是静态概念，runner 是动态概念， 静态是一种表示(程序)， 动态是一种运行(进程)，有 map 机制，将静态映射到动态(调度)\n1. 代码分为静态代码和动态代码，静态是写死的，动态是根据配置自动生成的\n1. 标准化然后自动化\n1. 简化程序， 去除杂项。用 sandbox\n1. `版本控制， 无情的测试，完全自动化`\n1. `抽象`和`分治`是降低程序复杂度的两种方法\n1. 了解开源库结构先看[fossies doxygen lists](https://fossies.org/dox/all.html)\n1. 新功能用 sourcegraph 探索大家都怎么使用的， 如探索 mermaid 使用\n1. mermaid readme 中画 uml 图和流程图, 可以作为写代码的 roadmap, 用 Snipaste 贴到空白地方写代码\n1. 注意 debug log\n   - cmake: `-DCMAKE_VERBOSE_MAKEFILE=ON`\n   - opencv:`OPENCV_LOG_LEVEL=DEBUG`\n1. `have fun` neofetch and tty pts send\n1. `能够轻易得到答案的简单问题不要问出口`，那并不会显得你很好学，反而会显得你无知又懒惰。\n1. `Think twice, code once`. Don't start “doing something” before you fully understand the problem and have acquired sufficient background knowledge\n1. 文档写好可以出书\n1. 讲解要有画面感\n1. `doxygen 文档` 为每个库生成 doxygen 文档，远程统一拉取配置， 生成文档发送到 mirros 上推送到 mirrors 上面。大家都可以访问， 作为 user guide。Jenkins 自动完成\n1. `Roadmap`: 路线图很关键， 例如[software-design-and-architecture-roadmap](https://github.com/stemmlerjs/software-design-and-architecture-roadmap)\n1. glog 只运行一次的 log 可以用 INFO\n1. `开发环境和测试环境分离`： 开发环境公用，每个场景有自己测试环境， 不用来回切换测试环境, 测试环境用 Jenkins 来搭建。\n1. `梳理好流程`：(效果拔群：6yolox + deepsort + 2lanes workflow 一天搞定)\n\n   - 数据通路图\n   - 数据结构 + 函数\n   - 待做的事\n\n1. 弄清需求，画图，然后再开始做, 迭代。\n1. 重复的事情尽量用 ci 搞定。ci 流程熟练。\n1. 编译不要漏过`warning`\n1. **加速编译**： `configure the project and generate a native build system`后直接执行`make -C $BUILD_DIR -j4` or `cmake --build ${BUILD_DIR}`，不用每次都重新构建编译系统\n1. 任务分解：先搭框架，慢慢填充，上节奏。\n1. 搭个框架，编译通过： 类接口 + 测试程序 => 一步步调试(构造， 输入，输出)\n1. 专注：\n   - 高亮\n   - 折叠\n   - narrow\n   - beacon\n   - fullscreen\n   - 统一界面\n1. 可重复, 自动化： 保留自己的操作历史\n   - .zsh_history\n   - z.lua\n   - docker_file\n   - work_log\n   - snippets\n   - blog\n   - bug 跟踪历史\n   - org mode\n1. 多使用 emacs c++ man 功能。可以作为增强版 snippets\n1. markdown 折叠很有用： worklog, blog\n1. 高亮相当于荧光笔，关注关键点\n1. 问清楚事情的来龙去脉，不要埋头苦干。\n1. 记录调试状态，步骤。不用重复跟别人解释，也好回忆内容。\n1. html 文档比 pdf 好用\n1. release 给别人时加一下 [changlog](https://keepachangelog.com/zh-CN/1.0.0/) 或 release note\n1. 看见好的地方就吸收\n1. 从开发者的角度开发功能，从使用者的角度来使用。开发功能要配套 test， test 越简单越好。\n1. 不要陷入细节，从高层次来看问题\n1. 开发方式：作为用户，先写测试程序架子，抽象出用到的接口。然后作为开发者实现接口， 用户和开发者要。\n1. `[自顶向下和自底向上结合](https://www.jianshu.com/p/608ac1e6d05d)`\n   - 自顶向下: 先搭框架，抽象出各个层次，再往里填。\n   - 自底向上: 先完成基本功能，再搭框架。\n1. `抽象层次`很重要，\n1. `sandbox` 快速验证，非常有用\n1. 热爱编程，从中找到乐趣，代码写的简洁优雅, 易用。\n1. 统一：\n   - emacs 和命令行统一操作\n   - emacs 统一编辑等功能\n   - format all 统一格式化\n   - docker 统一开发环境\n   - tmux 统一 terminal\n   - Nvidia Unified Memory\n   - opencv 统一接口\n1. 参考常用库接口,如 opencv, 使用 doxygen 生成 UML, yaml(gtest)\n1. 解决编程痛点：\n   - 不同版本 clang-format 不一样\n   - 命令行 error warning 高亮\n   - mount uid 与主机一致\n   - 新板子分配用户，uid 一致\n1. 多使用 profilling(chrono)测试性能(看哪种写法性能更好)\n1. 讲故事编程, 串起来\n1. `通用`: 写的代码尽量通用，尽量少的特例，少 if。linus.\n1. `迭代`： 先想怎么写就怎么写，可能非常丑陋，然后再打磨代码。是一个迭代过程，不是一蹴而就,例如：rust xmodel product 模块，刚开始特别烂，不断迭代，抽象了接口，使用了 trait object, 工厂模式，模板，前后提交了几十个 commit。\n1. `讲故事`：大师级程序员把系统当作故事来讲，而不是当作程序来写。学会讲故事会提升编程能力和应表达能力。\n1. 编程艺术：编程的目的是搭建系统，系统是由语言来描述的，函数是语言的动词，类是名词。编程的艺术其实也是语言的艺术，合理的使用动词，名词。\n1. `语言feature`: 编程语言有一堆 feature，每种语言在其中选择权衡，理解了各种 feature，也就学会了各种语言，各 feature 之间的关系，互斥，相交。[haskell feature](https://wiki.haskell.org/Functional_programming) [haskell book](http://learnyouahaskell.com/chapters)\n1. 函数式编程没有变量也没有 side effect。隔离了可变性，变量或者默认状态默认就是不可变的。避免了死锁，状态冲突等众多麻烦。\n1. 函数式编程，命令式编程，面向对象编程区别\n1. 以前的面向对象系统和如今的分布式系统。\n1. 表达式 expression 和语句 statement 区别，表达式有返回值。\n1. `测试`分为`单元测试，集成测试和文档测试`。单元测试独立地验证库的不同部分，也能够测试私有函数实现细节。集成测试则检查多个部分是否能结合起来正确地工作，并像其他外部代码那样测试库的公有 API。\n1. 最重要的是`官方资源`，看英文原文，如 rust 官网教程，c++ cppcon 会议。\n1. 找`最专业`的，从原理上学习。如 rust 设计者讲 rust，git 原理。\n1. 找`创始人相关`视频学习，如 Bjarne Stroustrup c++视频，Linus Torvalds git 原理。Richard Stallman emacs.\n1. `先见识，再模仿，后摸索`。`Good artist copy, great artist steal` 学习新语言，可以先看看视频教程，再自己摸索。\n1. `将知识点放入体系`中，不能孤立的学习。比如学习 C++知识时要有`big picture`，要把编译器，操作系统考虑进去，这样才能理解深刻，不要陷入细节中无法自拔。\n1. 搭建自己`编程体系，哲学`。写代码是`实践`，用来验证体系的好坏。重点应该关注体系哲学而不是具体的代码。\n1. `将知识点带入现实，自己融入进去`。便于理解和讲解。比如，想象自己是操作系统，管理一堆资源，向应用提供服务，交互过程。\n1. 如何看待编程？`编程是一个建造世界的过程(会涉及不同层级的抽象)`，建造完成后的世界就相当于程序，完成了编程的目标。建造流程为生产对象，组织对象，对象行为约定。（对应设计模式里的创建型模式，结构型模式，行为型模式），设计模式就相当与搭建过程中用到的各种套路，是一种设计思路。参考《我的世界》游戏。\n1. `区分抽象层次`很重要，有助于理解系统的横向(同层次）纵向（上下层）关系。理解编写代码要从最高层次（顶层设计）入手，一层一层的往里剥，越往里越细节（the onion principle）。\n1. 有`目标`或者`带着问题`看文档或代码。\n1. 无论是整体还是模块，都要先弄清楚模块`目的`，再学习`基本概念`, 然后学习`框架和设计模式`，最后再学习具体代码。\n1. 看文档或代码的时候`抓关键点记笔记`，有利于`专注`，记录的时候会强化，加深理解，也有利于`新思路涌现`。可以记录到`blog`或者`git`上。如有需要进行`可视化`\n1. 看文档代码先问`why`。要从模块`存在的目的？解决了什么问题？特点特性？优缺点？适用范围？概念？架构？设计思路？具体实现方式？`等方面考虑问题。\n1. 概念刚开始可能很难理解，可以从`具体实例`来理解，`多动手`，写一遍理解深刻很多。\n1. 找到`语言优势`，重点关注。C++的优势在于`性能`，死磕性能。\n1. 学习`建模`，对系统建模。\n1. 读代码时要先理解总体设计架构，设计思路，再具体到细节，架构理解了代码就不是问题。\n1. 多学点架构，设计方法，少学点语法。\n1. 最终目标创造而不是复制。\n1. 架构是撑起项目的基础，理解架构了就能看清楚系统轮廓。架构就相当于系统的草图，有了草图才能起高楼。\n1. 注意软件架构和设计模式的区别。\n1. `设计`是解决问题的方案，不是一种算法。\n1. 分主题分模块学习语言，分拆效率高，更容易 focus，不能一股脑的啥都往脑子里塞。\n1. 学习新知识时`先明确概念`，如 cy 学习 git，明确 git 的原理，四个 object；学习 cmake 时明确 component 和 target；学习 gstreamer 明确 component,pad 等，给别人讲解是也是从基本概念、基本组成讲起。\n1. 文档越详细越好，肯定会忘\n1. 读代码的时候可以记录自己的理解，可加深印象。用 git 仓库保存起来。\n1. github 排名，github trending\n1. 查看开发者的 github 找资料\n1. 先`模仿`github 开源代码。youtube 视频教程。\n1. 随时写一些简单的例子验证想法。很重要。\n1. Github awesome 系列，awesome emacs, shell，rust\n1. emacs org 管理项目，todo，日志\n1. 遇见问题记得看 github issues\n1. 设计的思路，设计原则，理解之后对使用帮助很大(例如： emacs, git)\n1. 编译时出错`仔细看错误`信息\n1. 调试时要一小步一小步的调，步步为营\n1. `乐于学习新东西`，学习 emacs 之后才知道 vim 该怎么用，学习 Rust 之后才知道语言一些基本特性，更好的理解 C++\n1. `重头文件(接口)，轻源文件`。看一个新库时例如 xir, vart，先看接口（接口注释很重要），知道接口功能就行，不需要明白具体实现。通过接口明白整个库的结构。\n1. `突出重点`:读音加重，停顿。看 C++代码要具备忽略次要信息的能力，看重点的信息要用不同的眼光，例如函数名，函数功能重点看和理解，具体实现可以先不用管\n1. 程序有 Debug 和 Release 模式，Release 开优化，编译慢，运行快\n1. 程序有编译期和运行期。\n1. 程序包含功能和性能，注重分析程序的性能，比如帧率，时间\n1. 流程: 开发(开发新库），测试(jenkins)，发布(上 github)，运营(gihub issues)\n1. 重设计，轻实现\n1. 按部就班，不能急于求成\n1. 知乎话题：rust, emacs\n1. 学习编程语言要关注几点：起因，解决什么问题，设计哲学，特性 [参考文章](https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM)\n1. 大项目中，模块之间要检查`输入输出`是否正确，不用在乎模块里内部实现\n1. 日志写在实现的外面，可以从使用者的角度检查输出，日志写在里面，可以从实现者的角度检查问题。倾向写在实现外面，先定位哪个模块出问题了，再深入到模块内部，看看为什么出问题。\n1. 一个函数完成一个小功能，方便理解定位问题\n1. main.rs 函数中处理程序运行，lib.rs 中处理任务逻辑\n1. 操作符重载打印结构体很方便\n1. API 文档目的是让他人理解如何使用库，而不是让他人明白库如何实现的。\n1. 创建一个有用的公有 API 结构更像是一门艺术而非科学，你可以反复检视他们来找出最适合用户的 API\n1. 留意 FAQ\n1. 函数(一层抽象)，类，泛型都是为了重复代码。\n1. 写代码时明确（输入，输出，算法）（开，关，做）（构造，析构，虚函数)\n1. RFC 流程。\n1. C++ API -> C API 可能拆分， C API -> Rust API 可能合并\n1. 区分公开与非公开部分。\n1. 学习语言，应该了解编译器，编译器是整个编程中重要一环。\n1. 使用 cppinsights 从编译器的角度看程序。有助于对语法的了解。\n1. 区分计算密集和 I/O 密集，计算密集多线程，I/O 密集异步？\n\n## Productivity [陈天](https://zhuanlan.zhihu.com/p/19968368) [link](https://zhuanlan.zhihu.com/p/366187306) [知乎生产力工具](https://www.zhihu.com/topic/19772918/hot)\n\n1. 光标样式设置大一号, 个性化 -> 主题 -> 鼠标光标\n1. 统一开发环境 docker\n1. [sourcegraph 插件](https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack)\n1. [gitzip 插件](https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn)\n1. chrome 快捷搜索设置，github g https://github.com/search?q=%s; translate t https://translate.google.cn/?source=osdd&who=test&sl=en&tl=zh-CN&text=%s&op=translate;\n1. 多看高手 screencast [sample](https://www.youtube.com/results?search_query=emacs+screencast&sp=CAM%253D)\n1. 好电脑，大屏幕\n1. 自动化，重构\n1. snippet\n1. 统一编辑器，emacs\n1. 工程加 make 命令： make init，make build，make run，make create-pr [link](https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=2649828020&idx=1&sn=59668db47a49e023735152e51b450b88&chksm=8704a8a8b07321be4bb8f540909f2a0b1be4c3a250c71d04e115f78ab19dc804310b55170ed4&scene=21#wechat_redirect)\n1. sandbox 或模拟器\n1. 搭建 ftp 服务器，使用`put`上传，`get`下载，`gls`查看列表。多个服务器之间共享传递文件，windows 上浏览器也可访问。见 Bash-usage.md\n1. 用好 tmux, fd, rg, zh, fzf\n1. 使用格式化工具刷代码，不要手动刷\n1. 开始时多使用 cheatsheet\n1. 常用命令 alias\n1. 保持工作空间整洁，经常清理，立即删除无用文件\n1. git 管理代码，配置，日志\n1. 多用 google，少用百度\n1. 使用好日志系统\n1. 学会 bg, jobs, fg, C-z, &来切换前后台运行。注意：多个 jobs -l 时需要 fg %n 才能切换到前台, kill -9 <tab> fzf to kill ps\n\n## Keyboard usage\n\n1. EMACS alt, shift 一只手同时按，另一只手按%,>\n1. sharpkeys 修改键位\n1. emac 快捷键设置技巧\n   - 右手 leader key,左手按键\n   - 常用命令才设置，不常用直接输命令\n   - 快捷键有意义\n   - 尽量简单简洁\n   - 尽量少用左手小拇指，多用命令\n\n## 编程名言 [link](https://www.jianshu.com/p/234452c2d88d)\n\n1. 在物理学中，第一性原理(或起源)，或称从头算，指从基本的物理学定律出发，不外加假设与经验拟合的推导与计算。例如利用薛定谔方程在一些近似方法下解电子结构，但不从实验数据得到拟合参数的从头计算法。\n1. LLVM 之父 Chris Lattner：`这正是我们从第一性原理出发开展工作的原因。你必须从头完成所有的工作，如果做得对，就不应跳过任何重要的步骤` [link](https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247492618&idx=1&sn=a20f4828b9ab3e3cee3fedfd906e0eb2&chksm=fe426a3cc935e32a8312ce9efbb4f2640787508d3e811579bbffe918685cdb07a8bd8e3ffc4b&scene=132&exptype=timeline_recommend_article_extendread_samebiz#wechat_redirect)\n1. `Any problem in computer science can be solved by another layer of indirection` 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决;例如虚拟地址\n1. `Think twice, code once`\n1. `Hackers write better code when it's for their own satisfaction instead of for pay.`\n1. 控制复杂性是计算机编程的本质。—— Brian Kernighan\n1. Any fool can write code that a computer can understand. Good programmers write code that humans can understand. –Martin Fowler\n   任何一个傻瓜都会写能够让机器理解的代码，只有好的程序员才能写出人类可以理解的代码。——Martin Fowler\n1. “The first 90% of the code accounts for the first 90% of the development time. The remaining 10% of the code accounts for the other 90% of the development time.” – Tom Cargill\n   “最开始的 90%的代码使用了程序员 90%的时间，剩下的 10%的代码也需要 90%的开发时间”——Tom Cargill（这不就是中国谚语——“行百步半九十”）\n1. 过早的优化是万恶之源。Premature optimization is the root of all evil! - Donald Knuth\n1. 作为一个程序员，郁闷的事情是，面对一个代码块，却不敢去修改。更糟糕的是，这个代码块还是自己写的。—— Peyton Jones\n1. 用几个小时来制定计划，可以节省几周的编程时间。—— 匿名\n1. 当你试图解决一个你不理解的问题时，复杂化就产成了。——Andy Boothe\n1. 靠代码行数来衡量开发进度，就像是凭重量来衡量飞机制造的进度。——比尔·盖茨\n1. `Talk is cheap. Show me the code.`\n\n## have fun\n\n1. `/etc/profile` 添加 ssh 自启动\n1. [cfonts](https://github.com/dominikwilkowski/cfonts) 可作为 ssh 登录输出，区别不同机器\n   - `npm i cfonts -g`\n   - `cfonts \"heimdallr\" --gradient red,blue`\n   - `cfonts \"heimdallr\" --gradient red,blue -f shade`\n   - `cfonts \"heimdallr\" --gradient \"#e60012\",blue > heimdallr.txt`or `script -q -c \"cfonts \"heimdallr\" --gradient red,blue\" heimdallr.txt > /dev/null` 将彩色输出保存到到文件中\n   - cat file on board\n1. `neofetch` ssh 登录显示 no bug car\n   - [link](https://github.com/dylanaraps/neofetch)\n   - `neofetch --ascii /home/nvidia/phigent_color.txt`\n1. ASCII art: 抠图 -> ASCII 转换 -> 颜色(logtool)\n1. `linuxlogo` 命令行显示 linux logo\n1. w, who 查看登录的用户; 向登录用户发消息 `echo jia > /dev/pts/20 ` `for i in $(who | awk '{print $2}'); do echo \"${i}\" > /dev/${i}; done`\n   `port=0; echo -e \"From xiyang: hi 你好 xx\\c\" > /dev/pts/${port} ; for i in $(seq 1 100); do echo -e \".\\c\" > /dev/pts/${port}; sleep 1; done`\n1. `cmatrix` [link](https://www.tecmint.com/20-funny-commands-of-linux-or-linux-is-fun-in-terminal/)\n1. [figlet and lolcat](https://opensource.com/article/21/11/fun-linux-commands) `figlet centos.com | lolcat` `cat no_bug_car.txt | lolcat`\n1. [ascii car](https://www.asciiart.eu/vehicles/cars) 需要删除空行，更好看\n1. [在线 image to ASCII art](https://manytools.org/hacker-tools/convert-images-to-ascii-art/)\n1. [在线 string to ASCII art](http://patorjk.com/software/taag/#p=testall&c=c%2B%2B&f=3D%20Diagonal&t=PhiGent%20Heimdallr) Larry 3D\n1. no_bug_car.txt 在 `source/images/software-diagram/`目录下\n1. [scratch language for children](https://scratch.mit.edu/)\n\n## Links\n\n1. [Hacker laws](https://github.com/dwmkerr/hacker-laws)\n2. [陈天](https://www.zhihu.com/people/tchen/columns)\n","tags":["Program"],"categories":["Summary"]},{"title":"Amazing emacs","url":"/2021/09/30/Amazing-emacs/","content":"\n## Emacs Architecture\n\n![Emacs Architecture 《架构之美》](https://pic2.zhimg.com/964f7a10ac8a4158896500858efb4a55_b.png)\n\n## NOTE\n\n1. `ln -s build-debug/compile_commands.json` 设置软连接\n1. `lsp`提示时按 i, 否则不能补全\n1. `list-face-display and list-colors-display` 列出颜色\n1. `(add-hook 'window-setup-hook 'on-after-init)` 启动时防止 buffer 模糊不通透\n\n<!-- more -->\n\n1. gcc emacs 性能提升\n1. vnc x11 meta[问题](https://www.emacswiki.org/emacs/MetaKeyProblems#:~:text=There%20is%20no%20mention%20of%20Meta%20for%20any,may%20want%20Meta%20to%20be%20distinct%20from%20Alt.)\n\n```sh\n% xmodmap\n% xmodmap -e \"clear mod4\"\n```\n\n1. windows terminal 透明, 启动配置里加\n\n```sh\n(defun on-after-init ()\n  (unless (display-graphic-p (selected-frame))\n    (set-face-background 'default \"unspecified-bg\" (selected-frame))))\n\n(add-hook 'window-setup-hook 'on-after-init)\n\n```\n\n1. [固定创建一个窗口](https://emacs-china.org/t/topic/17035)\n\n## [Calc](https://www.gnu.org/software/emacs/manual/html_mono/calc.html)\n\n1. `C-x * *`\n1. `calc-reset` 重启\n1. `D` redo\n1. `U` or `ctrl+/` undo\n1. `Backspace` calc-pop: can't redo\n1. stack 计算方式, 可以直接输入+ - \\* /， 最近 stack 进行计算\n1. [计算 buf 均值](https://superuser.com/questions/1077154/emacs-commands-to-calculate-sum-average-etc-of-region)\n1. `C-x * q (quick-calc)`\n1. step\n   - put num in a buffer `ctlr-x space` select rectangle, remove other\n   - select all buffer `ctrl-x h`\n   - M-x: statistics-in-rectangle\n   - M-x: calc-grab-region\n   - M-x: calc-vector-mean (u M)\n1. step\n   - `ctlr-x space` select rectangle:(can slect string, such as: 10ms, 101ms NOTE: 后缀字符串必须一样)\n   - M-x: calc-grab-rectangle\n   - M-x: calc-vector-mean\n\n## [Rectange](http://xahlee.info/emacs/emacs/emacs_string-rectangle_ascii-art.html)\n\n1. `ctrl-x space` + `M-w` + `C-y` 选择，复制，粘贴\n1. `ctrl-x r`\n1. `ctrl-x r t` insert\n1. `ctrl-x r k` kill\n1. `ctrl-x r y` paste\n1. `ctrl-x r N` insert a column of numbers\n\n## ibuffer\n\n1. `, b l`\n1. `h` for help\n1. `% n` - Mark buffers by their name, using a regexp.\n1. `U` - Unmark all marked buffers.\n1. `/ n` - Add a filter by buffer name.\n1. `/ /` - Remove all filtering currently in effect.\n\n## dired\n\n1. filter: search file and ivy-occur\n1. `wdired-change-to-wdired-mode` (可批量改文件名)Put a Dired buffer in Writable Dired (WDired) mode. `C-c C-c` wdired-finish-edit\n1. `dired-hide-details-mode` toggle dired details shortcut:`(`\n1. `s` sort by date\n1. `ctrl+u s`\n1. xah-dired-sort\n1. `>` next dir\n1. `<` previous dir\n1. `f and b, j and k` dired-find-file and dired-up-directory, next line and previous line\n1. `+` add directory\n1. `C-x C-d` recent dired\n\n## speed up\n\n1. set windows repeat rate [link](https://www.dummies.com/computers/pcs/set-your-keyboards-repeat-delay-and-repeat-rate/)\n1. `profiler-start, profiler-report, profiler-stop` to see cpu report\n1. next-line is slow: `(setq auto-window-vscroll nil)` [link](https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag)\n1. yascroll is slow; close\n1. recentf (set len 10)\n1. flycheck 应该很慢\n1. 如果卡了就完全从头编译一下\n\n## macro\n\n1. `kmacro-start-macro-or-insert-counter` F3\n1. `kmacro-end-or-call-macro` F4\n1. `call-last-kbd-macro` C-x e e e e e\n1. F3 -> (F3) -> F4 counter\n1. `C-u 222 F3 ... F3 ... F4` start counter from 222\n1. `C-u 100 F4` repeat macro 100 times\n\n## useful keys\n\n1. `M-S-n` 快速选中多行， 比`M-; -> M-n`更快\n1. `repeat` (global-set-key (kbd \"C-x .\") 'repeat)\n1. `xterm-paste`\n1. `ibuffer` -> `% n` -> \"Occur\" -> `D` remove all Occur buffer\n1. isserch: Typing `M-s o` in incremental search invokes isearch-occur\n1. occur 正则： yolox.*Raw.*running `next-error`\n1. `clm/toggle-command-log-buffer` C-c o\n1. in minibuffer: ivy-occur 默认绑定在`C-c C-o`上，它可以将当前的候选集合保存至 buffer 内并退出 minibuffer\n1. ivy-call 默认绑定在`C-M-m`上，它可以看做不退出 minibuffer 的 ivy-done 操作\n1. `M-x M-o` see ivy-mini-buffer-map; i: insert comand; d: go to defination;\n1. `C-M-j` ivy-immediate-done, when you call find-file to create a new file, but the desired name matches an existing file.\n1. 利用好 lsp\n\n```sh\n(setq lsp-ui-doc-enable nil) ;; lsp关闭弹窗\n(setq lsp-ui-sideline-mode nil) ;; lsp 关闭右侧错误提示\n(setq lsp-signature-mode nil) ;; 防止M-n被占用\n(setq lsp-enable-symbol-highlighting nil)) ;; lsp 不高亮\n```\n\n## 编程操作\n\n1. symbol-overlay 高亮选中后可以用 t 切换 scope，然后 r 重命名。废弃： `narrow` => `symbol-overlay-put` => `n or r`跳转或替换 => `fancy-widen`\n1. `symbol-overlay`: 双击左键高亮或取消高亮， 中间键跳转到上一个， 右键跳转到下一个\n1. `origami-toggle-all-nodes` and `origami-recursively-toggle-node`, `origami-show-only-node`, `origami-undo`, `origami-redo`\n1. `outline-show-all`, `outline-hide-other`, `outline-show-subtree`\n1. `bm-toggle` and `bm-next`\n1. `git-gutter`: next, previous, revert\n1. `view-mode`: (help man 都适用)(单手，大拇指 space 无名指 Delete)\n   - `e` quit and stay current buffer\n   - `space` scroll page down\n   - `Delete` scroll page up\n   - `(setq view-read-only t)` read-only 打开 view-mode\n1. `projectile-switch-project` 切换工程 `projectile-toggle-project-read-only` 工程只读\n1. `deadgrep`\n1. `occur` + `next-error`\n1. `goto-last-change`\n1. `indent-guide`\n1. `markdown mode` shift+tab 折叠, head 上 tab 折叠\n1. `company-toggle-delay` to toggle company automatically\n1. `F11` 全屏操作\n1. `follow-mode` + `balance-window(C-x +) or balance-windows-area(, w b)`\n1. zap\n\n## [snippets](http://joaotavora.github.io/yasnippet/snippet-development.html#orgcde188c)\n\n1. [inspired from textmate](https://macromates.com/manual/en/snippets)\n1. M-x yas-tryout-snippet, key binding: C-c C-t C-t When editing a snippet, this opens a new empty buffer,\n1. 可以执行 emacs lisp 命令 `#include \"${1:`(file-name-nondirectory (file-name-sans-extension (buffer-file-name)))`.hpp}\"`\n1. 自动大写`constexpr ${1:type} ${2:$$(upcase yas-text)} = $3;`\n1. `${1:$$(yas-choose-value '(\"right\" \"center\" \"left\"))}` 选择值\n1. c++ man\n\n## Common\n\n1. [stdman](https://github.com/jeaye/stdman.git) 安装 stdman 可以在 emacs 中看 cppreference 内容\n1. 通过整数确定字符在缓冲区的位置，但对缓冲区操作时会引起字符位置变化，可以使用(marker)来跟踪文本位置，会随文本变化而变化。如 set mark [架构之美 235 页](https://github.com/0voice/expert_readed_books/blob/master/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E.pdf)\n1. [keymaps 示意图](https://excalidraw.com/#json=5564509368352768,a62g1lvpbVbiHVddtzRpOQ)\n\n## The Amazing Packages\n\n1. treeemacs\n1. indent-guide\n1. [calctex](https://github.com/johnbcoughlin/calctex)\n1. tmux-cc(注意 emacs 中 tmux 版本大于 3.0a) (set windows.panel)[vim-slime](https://github.com/jpalardy/vim-slime)\n1. woman\n1. emamux\n1. deadgrep\n1. hightlight\n1. bm\n1. company-ispell\n1. beginend\n1. fancy-narrow\n1. ctrlf\n1. mwim\n1. dogears\n1. keycast-mode\n1. command-log-mode: clm/toggle-command-log-buf\n1. symbol-overlay\n1. awesome-tab\n1. eyebrowse\n1. beacon\n1. dimmer\n1. mood-line\n1. smex\n1. keypression\n1. rainbow-mode\n1. rainbow-delimiters\n1. ace-window\n1. helpful\n1. imenu-list\n1. hydra\n1. anzu\n1. move-text\n1. goto-chg\n1. whole-line-or-region\n1. ace jump\n1. clang format\n1. compile and gdb\n1. next error\n1. jump to defination\n1. company\n1. undo tree\n1. which key\n1. expand region\n1. snippets\n1. help mans\n1. M-x: you can use commands to do everything\n1. magit\n1. counsel buffers and files\n1. ibuffer\n1. dired\n1. bookmarks\n1. leader key\n1. org mode and markdown mode\n1. google translate\n1. macro\n1. smartparens\n1. swiper\n1. shift select\n1. flycheck\n1. hungry delete\n1. ox-reveal\n1. crux\n1. leetcode\n1. pdf-tools\n","tags":["Emacs"],"categories":["Tools","Emacs"]},{"title":"Cpp grammar","url":"/2021/09/20/Cpp-grammar/","content":"\n## NOTE:\n\n### basic concept\n\n1. 程序(内存中完全链接): 算法(函数， 代码) + 数据(变量)\n1. 编译(未完全链接)：引用 + 定义 (变量和函数)\n1. 注意内存分布(代码 + 数据)\n1. 编译期，链接期，加载期， 运行期\n1. 语句， 表达式\n1. 作用域， 生命周期， 所有权\n1. 对象何时构造(编译期，运行期)及构造顺序\n\n## 参考代码\n\n1. [perf-ninja 性能比较](https://github.com/dendibakh/perf-ninja/blob/main/GetStarted.md)\n1. [google abseil](https://github.com/abseil/abseil-cpp)\n1. [abseil doc](https://abseil.io/)\n1. [facebook folly](https://github.com/facebook/folly)\n1. [Software Engineering at Google](https://abseil.io/resources/swe-book)\n1. [Software-Engineering-at-Google 中文版本](https://github.com/qiangmzsx/Software-Engineering-at-Google)\n1. [Vitis-AI](https://github.com/Xilinx/Vitis-AI/blob/2.0/tools/Vitis-AI-Library/benchmark/include/vitis/ai/benchmark.hpp)\n1. [Vitis AI demo](https://github.com/Xilinx/Vitis-AI/blob/c26eae36f034d5a2f9b2a7bfe816b8c43311a4f8/src/Vitis-AI-Library/benchmark/include/vitis/ai/demo4.hpp)\n1. [hash-library](https://github.com/stbrumme/hash-library)\n\n<!-- more -->\n\n## [attribute](https://zhuanlan.zhihu.com/p/64493524)\n\n1. `[[maybe_unused]]`\n1. `__attribute__((visibility(\"default\")))` 函数符号不隐藏\n1. `[[deprecated]]/[[deprecated(\"reason\")]]`\n\n## Note\n\n1. std::array 编译期需要确定大小；在栈上分配内存，std::vector 在堆上;在栈上申请内存比堆快 [link](https://zhuanlan.zhihu.com/p/481687008);\n1. `类型擦除`指将原有类型消除或者隐藏，因为很多时候我们并不关心具体类型是什么，我们只需要去使用就可以了，提高提高代码的简洁性。是不是很耳熟，对，抽象继承的多态其实就是比较传统、常见及简单的类型擦除。我们使用的只是抽象接口，而不关心具体实现类的类型。类型擦除常用做法是`多态、模板、通用类型（C++17 std::any|std::variant）、闭包`\n1. 注意区分#ifdef 在头文件和.cpp 中的表现，在头文件中，不同的库也要定义才能生效，如果在.cpp 中，只需要相应 lib 定义就好\n1. [头文件中定义问题](https://blog.csdn.net/sksukai/article/details/105612235)/\n\n## 性能测试 chrono [link](https://github.com/Xilinx/Vitis-AI/blob/master/tools/Vitis-AI-Runtime/VART/vart/util/include/vitis/ai/profiling.hpp)\n\n1. 计时用 steady_clock, timestamp 用 system_clock\n1. steady_clock 是单调的时钟，相当于教练手中的秒表；只会增长，适合用于记录程序耗时；\n1. system_clock 是系统的时钟；因为系统的时钟可以修改；甚至可以网络对时； 所以用系统时间计算时间差可能不准。\n1. high_resolution_clock, 不建议使用\n1. 可以和 glog 与 get_env 结合(性能与 Debug 结合) [link](https://github.com/Xilinx/Vitis-AI/blob/master/tools/Vitis-AI-Runtime/VART/vart/util/include/vitis/ai/env_config.hpp)\n1. [CLOCK_MONOTONIC 与 CLOCK_REALTIME 区别](https://www.jianshu.com/p/1861a844a2fb)\n1. C++11 中的 system_clock::now() 使用 gettimeofday()或者 std::time()，而 steady_clock::now()则使用 clock_gettime(CLOCK_MONOTONIC,\\*);\n\n```\n#include <chrono>\nusing Clock = std::chrono::steady_clock;\n#define __TIC__(tag) auto __##tag##_start_time = Clock::now();\n\n#define __TOC__(tag)                                                  \\\n  auto __##tag##_end_time = Clock::now();                             \\\n  std::cout << #tag << \" : \"                                          \\\n            << std::chrono::duration_cast<std::chrono::microseconds>( \\\n                   __##tag##_end_time - __##tag##_start_time)         \\\n                   .count()                                           \\\n            << \"us\" << std::endl;\n\n```\n\n2. ns\n\n```\n#include <chrono>\nusing Clock = std::chrono::steady_clock;\n#define __TIC__(tag) auto __##tag##_start_time = Clock::now();\n\n#define __TOC__(tag)                                                  \\\n  auto __##tag##_end_time = Clock::now();                             \\\n  std::cout << #tag << \" : \"                                          \\\n            << std::chrono::duration_cast<std::chrono::nanoseconds>( \\\n                   __##tag##_end_time - __##tag##_start_time)         \\\n                   .count()                                           \\\n            << \"ns\" << std::endl;\n```\n\n## [数式编程](https://zhuanlan.zhihu.com/p/45750387)\n\n### map\n\n1. transform\n\n```\n  std::vector<float> vec(10000, 1.111);\n  std::vector<float> vec1(10000, 2.111);\n  std::vector<float> result;\n  // 操作一个vector\n  std::transform(vec.begin(), vec.end(), std::back_inserter(result),\n                 [](const auto item) -> float { return item + 100; });\n  // for_each(vec.begin(), vec.end(), [](auto &item) { item += 100; })\n\n  // 操作两个vector NOTE: 使用前需要检查vec, vec1 size是否匹配。\n  // 性能好 797us 13us(-O3)\n  std::vector<float> result1(10, 0.0);\n  std::transform(vec.begin(), vec.end(), vec1.begin(), result1.begin(),\n                 [](const auto &item1, const auto &item2) -> float {\n                   return item1 + item2;\n                 });\n\n  // 性能差 2605us 173us(-O3)\n  std::vector<float> result2;\n  std::transform(vec.begin(), vec.end(), vec1.begin(),\n                 std::back_inserter(result2),\n                 [](const auto &item1, const auto &item2) -> float {\n                   return item1 + item2;\n                 });\n  // for 463us 70us(-O3)\n  std::vector<float> result3(vec.size(), 0);\n  for (auto i = 0u; i < result3.size(); ++i) {\n    result[i] = vec[i] + vec1[i];\n  }\n\n\n```\n\n### filter\n\n1. copy_if\n2. remove_if\n\n### fold\n\n1. accumulate `float sum = std::accumulate(vec.begin(), vec.end(), 0.0, std::plus<float>());`\n\n### \\_\\_func\\_\\_函数名\n\n```\n#include <stdio.h>\nvoid myfunc(void)\n{\n  printf(\"%s\\n\", __func__);\n}\n```\n\n## RVO 返回值优化 effective modern c++ 166 页\n\n1. 返回值也是函数参数，RVO 直接在位函数返回值分配的内存上创建局部变量来避免复制\n2. 两个条件：\n   - 局部对象类型和返回值类型相同\n   - 返回的就是局部对象本身\n\n## [gcc -O0 -O1 -O2 -O3 四级优化选项及每级分别做什么优化](https://blog.csdn.net/qq_31108501/article/details/51842166)\n\n## [GDB 使用](https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html)\n\n1. .gdbinit gdp 配置文件\n2. 编译要加 -g [link](https://zhuanlan.zhihu.com/p/74897601)\n3. readelf -S xxx|grep debug 查看有没有 debug 段\n4. file xxx 查看有没有 stripped (编译不能加 -s)\n5. -fkeep-inline-functions 调试内联，编译的程序会变大很多\n6. set logging file log.txt, set logging on, set logging overwrite on 记录执行 log\n7. gdb -q 启动时不显示版本等信息\n8. gdb --args xxx ... && r 或 gdb xxx && set args ... && r 或 gdb xxx && r ...\n9. show env xxx 显示环境变量\n10. bt 或 i s(info stack) 显示程序栈 backtrace\n11. l 或 l + 向下显示源码， l - 向上显示源码，l 1,100 打印 1 到 100 行， l xxx:10 显示文件 xxx 第 10 行, l funciton 显示函数，\n12. bt 可以显示运行到哪一行, l -1 或 l +1 显示当前行前后代码\n13. step/finish 进入/返回函数 [link](https://wizardforcel.gitbooks.io/100-gdb-tips/content/finish-and-return.html)\n14. tb 如果想让断点只生效一次，可以使用“tbreak”命令\n15. source script 执行脚本中的命令\n16. p/x c 十六进制打印\n17. d 删除所有断点\n18. watch expr\n19. info functions add 列出 add 函数\n20. 在程序入口处打断点, 先 readelf -h xxx 读入口地址，然后 b \\* 设置断点 [link](https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-entry.html)\n21. set print array-indexes on 打印数组下标\n22. i args 显示函数参数\n23. i locals 打印局部变量\n24. i sharedlibrary 显示共享链接库\n25. whatis xxx 打印变量类型， ptype xxx 打印详细信息，\n26. set history filename ~/.gdb_history， set history save on 保存历史\n27. shell ls 或 !ls 在 gdb 中执行 shell 命令\n28. 可以直接执行 cd 和 pwd\n29. 远程调试：\n30. emacs gdb-many-window, gdb 多窗口调试\n\n## input and output\n\n1. `std::flush` 立即输出， Without std::flush, the output would be the same, but may not appear in real time.\n\n## 标准函数 和 库\n\n1. std::filesystem 库 create_directoriesfile_size, exists, current_path,\n1. std::numeric_limits<float>::max()最大浮点数， std::numeric_limits<float>::lowest() 最小浮点数，注意不是 min。 #include<limits>\n1. std::round()四舍五入 #include<math.h>\n1. std::floor()向下取整 #include<math.h>\n1. std::ceil() 向上取整 #include<math.h>\n1. std::memcmp() 按位比较是否完全相等，解决 if(-0 == 0)问题\n1. std::memset() 只能用于设置连续内存，不能用于 vector [link](https://www.zhihu.com/question/408799127)\n1. int mi = std::min({x1, x2, x3, x4});\n1. std::max_element `auto max_value = *std::max_element(vec0.begin(), vec0.end()); `\n1. std::min_element `auto min_value = *std::min_element(vec0.begin(), vec0.end());`\n1. std::minmax_element `const auto [min, max] = std::minmax_element(vec0.begin(), vec0.end()); std::cout << \"min = \" << *min << \", max = \" << *max << '\\n';`\n\n## 第三方库\n\n1. [json 库集合](https://www.json.org/json-en.html)\n1. [json for modern c++](https://github.com/nlohmann/json)\n1. [jeson benchmark](https://github.com/miloyip/nativejson-benchmark#parsing-time)\n\n## ideas\n\n1. 记录语法时最好能举个例子\n1. `why?`。模块`存在的目的？解决了什么问题？特点特性？优缺点？适用范围？概念？架构？设计思路？具体实现方式？`等方面学习？\n1. 模块的存在的目的，功能作用，实现方式\n1. 按照 Bjarny Stroustrup 列的特性重新进行分类。\n\n## 原则\n\n1. `开闭原则` 软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的\n1. `单一职责原则` 一个类只做一件事\n1. `里氏替换原则` 子类应该可以完全替代父类，也就是说在使用继承时，只扩展新功能，不要破坏父类原有的功能。\n1. `依赖倒置原则` 细节应该依赖与抽象，抽象不应该依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。\n1. `迪米特法则/最少知道原则` 一个类不应该知道自己操作类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。\n1. `接口隔离原则` 客户端不应该依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将该接口拆分，让实现类只依赖自己需要的接口。\n\n## [struct 对齐和补齐](http://www.lingjun.online/2020/07/21/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%82%A3%E7%82%B9%E4%BA%8B/)\n\n结构体的对齐和补齐的规则：\n对齐：假定从零地址开始，每成员的起始地址编号，必须是它本身字节数的整数倍。\n补齐：结构的总字节数必须是它最大成员的整数倍。\n\n## C++ language features\n\n## Concurrency, Parallelism and Async\n\n1. Concurrency(并发): Less freedom for the scheduler(usually because of missing information)\n1. Parallelism(并行): More information provided to the scheduler(thus more freedom)\n1. Serial(串行：单线程) is between concurrency and parallelism.\n1.\n\n### C++ concurrency development\n\n1. C++11: Memory model, Threads, Mutexes and locks, Thread local data, Condition vaviables, Tasks\n1. C++14: Reader-writer locks\n1. C++17: Parallel STL\n1. C++20: std::jthread, Atomic smart pointers, Latches and barriers, Semaphores, Coroutines\n1. C++23: Executors, std::future, extensions, Transactional memory, Task blocks, Data-parallel vector, library\n1. 多线程要统计各个函数的运行时间，根据时间进行线程数比例划分，例如，预处理函数 1s，处理函数 2s，那么给预处理分配 1 个线程，处理分配两个线程，\n\n## OOP\n\n1. Object-Oriented Programming\n1. base class: defines the API\n1. derived classes: provide different implementaions\n\n## Generic Programming\n\n1. 泛型编程主要是为算法流程编写的，不是为数据结构，使算法通用化，可以适应不同的数据结构。\n1. 可以先写一个具体的例子，抽象出算法，屏蔽数据结构（类型）。\n1. `A type: specifies the set of operations that can be applied to an object and specifies how an object is laid out in memory` 类型不仅规定对象的操作集合，还规定对象在内存中的排布\n1. `A concept: Specifies the set of operations that can be applied to an object and says nothing about the layout of the object` Concept 只规定对象的操作集合，不规定对象在内存中的排布。\n1. 模板类是比参数类型 T 更高一级的抽象。模板类实现高一级别的抽象，而不用关心低一级抽象的不同。\n\n### Template\n\n1. typename 关键字用于引入一个模板参数\n1. 使用 typename 标识嵌套类型名称。\n1. 使用从属类型时要加 typename。比如：`typename T::const_iterator iter()`不加 typename 会报错，因为编译器并不知道 T::const_iterator 是一个类型的名字还是摸个变量的名字。\n1. 可变参数模板(c++11 之前参数个数固定不可变)：`template<typename... Args> class test`表示 Args 个数不固定，使用时`void f(Args... args)`\n1. `template <typename T> using xxx = T`\n\n### 模板嵌套\n\n## RAII Resource Acquisition Is Initalization\n\n1. 资源获取初始化：`使用局部对象来管理资源的技术`被称为资源获取初始化。`局部对象`(有生命周期)是指存储在`栈`上的对象，它的生命周期由操作系统管理，无需人工介入。\n1. 利用： C++保证了所有栈对象在生命周期结束时会被销毁(调用析构函数)。\n   - `A a;` 在栈上分配 a\n   - `A* a = new A()` 在堆上分配 a，并在栈上保存 a 的指针，生命周期结束后只释放栈上的指针变量，需要 delete 释放资源。。\n   - `unique_ptr<A> a = make_unique<A>(new A())` 在栈上分配 a，在堆上分配 A 的对象，a 中保存了 A 对象的指针，a 用来管理 A 对象，当 a 生命周期结束，会调用 a 的析构函数，释放 A 对象资源。\n1. RAII 用来自动管理对象，例如 smart pointers，用栈来管理资源。\n1. RAII 流程：设计一个类封装资源，构造函数初始化，析构函数释放资源。\n1. RAII 可以极大地简化资源管理，并有效的保证程序的正确和代码的简洁。\n1. The slogan is about initialization, but its meaning is ready about cleanup.\n1. `resource`: anything that requires specail(manual) management.\n   - Allocated memory(molloc/free, new/delete)\n   - POSIX file handles(open/close)\n   - C FILE handles(fopen/fclose)\n   - Mutex locks(pthread_mutex_lock/pthread_mutex_unlock)\n   - C++ threads(spawn/join)\n   - objective-c resource-counted objects(retain/release)\n1. resource 管理涉及到的操作： 资源释放（destructor)，资源复制(copy constructor)，释放原来资源并复制其他资源(copy assignement operator)，资源所有权转移(move operator)，释放原来资源并转移其他资源(move assignment operator)。\n1. RRID(Resource Release Is Destruction)\n\n### 构造函数，析构函数，copy 构造函数，copy 赋值构造函数，move 构造函数，move 赋值构造函数\n\n1. 全局对象的构造函数在程序进入 main() 函数之前执行\n1. Initialization is not assignment.\n1. `T w = v;` This is an initialization(construction) of a new object. It calls a copy constructor.\n1. `T w; w = v;` This is an assignment to the existing object w. It calls an assignment operator.\n1. 使得函数 default 可能提醒他人调用 default 是可以正常工作的。\n1. 资源释放应该放到析构函数中，避免资源泄露。\n1. 赋值构造函数最好使用 copy-and-swap.这样可以解决 self-copy 等问题。\n1. 析构函数的调用与构造函数反序。\n\n```c++\n// copy assignment constructor\nT& T::operator=(const T& rhs) {\n    T copy(rhs);  // 调用copy构造函数\n    copy.swap(*this);  // good\n    return *this;\n}  // copy will be destruct\n\n// move assignment constructor\nT& T::operatr=(T&& rhs) {\n    T copy(std::move(rhs));  // rhs现在是左值？\n    copy.swap(*this);\n    return *this;\n}\n\n```\n\n### [类对象内存分布](https://blog.csdn.net/dxpqxb/article/details/102794132)\n\n1. [带基类](https://blog.csdn.net/chuncanL/article/details/70306740)\n1. [sizeof(vector<>)大小固定](https://www.zhihu.com/question/34955591)\n1. [虚函数](https://tangocc.github.io/2018/03/20/cpp-class-memory-struct/)\n1. `p/x *(long *)&T` gdb 打印虚表地址 (64 位机器), 对象起始地址前 8 字节\n1. `p/x *(long *)(*(long *)&T + 8)` 打印第 2 个虚函数地址\n\n### 虚析构函数的作用\n\n1. 子类对象析构时一定会调用到子类的析构函数，这可以保证对象的正确析构。（多态时，例如工厂模式，基类需要定义虚析构函数）\n1. 多态发生在父类指针或引用指向子类对象时。此时如果没有虚析构，编译器默认调用父类的析构函数，无法通过父类的指针或引用析构子类对象的空间，此时就有可能发生内存泄漏。当父类析构和子类析构定义为 virtual 虚函数时，就可以顺利通过父类的指针或引用析构子类对象的内存空间。\n\n### 构造析构顺序\n\n1. 构造顺序\n   - 如果某个类具有基类，执行基类的构造函数。\n   - 类的非静态数据成员，按照声明的顺序创建。\n   - 执行该类的构造函数。\n2. 析构顺序：相反\n   - 调用类的析构函数。\n   - 销毁数据成员，与创建的顺序相反。\n   - 如果有父类，调用父类的析构函数。\n\n### The Rule of Three or Five(after c++11)\n\n1. 含义：如果类里面需要管理 resource，例如 rall pointer，那么你需要手写 3 个 functions.否则会调用默认函数，可能会出现多个指针副本，引起悬垂指针等问题。（可以 delete 这些函数，使 non-copyalble)\n   - A destructor to free the resource\n   - A copy constructor to copy the resource\n   - A copy assignment operator to free the left-hand resource and copy the right-hand one.\n   - A move constructor to transfer owenership of resource (after c++11)\n   - A move assignment operator to free the left-hand resource and transfer ownership of the right-hand one(after c++11)\n\n### The Rule of Zero\n\n1. 含义：如果你的类没有管理任何资源，但是使用了库中的 vector，string 等，那么你应该避免写特殊的函数，使用默认函数。\n   - Let the compiler implicitly generate a default destructor\n   - Let the compiler generate the copy constructor\n   - Let the compiler generate the copy assignment operator\n   - (But your own swap might improve performance)\n\n### 两种设计良好的 value-semantic C++类\n\n1. Bussiness-logic classes: 不管理资源，follow the Rule of Zero\n1. Resource-management classes(small, single purpose)： 管理资源(最好使用 RAII)，follow the Rule of Three or Five.\n\n### std::ref 与 reference_wrapper\n\n1. [浅析 std::ref 与 reference_wrapper](https://blog.csdn.net/u014645632/article/details/78966340)\n\n### move\n\n1. move does not move anything. （只是所有权移动，为物理移动任何东西）\n1. move unconditionally casts its input into an rvalue reference(无变量保存的数据)，会将输入变为右值。\n1. move constructor `ClassXX(ClassXX&& w) = default` w 是右值引用\n1. move assignment operator `ClassXX& operator=(ClassXX&& w) = default`\n1. 类成员最好用智能指针。原始指针不能使用默认 move 构造函数。需要自己写 move 构造函数， 分两步： member-wise move and reset。\n1. move asignment operator 分 3 步： cleanup, member-wise move and reset\n1. make move operations(constructor) noexcept\n1. Don't return a T&&.\n1. 使用 move 后，原来的变量不再进行资源释放，它已经将所有权转移给新的变量，由新变量进行资源管理。\n\n### forward\n\n1. `& & = &`, `& && = &`, `&& & = &`, `&& && = &&` 变量，是 lvalue\n1. `void f(T&& x); auto&& var = var1;` 其中 T&&和 auto&&是 forward reference(T 类型不确定，T&&类型要通过推导（模板），如果 T 是确定的，那么是右值引用，如类的 move 构造函数 T 就是类名称)。转发引用。被称为 universal reference.\n1. forward reference 作为参数能接受左值也能接受右值。\n1. 应用: `make_unique`可以传左值和右值。`auto i = make_unique<int>(1); auto s1_ptr = make_unique<string>(s1)`\n1. std::forward（不是 forward reference, 是标准库函数）作用： 如果输入是 lvalue，将其转化为 lvalue reference，如果是 rvalue，将其转化为 rvalue reference。使用原因：当一个函数输入参数是右值，并且需要用到该参数调用其他函数，调用时会将右值转化为左值，因为有了名字。在调用的函数中被当做左值来处理。如果希望是右值，则实现不了。在调用其他函数时，将参数通过 std::forward 转化一下\n1. std::forward does not forward anything。\n1. 问题：forward reference 作为模板的参数时能接收任何参数，容易与其他函数冲突。\n\n### 左值(lvalue) 右值(rvalue)\n\n1. 左值：占据内存中某个可识别位置（有变量保存）的对象\n1. 右值：临时存储，没有变量标识。\n1. 如果表达式的结果是一个暂时的对象，那么这个表达式就是右值。\n1. 如果函数能直接返回，不要起名字。return 右值，否则要使用 move。(RVO)\n\n### && rvalue reference 右值引用\n\n1. 只有左值才能给引用`int nine = 9; int& ref = nine;` 不能`int& ref = 9;`，也不能`int& ref = get_value()`\n1. 右值引用用法：`int&& ref = 9`或`int&& ref = get_value()`\n\n## Lifetime and Allocation Deallocation\n\n1. 指的是 object lifetime，不是类。\n1. 对象涉及到生命周期和内存分配销毁两方面问题。一般生命周期起始分配内存，生命周期结束释放内存。但生命周期可能小于内存分配释放时间，比如 option.\n1. reference 能够延长临时变量生命周期。 `string & s = get_string();`无问题 `char *s = get_string().c_str();`有问题，get_string 返回右值，s 只接受了指针，右值内容被释放。\n\n## Smart Pointers\n\n1. 用来管理 raw pointer，属于资源管理类。\n\n### unique_ptr\n\n1. 防止内存泄露，使所有权清晰。\n1. 唯一所有权， 不能复制，只能 move\n1. 有一个 Deleter 成员变量\n1. 有两个参数，Deleter 有默认\n1. 智能指针传参和返回值应该`按值传递`，这样更简单，而且只会消耗很小的资源(8 字节)，栈上传递，很快.\n1. 不要通过引用传递指针\n\n```c++\ntemplate<class T, class Deleter = std::default_delete<T>>\nclass unique_ptr {\n    T* p_= nullptr;\n    Deleter d_;\n\n    ~unique_ptr() {\n        if (p_) d_(p_);\n    }\n}\n\ntemplate<class T>\nstruct default_delete {\n    void operator()(T* p) const {\n        delete p;\n    }\n}\n\n```\n\n1. 需要调用 free, close 等地方，可以封装为 unique_ptr, sample:\n\n```c++\nstruct FileClose {\n    void operator()(File *fp) const {\n        assert(fp != nullptr);\n        fclose(fp);\n    }\n}\n\nFile *fp = fopen(\"input.txt\", \"r\");\nstd::unique_ptr<File, FileClose> uptr(fp);\n```\n\n### shared_ptr\n\n1. 避免悬垂指针。\n1. shared mean reference counting 引用计数\n1. \"Will the last person out of the room please turn out the lights.\" 最后一个离开房间的人请关灯，人数就相当于引用计数，灯相当于共享的资源。最后一个释放资源。如果房间里还有人就把灯关了，剩下的人就相当于悬垂指针。\n1. 栈上有两部分 ptr to T and ptr to control block。分别指向堆上数据。\n1. uniqe_ptr 可以转化为 shared_ptr，反之不成立。\n\n### make_shared and make_unique\n\n1. 现代的 c++应该避免使用 raw new and delete，智能指针可以避免使用 delete，我们也应该避免使用 new，工厂函数能够避免 new。\n1. make_shared and make_unique 都是`工厂函数`。make_shared 能够产生一个 shared_ptr，make_unique 能够产生一个 unique_ptr\n1. `最好不要使用rall pointer`，。如果不用 rall pointer，就不用担心内存泄露。\n\n### weak_ptr\n\n2. weak_ptr 可以告诉你 xuan\n1. weak_ptr has the same physical layout ad shared_ptr\n1. weak_ptr 不是智能指针。不能对 weak_ptr 解引用\n1. weak_ptr 可以看作是获取 shared_ptr 的 ticket，如果拥有 weak_ptr 就有权获得 shared_ptr。\n1.\n\n### std::enable_shared_from_this\n\n## Cast\n\n### 四种关键字: const_cast, 常量性转除;dynamic_cast, 向下安全转型;reinterpret_cast, 重新解释转型; static_cast, 静态转型;\n\n1.  const_cast, 常量性转除:\n\n主要对变量的常量性(const)进行操作, 移除变量的常量性, 即可以被非常量指向和引用, 详见代码;\n\n2. dynamic_cast, 向下安全转型:\n\n主要应用于继承体系, 可以由 \"指向派生类的基类部分的指针\", 转换\"指向派生类\"或\"指向兄弟类\";\n\nstatic_cast 只能转换为\"指向派生类\";\n\n3. reinterpret_cast, 重新解释转型:\n\n主要是对 2 进制数据进行重新解释(re-interpret),不改变格式, 而 static_cast 会改变格式进行解释;\n\n如由派生类转换基类, 则重新解释转换, 不改变地址, 静态转换改变地址;\n\n4. static_cast, 静态转型:\n\n主要是数据类型的转换, 还可以用于继承;\n\n## Zero Cost Abstract\n\n## Lambdas\n\n1. 用于定义和创建匿名函数。\n1. 语法： `[capture list] (params list) mutable exception -> return type { function body}`\n\n## Macros\n\n1. [C++宏（Macro）的各种玩法](https://blog.csdn.net/qq_22660775/article/details/89255286)\n1. [thread local 来解决 macro 不同线程 static 变量相同问题](https://stackoverflow.com/a/31609246)\n\n### #define\n\n1. `#if __cplusplus < 201703L` 可用宏来兼容 c++11 和 c++17\n\n## Memory\n\n1. 内存分为 host 内存和 device 内存。需要管理 device 上需要大空间的对象，比如 tensor，还需要在 host 和 device 内存中传输数据。输入的数据在 host 端处理后需要发送到 device 上使用，device 上输出结果或 dump 的数据需要在 host 端显示或者保存。不同的设备管理方式不同，当设备段是直接通过物理地址管理内存的，可以在 host 端创建一个对象来管理设备端的内存。\n\n### 内存分配方式\n\n1. `栈` 函数参数，局部变量\n1. `堆` malloc 和 free。堆上操作系统维护的一块内存\n1. `自由存储区` new 和 delete。自由存储区是 C++中通过 new 和 delete 动态分配和释放对象的抽象概念。有些编译器使用 malloc 和 free 实现 new 和 delete。\n1. `全局/静态存储区` 全局变量和 static 变量。\n1. `常量存储区` 存放的是常量，不允许修改。\n\n### 内存管理方式\n\n1. `自动存储`\n1. `静态存储`\n1. `动态存储`\n1. `线程存储`\n\n## Multi Thread\n\n## Small Module\n\n### 值语义与引用语义\n\n1. 值语义(value sematics)指的是对象的拷贝与原对象无关，就像拷贝 int 一样，拷贝之后与原对象脱离关系。\n1. 引用语义(reference sematics)或者对象语义(object sematics)是指面向对象意义下的对象，对象是禁止拷贝的。因为拷贝对象是无意义的，如拷贝一个雇员不会变成两个雇员。\n1. 值语义：复制（赋值操作）以后，两个数据对象拥有的存储空间是独立的，相互之间互不影响。\n1. 引用语义：复制（赋值操作）以后，两个数据对象互为别名。操作其中一个会影响另一个。\n1. 引用语义赋值操作是按位复制，有可能只复制了栈上的数据，为复制堆\n1. 值语义的好处： 生命周期管理很简单，不用担心生命周期。\n1. 引用语义的 object 由于不能拷贝，我们只能通过指针或引用来使用它。需要考虑生命周期来释放资源，避免悬垂指着等。\n1. 使用指针和引用之后所有的赋值代表将有多个变量指向同一个对象，一旦其中一个变量释放了对象的资源，其他的变量的使用将是一个问题。\n1. (zero abstract cost) C++的 class 的 layout 与 C struct 一样，没有额外开销。定义一个只包含一个 int 的 class 的对象和定义一个 int 一样。\n1. 默认拷贝构造函数是最简单的浅拷贝。\n1. 智能指针实际上是将对象语义转化为值语义。\n\n### static\n\n1. [cppreference static members](https://en.cppreference.com/w/cpp/language/static)\n1. [thread local 来解决 macro 不同线程 static 变量相同问题](https://stackoverflow.com/a/31609246)\n1. [类 static 成员变量头文件初始化问题](https://caloud.tencent.com/developer/article/1858485)\n1. C++17 中可以用 inline 来在头文件中定义类的 static 成员变量 [link](https://stackoverflow.com/a/54994044)\n1. 局部 static 变量只被初始化一次，生命周期是从创建到程序结束。相比全局 static 变量只是作用域不是全局。\n1. 如果全局变量仅在单个函数中使用，则可以将这个变量改为该函数的静态局部变量。\n1. 全局变量，静态局部变量，静态全局变量都存在全局静态存储区。\n1. 函数中必须要使用 statci 变量的情况：当某个函数返回值为指针类型时，则必须是 static 的局部变量的地址作为返回值，因为他的生命周期是整个程序运行期间。\n1. static 全局变量限定作用范围为定义该变量的文件。\n1. 子类访问父类定义的 static 成员变量或函数`Son::Parent::xxx()`\n1. static 存储在全局静态存储区，因此父类中定义的 static 变量由所有子类父类对象共享。\n1. 作用\n   - 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n   - 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n   - 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。\n   - 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。\n1. 伪单例： 共享一个变量，但多线程不安全\n\n```c++\ninline std::vector<bool>& is_file() {                                                                                                                                                                                static std::vector<bool> ftype;                                                                                                                                                                                    return ftype;\n}\nis_file() = {true}\n```\n\n1. fps control\n\n```c++\n#define __FPS_CONTROL__(fps)                                                   \\\n  {                                                                            \\\n    static thread_local auto start_time = std::chrono::steady_clock::now();    \\\n    auto end_time = std::chrono::steady_clock::now();                          \\\n    auto time_us = std::chrono::duration_cast<std::chrono::microseconds>(      \\\n                       end_time - start_time)                                  \\\n                       .count();                                               \\\n    int sleep_us = static_cast<int>(1000.0 * 1000.0 / fps) - time_us;          \\\n    if (sleep_us > 0) {                                                        \\\n      std::this_thread::sleep_for(std::chrono::microseconds(sleep_us));        \\\n    }                                                                          \\\n    start_time = std::chrono::steady_clock::now();                             \\\n  }\n```\n\n### 操作符重载\n\n### 作用域\n\n1. `全局作用域`\n1. `局部作用域`\n1. `语句作用域`\n1. `类作用域`\n1. `命名空间作用域`\n1. `文件作用域`\n\n### 函数指针\n\n1. 声明\n\n```c++\ndouble cal(int);   // prototype\ndouble (*pf)(int);   // 指针pf指向的函数， 输入参数为int,返回值为double\npf = cal;    // 指针赋值\n```\n\n1. 作为函数参数\n\n```c++\nvoid estimate(int lines, double (*pf)(int));  // 函数指针作为参数传递\ndouble y = (*pf)(5);   // 通过指针调用， 推荐的写法\ndouble y = pf(5);     // 这样也对， 但是不推荐这样写\n```\n\n### typedef(传统)\n\n1.  任何声明变量的语句前面加上 typedef 之后，原来是变量的都变成一种类型。不管这个声明中的标识符号出现在中间还是最后。\n1.  作用：\n    - 促进跨平台开发\n    - 定义易于记忆的类型名\n1.  使用：\n    - `typedef int* IntPtr; int x = 5; IntPtr = &x; *IntPtr = 1;`\n    - `typedef void (*call_back)(int)； void add_one(int i) {return i+1}; call_back = add_one; call_back(2);` call_back 声明为函数指针\n\n### using(新标准)\n\n1. `using IntPtr = int*;int x = 5; IntPtr = &x; *IntPtr = 1;`\n1. `using V1F = std::vector<float>; using V2F = std::vector<V1F>;`\n1. `using CallBack = void (*)(int)；// using CallBack = decltype((add_one)); void add_one(int i) {return i+1}; CallBack call_back = add_one; call_back(2);`\n\n### overload (重载)and override or overwrite（覆盖或重写） [link](https://blog.csdn.net/Zeno_wrj/article/details/110478916)\n\n1. 类内：Overloading occurs when two or more methods in one class have the same method name but different parameters.\n1. 类间：Overriding or overwrite means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class.\n\n### class 和 struct 区别\n\n1. C++中的 struct 对 C 中的 struct 进行了扩充，可以有成员函数，可以被继承，可以有多态。\n1. struct 和 class 最大的区别是访问权限，struct 成员默认是 public 的，class 默认是 private，struct 继承默认是 public，class 默认是 private。\n1. class 可以定义模板参数，就像 typename，而 struct 不行。\n\n### template 定义时的 typename 和 class 区别\n\n1. 最早使用的 class 可能会造成概念上的混淆，后面加上了 typename 替代 class。\n\n### new/delete 和 malloc/free 区别\n\n1. malloc/free 是 c++/c 标准库函数，new/delete 是 C++运算符，都可以用于动态内存申请和内存释放。\n1. new 一个对象时会调用构造函数，delete 一个对象时会调用析构函数。\n1. 对于非内部累来说，malloc/free 无法满足在对象创建时执行构造函数，在对象销毁时调用析构函数。\n1. 由于内部数据类型的对象没有构造和析构的过程，对他们而言 malloc/free 和 new/delete 是等价的。\n1. 为什么需要 malloc 和 free，因为 C++中经常调用 c 函数，而 c 只能用 malloc 和 free 管理动态内存（堆上）。\n\n### 函数调用的过程\n\n### for each any_of\n\n### rang-based for loop\n\n### std::tuple\n\n1. `std::get<0>(std::make_tuple(3.8, 'A', \"Lisa Simpson\")) `\n1. `float a; char b; string c; std::tie(a, b, c) = (std::make_tuple(3.8, 'A', \"Lisa Simpson\");`\n1. `auto [a, b ,c] = (std::make_tuple(3.8, 'A', \"Lisa Simpson\");`\n\n### std::tie\n\n1. 创建 tuple 的左值引用\n1. 可以用来解 tuple\n1. c++17 之后可以被 structured bindings 替代\n\n### Structured Bindings c++17\n\n1. `const auto &[elem1, elme2] = some_thing;`\n1. `auto [ gpa2, grade2, name2 ] = return std::make_tuple(3.8, 'A', \"Lisa Simpson\");`\n1. 类似引用，结构化绑定是既存对象的别名。不同于引用的是，结构化绑定的类型不必为引用类型。\n1. [reference](https://zh.cppreference.com/w/cpp/language/structured_binding)\n\n### concepts c++20\n\n### modules c++20\n\n### string_view c++17\n\n### std::format c++20\n\n### ranges c++20\n\n### fold expressions\n\n### std::exchange()\n\n### [[deprecated]] attribute\n\n```\n[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n```\n\n### c 中的 const 和 c++中的 const 区别\n\n1. c 语言中只有 enum 能实现真正的常量\n\n### macro 和 inline\n\n### const 关键字作用\n\n### default， delete，override，final，noexcept\n\n1. `final`在基类中指定无法在派生类中重写的虚函数。还可以指定无法继承的类。\n1. 当使用 default 或者 delete 定义构造，析构，复制构造，赋值，move...其中一个时，也需要定义其他的。\n\n### explicit\n\n1. explicit 只能用来修饰类构造函数。作用是声明类构造函数是显示调用的，不能隐式调用。\n1. 只能显示使用`ClassXX a(args)`来创建对象，不能使用`ClassXX a = args`来隐士调用构造函数。\n1. 作为函数参数也必须使用`ClassXX(args)`，不能使用`args`隐式调用构造函数。\n1. 能用就用。\n\n### virtual\n\n1. 接口类(基类)的析构函数需要为 virtual,这样才能正常调用子类的析构函数，如果不为 virtual，那么只会调用基类的析构函数，不会调用子类的。\n\n### 友元\n\n1. 友元函数\n2. 友元类\n3. 友元成员函数\n\n### decltype\n\n1. 获取变量的类型。`int x; decltype(x) y; // y is int`\n2. 可以用于匿名结构体。\n\n### constexpr\n\n1. 常量表达式是指`值不会改变`并且在`编译过程中就能计算结果`的表达式\n1. const int sz = get_size(); sz 不是常量表达式，sz 只是常量，因为值在编译期才确定\n1. 声明为 constexpr 的变量一定是个常量，并且必须用常量表达式初始化。\n\n### add pointer and is pointer remove_pointer\n\n1. 都是类模板，定义在 std 中\n1. `add_pointer<T>`：T 可以是具体类型也可以是类型引用。获取类型的指针，保存在 type 成员变量里。一般和 typede 一起使用`typedef std::add_pointer<x>::type IntPtr; IntPtr i;`\n\n### std::function\n\n1. std::function 是通用多态函数封装器。\n1. 定义：`template < class R, class... Args> class function<R(Args...)` R 为返回类型，Args 为参数。\n1. 例子：`void p(int i) { cout << i;}; std::fuction<void<int>> f = p; f(i);`\n1. 可用来实现函数回调\n\n### std::atomic\n\n## Design Patterns\n\n### 工厂模式\n\n1. 目的：将对象的创建与对象的使用解耦。\n1. `简单工厂函数` 将对象的创建放入到统一工厂函数中，根据类型判断具体创建哪一种类型对象。相当于将耦合问题从使用中转移到工厂函数。扩展性差，每增加一个产品就要修改工厂函数。\n1. `工厂方法模式` 每个产品都有一个工厂函数，相当于将耦合从总的工厂函数中转移到各个产品的工厂函数中，问题：使用时需要包含各个工厂头文件。\n1. `抽象工厂模式` 同工厂方法模式，只不过每一个具体工厂可以可以调不同接口（不是同一个接口传参数）创建不同的产品。\n1. `反射，依赖注入` 由类名来创建对象。相当于工厂方法模式+单例模式。全局有一个总的工厂，工厂里有保存产品类型及其工厂函数的 map 表(使用到函数指针)，每个产品都要有一个工厂，并且需要注册（依赖注入）到总的工厂 map 表中。解决了工厂方法模式中使用问题。map 可以使用全局变量，注册函数写成类的静态函数，就不需要专门设计一个总的工厂类。总工厂生产的产品不由总工厂控制，而是交给子工厂控制，这叫`控制反转`，将子工厂通过注册接口传入到总工厂中，这叫`依赖注入`\n1. `模板工厂模式`\n\n#### Reference\n\n1. [factory method](https://www.cnblogs.com/xiaolincoding/p/11524401.html)\n1. [reflection](https://blog.csdn.net/K346K346/article/details/51698184)\n\n### 单例模式\n\n1. 目的： 保证一个类只有一个实例，并且提供一个访问它的全局访问点，该实例被所有程序模块共享\n1. [reference](https://zhuanlan.zhihu.com/p/37469260)\n1. code\n\n```c++\nclass Singleton\n{\n private:\n\tSingleton() { };  // 私有构造函数，拷贝构造函数和赋值函数，防止创建对象。\n\t~Singleton() { };\n\tSingleton(const Singleton&);\n\tSingleton& operator=(const Singleton&);\n public:\n\tstatic Singleton& get_instance()\n    {\n\t\tstatic Singleton instance;  // 使用local static对象，只在第一次访问get_instance才创建\n\t\treturn instance;\n\t}\n};\n```\n\n### 代理模式\n\n## Program with C\n\n## 接口实现分离\n\n1. `Pimplldiom`(防火墙技术，代理模式？(未提供一个抽象接口)) 将实现细节隐藏于指针背后，比如：分成两个类，一个负责提供接口，一个负责提供实现。负责提供实现的类的对象作为负责提供接口类的私有成员。这种方式只能不能像工厂函数一样由多种实现，因为类中写死了一种实现方式。\n2. `Object Inerface` 将接口定义为抽象类，派生类实现这些借口。类似工厂函数(创建型设计模式)。\n\n## 命令行参数解析\n\n1. glib [usage](https://github.com/kiwibrowser/src/blob/master/third_party/wds/src/mirac_network/gst-test.cpp#L67)[link1](https://gstreamer.freedesktop.org/documentation/application-development/basics/init.html?gi-language=c#the-goption-interface) [link2](https://people.gnome.org/~ryanl/glib-docs/glib-Commandline-option-parser.html)\n2. getopt: see how to use with emacs woman; [link1](https://github.com/Xilinx/Vitis-AI/blob/master/tools/Vitis-AI-Library/usefultools/src/xir2elf.cpp#L38)\n3. [cxxopts](https://github.com/jarro2783/cxxopts): only include header\n\n### Reference\n\n1. [reference](https://blog.csdn.net/TAOKONG1017/article/details/79561856)\n1. [modern-cpp-features](https://github.com/AnthonyCalandra/modern-cpp-features)\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"plugins","url":"/2021/09/13/Plugin-System/","content":"\n## Basic\n1. emacs man dlopen有参考例子\n2. 用作插件：插件技术最大特点是更新插件无需编译主程序，设计良好的系统可以做到在线升级，只更新插件（补丁）\n3. 使用dlopen时链接发生在runtime, 不需要知道函数声明， 而-l链接发生在compile期，需要知道函数声明\n4. libc.so.6 GNU标准c库，含有getchar,system等函数\n\n## VVAS and DeepStream\n1. use gstreamer\n\n## VART and TensorRT\n1. use dlopen\n\n\n## samples\n1. [x3](https://github.com/rhcad/x3py/wiki)\n\n## famous projects\n1. [TensorRT](https://github.com/NVIDIA/TensorRT/blob/eb8442dba3c9e85ffb77e0d870d2e29adcb0a4aa/plugin/common/cudaDriverWrapper.cpp#L28)\n2. [Tensorflow](https://github.com/tensorflow/tensorflow/blob/96493ef750a69c5ab71a1744b282c0c6770df234/tensorflow/core/platform/default/load_library.cc#L27)\n3. [pytorch](https://github.com/pytorch/pytorch/blob/f23f21dafebae49c9670e2e695344edd01867b0c/torch/csrc/deploy/loader.cpp#L373)\n5. [linux](https://github.com/torvalds/linux/blob/master/tools/lib/traceevent/event-plugin.c#L461)\n6. [FFmpeg](https://github.com/FFmpeg/FFmpeg/blob/989febfbd0c986e9e3e0f269a6b22778bf79147b/libavcodec/omx.c#L115)\n7. [opencv](https://github.com/opencv/opencv/blob/c3ac834526c66840835737f03ed1b4d8f711534e/modules/core/src/gl_core_3_1.cpp#L62)\n\n\n## links\n1. [BUILDING A PLUGIN SYSTEM USING DYNAMIC LOADING](https://hackaday.com/2018/07/12/its-all-in-the-libs-building-a-plugin-system-using-dynamic-loading/)\n2. TensorRT [link1](https://github.com/NVIDIA/TensorRT/blob/eb8442dba3c9e85ffb77e0d870d2e29adcb0a4aa/samples/common/common.h#L930) [trtexec](https://github.com/NVIDIA/TensorRT/blob/eb8442dba3c9e85ffb77e0d870d2e29adcb0a4aa/samples/trtexec/trtexec.cpp#L145)\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"Profiling","url":"/2021/08/24/Cpp-Profiling/","content":"\n## great\n\n1. [各种性能分析工具](https://www.brendangregg.com/overview.html)\n1. [easyperf](https://easyperf.net/)\n1. [VAI profiler](https://docs.xilinx.com/r/zh-CN/ug1414-vitis-ai/Vitis-AI-Profiler-%E6%9E%B6%E6%9E%84)\n1. [perf-book](https://github.com/dendibakh/perf-book)\n1. [perf-ninja](https://github.com/dendibakh/perf-ninja)\n1. [基于 CPU 性能调优的必要性和方法](https://www.eet-china.com/mp/a196988.html)\n1. [topics/profiling](https://github.com/topics/profiling)\n1. [Linux_Performance_Analysis_and_Tools](https://hhb584520.github.io/kvm_blog/files/perf/Linux_Performance_Analysis_and_Tools.pdf)\n1. [linuxperf](https://www.brendangregg.com/linuxperf.html)\n\n<!-- more -->\n\n1. [profiling 与性能优化总结](https://zhuanlan.zhihu.com/p/362575905)\n   - 通常在计算密集型（CPU intensive）的任务中 CPU time 会占据较大的比重，而在 I/O 密集型（I/O intensive）任务中 off-CPU time 会占据较大的比重。\n   - 我们把程序在 CPU 上执行的时间（即 user CPU time + system CPU time）称为 CPU time（或 on-CPU time），程序处于睡眠等状态的时间称为 off-CPU time（or blocked time），程序实际运行的时间称为 wall clock time（字面意思是墙上时钟的时间，也就是真实世界中流逝的时间），对于一个给定的线程：wall clock time = CPU time + off-CPU time。\n1. [Linux tracing/profiling 基础：符号表、调用栈、perf/bpftrace](http://arthurchiao.art/blog/linux-tracing-basis-zh/)\n1. [Practical Linux tracing ( Part 1/5) : symbols, debug symbols and stack unwinding](https://medium.com/coccoc-engineering-blog/things-you-should-know-to-begin-playing-with-linux-tracing-tools-part-i-x-225aae1aaf13)\n1. [Perf IPC 以及 CPU 性能](https://zhuanlan.zhihu.com/p/385519404)\n1. [plantegg's blog](https://plantegg.github.io/)\n1. [VART trace](https://github.com/Xilinx/Vitis-AI/tree/master/src/vai_runtime/vart/trace)\n1. [vaitraceTools/mem_perf](https://github.com/Xilinx/Vitis-AI/tree/master/src/vai_runtime/vart/trace/vaitrace/vaitraceTools/mem_perf)\n1. [Vitis-AI-Profiler](https://docs.xilinx.com/r/en-US/ug1414-vitis-ai/Vitis-AI-Profiler?tocId=LjrELULUsJtA_mgGxWE2lQ)\n1. [linux 性能分析工具 perf：十八般武器之 cache](https://zhuanlan.zhihu.com/p/445267642)\n1. [Using perf On Arm platforms](https://static.linaro.org/connect/yvr18/presentations/yvr18-416.pdf)\n1. [viztracer](https://github.com/gaogaotiantian/viztracer)\n1. 谓词替换分支， 谓词函数是一个返回布尔值的函数。\n1. 问 chatgpt 如何优化\n1. [TVM 各种优化方法](https://tvm.hyper.ai/docs/tutorial/tensor_expr#%E7%A4%BA%E4%BE%8B-2%E4%BD%BF%E7%94%A8-te-%E6%89%8B%E5%8A%A8%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95)\n   - 块操作\n   - 循环置换\n   - 向量化\n   - 数组打包\n   - 通过缓存优化块写入\n   - 并行化\n\n## 编译器选项\n\n1. gcc 选项顺序很重要，如果两个选项冲突，则以后一个为准。可以用`-O3 -fno-inline-functions`既使用-O3 的功能又关闭函数内嵌功能。\n\n   - `-O3 -O0` O0 级别\n   - `-O0 -O3` O3 级别\n   - `-O3 -O` O3 级别\n   - `-O0 -O` O0 级别, If you use multiple -O options, with or without level numbers, the last such option is the one that is effective.\n\n1. `-O3` 是编译器的优化级别选项，表示进行高级优化。这个选项告诉编译器进行更多的优化，以提高代码的执行效率。`-O3` 是最高级别的优化选项，它会启用多种优化技术，包括循环展开、函数内联、向量化等。使用 `-O3` 可以显著提高代码的执行速度，但可能会增加编译时间和可执行文件的大小。\n1. `-Ofast` enables all -O3 optimizations. It also enables optimizations that are not valid for all standard-compliant programs. It turns on -ffast-math and the Fortran-specific -fstack-arrays, unless -fmax-stack-var-size is specified, and -fno-protect-parens\n1. `-LNO:simd` 是针对 SIMD（Single Instruction Multiple Data）指令集的优化选项。SIMD 是一种并行计算的技术，它允许在同一时间执行多个数据元素的相同操作，以提高程序的并行性和性能。`-LNO:simd` 告诉编译器使用 SIMD 指令集进行优化，以利用硬件的并行能力。这可以在循环、向量操作和并行计算等方面提高程序的性能。\n1. `-openmp`可以在编译时启用 OpenMP 并行编程的支持，从而实现多线程并行执行，提高程序的性能， 需要注意的是，使用 OpenMP 进行并行编程需要在代码中添加适当的并行指令，如 #pragma omp parallel，来标识需要并行执行的代码块。同时，也需要注意线程间的同步和数据共享，以避免并发冲突和数据竞争的问题。\n1. `-fopenmp-simd -DSIMDE_ENABLE_OPENMP`\n1. `-funroll-loops`强制编译器展开循环。这可能会提高某些循环密集型程序的性能，但也可能使代码体积增大。\n1. `-fprefetch-loop-arrays` 如果目标平台支持，这会在循环中为数组引用生成预取指令。\n1. `-march=native` 为当前运行编译命令的机器优化代码。这会使 GCC 产生针对你的特定 CPU 类型的代码，使用所有可用的指令集和优化。\n1. `-flto` 启用链接时间优化。这在链接时进行全程序分析，可能会产生更好的优化代码，但会增加链接时间。\n1. `-mfpu=neon` 此选项告诉编译器要为 NEON 浮点单元生成代码。这适用于较老的 ARM 架构和编译器版本。\n1. `-march` 使用此选项指定目标架构，例如`-march=armv8-a`。这可以确保编译器针对特定的 ARM 版本生成优化代码。\n1. `-mfloat-abi` 该选项定义了浮点数应该如何在函数调用中传递。有三个选项可以选择：soft、softfp 和 hard。使用 NEON 时，通常建议使用-mfloat-abi=hard。\n1. `-ftree-vectorize` 这是一个优化选项，允许编译器自动将循环转换为使用向量指令。虽然这不是直接与 NEON 相关的，但它可以帮助自动利用 NEON 功能。\n1. `-fprofile-generate / -fprofile-use`用于基于真实数据的反馈指导优化（PGO）。首先使用-fprofile-generate 编译和运行程序来收集数据，然后使用-fprofile-use 再次编译以使用该数据进行优化。\n\n```\nrm -rf *.gcda\ng++ -Ofast -fprofile-generate -o prefetch prefetch.cpp && ./prefetch\ng++ -Ofast -fprofile-use -o prefetch prefetch.cpp && ./prefetch\n```\n\n1. `-DCMAKE_CXX_FLAGS=\"-fprofile-generate\"` 然后运行生成 gcda, 然后 `-DCMAKE_CXX_FLAGS=\"-fprofile-use\"`\n1. `-fauto-profile` 使用 perf 来优化\n1. `软件预取技术`：预取技术可以减少由于缓存未命中而导致的延迟。`__builtin_prefetch` 是 GCC 的内置函数，用于预取数据到缓存。其他编译器可能有类似的指令。\n1. `-ftree-vectorize -funroll-loops`可以组合用\n\n### links\n\n1. [gcc.gnu.org/onlinedocs](https://gcc.gnu.org/onlinedocs/)\n1. [gcc-9.5.0 Optimize-Options](https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Optimize-Options.html#Optimize-Options)\n\n## 程序性能分析步骤\n\n1. `cpufreq-set -g performance` 保持最大频率(频率固定好分析)\n1. `taskset -c 0 ./test` 固定核\n1. `perf stat -ddd ./test`\n1. `perf top -p` 快速的定位热点函数\n1. 火焰图看各函数耗时占比\n1. perf report and annotate 查看热点函数的热点代码\n1. profiling table 统计代码具体时间\n1. flamescope 看 hot map\n1. speedscope\n\n## 60s 操作 bpf\n\n1. uptime -----> `load averages` [link](https://zhuanlan.zhihu.com/p/75975041) [link1](https://blog.51cto.com/u_15077533/4173309)\n\n   - Linux load averages 不仅可以用于追踪 runnable 任务，还可以跟踪不间断睡眠状态下的任务（uninterruptible sleep state）。\n   - 如果 1min 平均值高于 5min 或 15min 平均值，则负载正在增加, 如果 1min 平均值低于 5min 或 15min 平均值，则负载正在减少\n   - 如果它们高于系统 CPU 的数量，那么系统很可能会遇到性能问题（视情况而定）\n   - 当 load averages 首次出现在 Linux 中时，就像其他操作系统一样，它们反映了 CPU 的需求。但后来在 Linux 上将它们改为不仅包括 runnable 任务，还包括处于不间断状态的任务（TASK_UNINTERRUPTIBLE 或 nr_uninterruptible）\n   - 这证实了故意改变 load averages 以反映对其他系统资源的需求，而不仅仅针对于 CPU 资源。Linux 从 “CPU load averages” 变为 “system load averages”。\n\n1. dmesg -T | tail ------> `kernal erros`\n1. vmstat 1 ------> `overall stats by time`\n1. mpstat -P ALL 1 -----> `CPU balance`\n   - `sudo apt install sysstat`\n   - 可以查看多核心 cpu 中每个计算核心的统计数据；\n   - Report CPU statistics.\n1. pidstat 1 -----> `process usage`\n   - 可以看进程分配在哪一个 cpu 核上\n1. iostat -xz 1 -----> `iostat -xz 1`\n1. free -m -----> `memory usage`\n   - man free 查看各个字段含义\n   - cat /proc/meminfo 有更详细内存占用\n1. sar -n DEV 1 -----> `network I/O`\n1. sar -n TCP,ETCP 1 -----> `TCP stats`\n1. top -----> `check overview`\n\n## roofline\n\n1. [roofline 数据收集方法](https://crd.lbl.gov/assets/Uploads/ECP20-Roofline-4-cpu.pdf)\n1. 为什么不能达到屋顶上方？因为算出了最大 FLOPS 和最大内存带宽，有比率，假设是线性对应关系，给了算术密度，有了计算性能， 最大带宽就是在线上。不能超过线。\n1. 其中 x 轴表示`算术密度`（每个访问的字节所做的浮点操作数），y 轴表示性能（通常是 FLOP/s，即每秒浮点操作数）。如果代码在带宽屋顶下方但接近于它，那么可能会受到内存带宽的限制。相反，如果代码在计算屋顶下方但接近于它，那么它可能受到计算能力的限制。\n1. 算术密度(FLOPs/Byte), (速率或总量， 知道总操作数和总访问量也可以)\n1. 注意 FLOPS 和 Flops 区别。 FLOPS = Flops/s\n1. 转折点为最大性能，最大带宽（可由计算密度算）\n1. 程序算术密度点大于转折点所在算术密度就是计算密集型程序。小于则是访存密集型。\n1. 和 IPC 有何关联？\n1. Roofline 模型讲的是程序在计算平台的算力和带宽这两个指标限制下，所能达到的理论性能上界，而不是实际达到的性能，因为实际计算过程中还有除算力和带宽之外的其他重要因素，它们也会影响模型的实际性能，这是 Roofline Model 未考虑到的。例如矩阵乘法，会因为 cache 大小的限制、GEMM 实现的优劣等其他限制，导致你几乎无法达到 Roofline 模型所定义的边界（屋顶）。\n1. [MegPeak——让你更懂你的处理器](https://zhuanlan.zhihu.com/p/522007924)\n1. [Accelerating HPC Applications with NVIDIA Nsight Compute Roofline Analysis](https://developer.nvidia.com/blog/accelerating-hpc-applications-with-nsight-compute-roofline-analysis/)\n1. [Uploads/ECP20-Roofline-1-intro.pdf](https://crd.lbl.gov/assets/Uploads/ECP20-Roofline-1-intro.pdf)\n1. Roofline 模型是一个可视化工具，用于表示计算系统的性能上限，并帮助识别应用程序的性能瓶颈。它通过绘制两个关键性能指标（算术密集度和峰值性能）来显示应用程序或某一计算部分的性能相对于理论峰值性能的位置。\n1. 确定应用程序或代码段的总浮点操作次数和所访问的内存量?\n1. `likwid-bench`可以算 roofline\n1. [Roofline Model 与深度学习模型的性能分析](https://zhuanlan.zhihu.com/p/34204282)\n\n## [simd library](https://www.reddit.com/r/cpp/comments/106ivke/simd_intrinsics_and_the_possibility_of_a_standard/)\n\n1. [highway cpu 向量加速库 SIMD](https://github.com/google/highway)\n   - [获取支持的加速硬件](https://github.com/google/highway/blob/f86369577e9f884f9156dddbf03ee786493c67f9/hwy/examples/benchmark.cc#LL245C5-L245C31)\n   - `cat /proc/cpuinfo` 看 flags\n1. [eve](https://github.com/jfalcou/eve)\n1. [xsimd](https://github.com/xtensor-stack/xsimd)\n1. [图像处理与机器学习 Simd](https://github.com/ermig1979/Simd)\n1. [parallelism TS v2](https://en.cppreference.com/w/cpp/experimental/simd)\n1. [simde](https://github.com/simd-everywhere/simde)\n\n## 性能基准测试\n\n1. [spec](https://www.spec.org/) 需要 ios 文件\n1. [SpecCPU2017 测试 cpu 性能](https://www.cnblogs.com/xiaoqi-home/p/15981359.html)\n\n## [sysstat](https://github.com/sysstat/sysstat)\n\n## [top](https://www.jianshu.com/p/af584c5a79f2)\n\n1. man top\n1. ? help\n1. RES=CODE+DATA 进程使用的、未被换出的物理内存大小\n1. 内存主要关注物理内存, 虚拟内存表示程序文件及链接库大小，并不是所有的都加载到内存\n1. used mem = total - free - buffers - cache （man free 可以看计算公式),\n1. 主要看 `avaliable` < free + buff/cache\n1. 纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到 free 中去，因此在 linux 上 free 内存会越来越少。\n1. %MEM -- Memory Usage (RES) A task's currently used share of available physical memory. 当前使用的物理内存 / 总的物理内存\n\n## proc 获取信息\n\n1. `/proc/[PID]/stat`\n\n## Basic\n\n1. 估计模型运行帧率时需考虑： 内存耗时和计算耗时； 要搬运的内存和内存读写速度可以算出一帧的耗时\n1. `性能分析` 和 `性能优化` 两大部分。\n1. eigen 矩阵可以向量化，Eigen::Map 问 chatgpt\n1. 矩阵乘法是计算密集型运算。为取得良好的 CPU 性能，有两个重要的优化： [link](https://tvm.hyper.ai/docs/tutorial/tensor_expr#%E7%A4%BA%E4%BE%8B-2%E4%BD%BF%E7%94%A8-te-%E6%89%8B%E5%8A%A8%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95)\n   - `提高内存访问的缓存命中率`。高缓存命中率可以加速复杂的数值计算和热点内存访问。这需要将原始内存访问模式转换为适合缓存策略的模式。\n   - `SIMD（单指令多数据）`，又称向量处理单元。在每个循环中，SIMD 可以处理一小批数据，而不是处理单个值。这需要将循环体中的数据访问模式转换为统一模式，以便 LLVM 后端可将其降低到 SIMD。\n1. `效率 = 有效量 / 理论量 = 有效量 / (理论峰值量 * 时间) = 有效量 * fps / 理论峰值量`\n1. op 计算效率：根据 op 算法算出计算量 C（可用 highway 函数统计 cycle)， 测出实际耗时 t, 已知理论峰值算力 O/s; `计算效率 = 计算量 / 理论计算量(峰值算力 * 实际耗时) = C / (O * t) = C * fps / O` ？\n1. op io 效率 `io效率 = io量 / 理论io量(峰值IO * 实际耗时)`\n1. 模型算力利用率： `利用率 = 模型计算量 / 理论计算量(峰值算力 * 实际耗时) = 模型计算量 * fps / 峰值算力`\n1. 提高 cache 命中率软件方法：\n   - 连续访存\n   - 分块\n1. 向量处理器可以设置步幅，访问步幅确定的非连续内存也有比较高的性能\n1. 在栈上申请内存比堆快, 不是运算快 [link](https://zhuanlan.zhihu.com/p/481687008);\n1. MIPS: 每秒执行了多少百万条指令。DMIPS：D 是 Dhrystone 的缩写，在 MIPS 前面加上 Dhrystone （整数运算），用于测整数计算能力。进程占用 DMIPS = 总的 DMIPS \\* 进程占用 CPU 百分比\n   - [ARM 各内核系列整型运算能力对比---DMIPS / MHz](https://blog.csdn.net/qq_21475601/article/details/106564903)\n   - A55 单核算力： 2.7DMIPS/MHz\\*1.2GHz=3.24 KDMIPS\n   - 评估算力： 某个平台 top（隔几秒统计一次）看各进程 cpu 占比(max, mean)，根据 cpu 占比计算进程占 DMIPS， 所有进程加起来看是否超过另外一个平台总算力\n1. 函数计算量评估方法：\n   1. 假设平台的最大计算量是 M，函数运行时的 CPU 占用率是 p%，函数的计算需求 C 可以大致估计为 C = M \\* p%。 然后通过函数的帧率 f 来估计每帧的计算需求：C_frame = C / f。\n1. ![cpu gpu npu算力单位](https://mmbiz.qpic.cn/sz_mmbiz_png/2icOarNW84W7BnJpVvdnUeOgJYHibeWJbd4z0KJu556ykzgnjl7MHm5YWyjWDqR7eMPmXIWSWCFy8KG3dJQD8O8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n1. [抛弃 ARM，高通第五代汽车芯片](https://mp.weixin.qq.com/s/uTp9DXsG0pzTbyux1JgHMA)\n1. 芯片指令解码位宽对 IPC 有直接影响\n1. 提高性能方法： 充分利用并行， 局部性原理\n\n1. 并行加速：\n\n   - `数据级并行（DLP）`，它的出现是因为可以同时操作许多数据项。\n\n     - `指令级并行`: 在编译器的帮助下，利用流水线之类的思想适度开发数据级并行，利用推理执行之类的思想以中等水平开发数据级并行。\n     - `SIMD`： 向量体系结构和图形处理器（GPU）将单条指令并行应用于一个数据集，以开发数据级并行。\n\n   - `任务级并行（TLP）`，它的出现是因为创建了一些能够单独处理但大量采用并行方式执行的工作任务。\n\n     - `线程并行`：线程级井行在一种紧耦合硬件模型中开发数据级并行或任务级并行，这种模型允许在并行线程之间进行交互。\n     - `请求级并行`: 在程序员或操作系统指定的大量去耦合任务之间开发并行。\n\n1. 局部性原理\n\n   - 时间局部性：最近访问过的内容很可能会在短期内被再次访问\n   - 空间局部性：地址相互临近的指令或数据很可能会在短时间内被用到\n\n1. 加速比(归一化)： 原执行时间 / 新执行时间 = 1 / ( (1 - 升级比例) + (升级比例/升级加速比))；新执行时间 = 不能加速部分 + 加速后部分 = 不能加速部分 + 加速部分/加速部分加速比\n1. Amdahl 定律：根据加速比， 可以得到\n\n   - 如果仅改进一部分计算的性能，在增加改进是，所获得的加速比增量会逐渐减小\n   - 加速比有最大值： 1 / ( 1 - 升级比例)\n\n1. 感知系统优化方案（从系统上分析)：\n\n   - 整体 pipeline 调度优化: 线程优先级， 各模块多线程，异步\n   - 整体数据流优化： 合并前处理操作， rgba 在 rgb 转 nchw 时来做， memory_pool, zero copy\n   - 模型+后处理联合优化：sigmoid 在后处理做, 反算阈值，sigmoid 之前先过滤， 优化 cpu 热点代码\n   - cuda 算子， neon 加速\n\n1. 关注数据流，具体哪一步耗时\n\n1. data packing:\n   - 注意 struct 成员变量顺序，尽量减少 padding\n1. 访存优化：\n\n   - 连续访问\n   - 不要重复访问（可以先用临时变量存下来)\n\n1. 软硬算法联合优化\n1. 编译器：\n\n   - 打开编译器优化报告\n   - 编译器参数：-O3(启动与机器无关的优化功能) -march=armv8.2-a(启动针对特定 CPU 系列的优化功能) -flto(启动过程间优化功能)\n   - gcc -fopt-info 输出优化报告\n\n1. 技术栈:\n\n   - 第一个就是编译器，你可能不需要更深入理解编译器的具体的原理，但是你要了解编译器通用的编译优化手段，以及它有比较通用的一些编译优化的选项。\n   - 第二个就是 OS 的一个调度，还有一个可能 CPU 绑核。在手机上的话，绑核还是很明显的，如果是在小核上和大核，要是中核，它们也差距很多。硬件的限制。如果你想你的任务要跑特别快，比如假如一个特别重要的前台功能，你需要把你的主线程一个界面相关的线程可能就要绑定到大核上，让他跑这么快。\n   - 第三个在硬点上，我可能我们要比较了解 CPU 的微架构是什么样的， CPU 微架构什么样的，为什么我的代码跑的时候它就慢，慢又拆解为几类，怎么去分析它。第二个你要去可能要去尝试的去学习，怎么去读或者改这些汇编的一些指令。\n\n1. 系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。\n1. [性能静态分析（定量）](https://zhuanlan.zhihu.com/p/419859575)\n\n   - [Parallelware Analyzer](https://www.jianshu.com/p/a0296d5b91bc)\n\n1. [性能指标](https://zhuanlan.zhihu.com/p/343408130)\n   - latency(延迟或响应时间)\n   - throughput()\n   - 资源使用率 (资源：处理器，内存，IO)\n     - cpu(不大于 75%)\n     - 内存(不大于 80%)\n     - IO(磁盘, 网络)\n   - 错误率\n1. latency 和 throughput (延迟和吞吐量)\n   - throughput(速度？)：吞吐量一般指相当一段时间内测量出来的系统单位时间处理的任务数或事务数。如：1s 处理 10 帧图片 (10FPS)\n   - latency: 执行一次任务需要的时间。如：处理一帧图片耗时 10ms\n   - latency 最大值：每个节点最大耗时叠加在一起，就是整体 pipeline 的 latency 最大值，即一帧最大需要多少时间输出结果，这个 latency 值尽量越小越好；\n   - 目标：低延迟，高吞吐\n   - 提高吞吐：提升 node 处理速度或异步流水线， 异步流水可能会增加延迟（较好提升, 有两种方法)\n   - 降低延迟：提升 node 处理速度， 优化关键点，也会增加吞吐(容易遇见瓶颈)\n   - 提升 node 处理速度能够同时提高吞吐和降低延迟。\n1. 流水线深度(硬件执行单元个数)，buffer 数量(处理多少帧)关系\n\n   - 如果完全流水起来， buffer size 不小于流水线深度，流水线帧率由耗时最大的 node 决定: 1 / max(node time)\n   - (异步处理比较重要 queue size)\n   - node 之间相互不影响，buffer size 大于流水线深度通常作用不大， 同一时刻所有 node 只能处理流水线深度的 buffer，但如果 node 之间相互影响，不好推测 buffer size 大小。\n   - node 之间相互影响：buffer size 不影响其他功能越大越好\n   - [流水线深度](https://zhuanlan.zhihu.com/p/66933636)\n\n1. 提升 node 处理速度方法：\n   - 减少运算量(降低算法复杂度)\n   - 加速库(如：硬件加速) 或更换更强硬件\n   - 多线程\n   - 减少资源申请与释放(如 memory pool, thread pool)\n   - 减小内存拷贝(如：零拷贝)\n   - 内存使用优化：如模型多个输出，申请一次大内存，偏移量来寻址。\n   - 空间换时间(如查表法)\n   - 语言特性：内联函数\n   - 提高 cache 命中率(如：矩阵变数组，连续访问会提高 cache 命中率)\n   - 改变运算方法(如 sigmoid 后再做处理，减少指数运算)\n1. 异步方法(流水线)\n   - 多线程\n   - 增加 buffer 数\n   - 调度优化\n   - 多流水线(pingpang)\n1. [定位和优化程序 CPU、内存、IO 瓶颈](https://bbs.huaweicloud.com/blogs/detail/222032)\n   - 两个方向：`提⾼运⾏速度 + 减少计算量`\n   - 先建立测试`baseline`\n   - 瓶颈点可能有多个，如果不解决最狭窄的瓶颈点\n1. 调研性能瓶颈，如何对系统性能进行分析。\n1. 单例 perf table\n1. 计算密集型\n   - 减少不必要计算\n1. 访存密集型\n   - 提高 page 和 cache 命中率\n   - 减少不必要访存\n1. IO 密集型\n\n## 理论性能评估\n\n1. 理论 GPU 使用时间计算：各模型的推理耗时是单模型实测值，GPU 时间片按照各自的设计帧率（如 15Hz (fps)）× 推理耗时得到，是个纯理论计算的值。总和为各部分理论值相加，820 为理论值，这个值如果大于 1000 则系统无法达成。\n1. 单模型推理时间 \\* fps = 模型占用 gpu 时间, 所有模型时间不能超过 1000ms;\n1. 有了各个模型推理时间也可以算理论最大帧率；（未考虑模型对计算资源的抢占，锁）\n\n## [推理优化](https://www.cnblogs.com/Matrix_Yao/p/13181778.html)\n\n1. [深度模型推理加速的术与道](https://www.6aiq.com/article/1662281420188)\n1. 减少 sigmoid 的使用(非常耗时)，可以放到后处理来做，根据 sigmoid 公式， 反算阈值，过滤之后再进行计算\n\n### 算子融合\n\n1. 算子融合基于对深度学习拓扑结构模式的观察。深度学习算子按其对资源的需求可以分为两类：\n\n   - 计算密集型算子，这些算子的时间绝大部分花在计算上，如卷积、全连接等。\n   - 访存密集型算子，这些算子的时间绝大部分花在访存上，他们大部分是 element-wise 算子， ReLU，eltment-wise sum。\n\n## cpu time and off-cpu time\n\n1. [profiling 与性能优化总结](https://zhuanlan.zhihu.com/p/362575905)\n\n## 性能调优方法\n\n### PMC(Performance Monitoring Counters)\n\n### [循环展开](https://zhuanlan.zhihu.com/p/553771789)\n\n1. 计算能力（GFlops）和访存速度（MB/s）的矛盾，在汇编语言中就是取指令（load）和计算（ALU）的矛盾。访存和计算天然是两种独立的资源，两者可以独立运行互不影响。\n1. 当循环次数变少，循环体增多的时候，`CPU在执行循环体的过程中就有了更大的操作空间进行指令调度(inline也有这个作用)`，在计算 a[i]的时候就可以去调度 a[i+1]相关的指令（取数据）和 a[i-1]相关的指令（存数据），因此 CPU 流水线更满载，也就提高了性能。\n1. 循环展开可以减少分支预测的次数\n1. 一般不需要手动优化，-O2 会自动展开， -O1 不会\n1. perf annotate 可以看出循环有开销(判断，跳转或 index 操作)， cpu 流水线并行性低\n\n### 分支预测\n\n1. 推理：在还不确切知道是否真的需要某一条指令时，就先执行改指令。如果预测错误，就需要清理流水线。\n\n### 预取\n\n1. 数据和指令预取\n1. 硬件和软件预取\n\n### [IPC (instruction per cycle)](https://zhuanlan.zhihu.com/p/385519404)\n\n1. `tiptop`\n1. `perf stat` 可以查看\n1. 当比较不同的指令集时，与使用相同芯片技术实现更复杂的指令集相比，更简单的指令集可能会导致更高的 IPC 数字。但是，更复杂的指令集可能能够以更少的指令实现更多有用的工作。\n1. 确定： `计算密集型或访存密集型`\n1. 如果 IPC < 1.0, 很可能是 Memory stall 占主导，可从软件和硬件两个方面考虑这个问题。软件方面：减少不必要的访存操作，提升 cache 命中率，尽量访问本地节点内存；硬件方面：增加 cache 容量，加快访存速度，提升总线带宽。\n   如果 IPC > 1.0, 很可能是计算密集型的程序。可以试图减少执行指令的数量：消除不必要的工作。火焰图 CPU flame graphs，非常适用于分析这类问题。硬件方面：尝试超频、使用更多的 core 或 hyperthread。作者根据 PMU 相关的工作经验，设定了 1.0 这个阈值，用于区分访存密集型(memory-bound)和计算密集型(cpu-bound)程序。读者可以根据自己的实际工作平台，合理调整这个阈值。\n1. [cpu-utilization-is-wrong](https://www.brendangregg.com/blog/2017-05-09/cpu-utilization-is-wrong.html)\n1. [CPU 最高性能预估之“理论最大 IPC”](https://zhuanlan.zhihu.com/p/364661188?utm_source=zhihu&utm_medium=social&utm_oi=26748628500480)\n1. [IPC 测试，可以预估最大 IPC](https://zhuanlan.zhihu.com/p/385519404)\n1. ipc 是指每个 core 的 IPC\n1. [用 CPI 火焰图分析 Linux 性能问题](https://cloud.tencent.com/developer/article/1517979) 使用 CPI 火焰图，可以很方便地做 CPU 利用率的分析，找到和定位引发 CPU 停顿的函数。一旦找到相关的函数，就可以通过 perf annotate 命令对引起停顿的指令作出进一步确认。\n\n### CPI(Cycle Per Instruction)\n\n### 绑核\n\n1. taskset\n1. `taskset -c 3,5 firefox`\n1. taskset 超出核心数程序可能更快， why?\n\n### memory bound\n\n### SSE（Streaming SIMD Extensions）\n\n### SVE(Scalable Vector Extension)\n\n1. 是 arm AArch64 架构下的下一代 SIMD 指令集，旨在加速高性能计算，SVE 引入了很多新的架构特点\n\n### 多发射处理器\n\n1. 多发射处理器相对于向量处理器的潜在优势在于它们能够从结构化程度较低的代码中提取某些并行，以及能够很轻松地缓存所有形式的数据。因为这些原因，`多发射方法已经成为利用指令级并行的主要方法`，而向量主要作为这些处理器的扩展。\n1. 目标就是允许在一个时钟周期中发射多条指令。多发射处理器主要有以下 3 类。\n\n#### 静态调度超标量处理器\n\n1. 由于静态调度超标量的收益会随着发射宽度的增长而逐渐减少，所以静态调度超标量主要用于发射宽度较窄的情况，通常仅有两条指令\n1. 大多属于嵌入式领域， MiPS 和 ARM ，包括 ARM Cortex-A8\n\n#### VLIW( 超长指令字)处理器\n\n1. [计算机指令集架构 – 超长指令字（VLIW）](https://zhuanlan.zhihu.com/p/337749676)\n1. 大多数属于信号处理领域，比如 TI C6x\n\n#### 动态调度超标量处理器\n\n1. Intel Core i3 、i5 ， i7. AMD Phenom, IBM Power7\n\n### cache\n\n1. LLC: last level cache 最后一级缓存，比较关键\n\n### 提高 cache 性能\n\n处理器的缓存（通常是 L1、L2 和 L3）旨在减少从主内存访问数据所需的时间。它们存储了最近或经常访问的数据副本，从而提高了数据访问速度。为了充分利用缓存并提高程序性能，你可以遵循以下一些方法和建议：\n\n1. **局部性原理**：\n   - **时间局部性**：如果某个数据项被访问，那么在近期它可能再次被访问。\n   - **空间局部性**：如果某个数据项被访问，那么它附近的数据项也可能会很快被访问。\n     为了利用这种局部性，尝试在连续的内存地址上组织和访问数据（例如，使用数组而不是链表）。\n2. **避免伪共享**：确保并发运行的线程访问的数据不位于同一缓存行上，因为这可能会导致缓存无效并减慢性能。\n3. **数据对齐**：确保数据结构按照缓存行大小进行对齐，这可以减少跨多个缓存行的数据访问。\n4. **预取策略**：如果可能，尝试预测下一次需要的数据并预先加载它。一些编译器和硬件支持数据预取指令。\n5. **减少缓存失效**：\n   - 将常用的数据放在一起。\n   - 避免大的数据结构，它们可能会频繁地导致缓存失效。\n   - 在可能的情况下，使用更小的数据类型。\n6. **循环分块/循环重排**：这是一种技术，可以将大的循环重组为更小的块，从而更好地适应缓存。这尤其适用于多层嵌套的循环。\n7. **避免不必要的写回操作**：只在数据确实更改时写入，以减少不必要的写回到主内存。\n8. **使用只读和常量数据**：如果数据不需要更改，将其标记为常量可以帮助编译器进行优化。\n9. **控制数据的分配和布局**：例如，在 C++中，你可以使用自定义分配器来控制对象在内存中的位置。\n10. **利用非统一内存访问 (NUMA) 架构**：在多处理器系统上，确保线程尽可能在与其数据最近的处理器上运行。\n11. **监控和剖析**：使用工具（如`perf`、`VTune`等）来分析你的程序，找出缓存失效的热点，并对它们进行优化。\n\n#### [cache line](https://plantegg.github.io/2021/05/16/CPU_Cache_Line%E5%92%8C%E6%80%A7%E8%83%BD/)\n\n1. 一般 size 64 byte (512bit)\n1. `getconf -a | grep CACHE` 查看各级 cache line size\n1. `lscpu -C`\n1. `likwid-topology`显示有关硬件拓扑的详细信息，例如 CPU、缓存、NUMA 域等。\n\n#### cache 一致性\n\n1. [在线体验 MESI 协议状态转换](https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm)\n1. [cache 相关动画](https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm)\n\n#### cache miss\n\n1. 应用程序的读占比越高，对缓存越友好；访问的字长越大对预取越友好；同等数量的指令内存依赖越低，CPI 会越高。\n1. `sudo perf stat -d -d -d -a -- sleep 10`\n1. `sudo perf stat -e cache-misses ls`\n1. `sudo cachestat-bpfcc 2`\n1. `sudo cachetop-bpfcc`\n\n#### prefetch\n\n1. 预取是一种优化技术，它允许 CPU 提前加载将要访问的数据到缓存中，以便在实际访问数据时可以更快地获得它。预取可以减少由于缓存未命中引起的等待时间。\n1. 硬件预取：现代 CPU 已经有自己的硬件预取策略。在某些情况下，手动的预取可能会与硬件的预取策略发生冲突，导致性能下降。\n1. ` __builtin_prefetch(&data[i + 16], 0, 1);  // 预取下一个将要访问的数据`\n\n#### 伪共享\n\n1. 伪共享发生在以下情况下：\n   - 两个或多个处理器核心在它们各自的本地缓存中读/写不同的变量。\n   - 这些变量恰好位于同一缓存行中。\n1. 避免：\n   - 数据对齐：确保经常由不同线程访问的数据在不同的缓存行上。许多编译器和平台都提供数据对齐指令或属性。\n   - 填充：在数据结构中添加填充，使每个线程访问的数据元素都有一个完整的缓存行。\n   - 局部变量：尽量使用线程的局部变量，因为它们通常存储在栈上，并且不太可能与其他线程的变量共享缓存行。\n   - 避免细粒度并行：如果任务太小，线程间的同步和伪共享可能会抵消并行处理的好处。\n1. sample, 避免伪共享更快\n\n```c++\n#include <chrono>\n#include <iostream>\n#include <thread>\n\nusing Clock = std::chrono::steady_clock;\n\n#define __TIC__(tag) auto __##tag##_start_time = Clock::now();\n\n#define __TOC__(tag)                                                           \\\n  auto __##tag##_end_time = Clock::now();                                      \\\n  std::cout << #tag << \" : \"                                                   \\\n            << std::chrono::duration_cast<std::chrono::microseconds>(          \\\n                   __##tag##_end_time - __##tag##_start_time)                  \\\n                   .count()                                                    \\\n            << \"us\" << std::endl;\n#define ITERATIONS 1000000000\n\n// 伪共享情况\nstruct SharedData {\n  long value1;\n  long value2;\n};\n\n// 避免伪共享的情况\nstruct PaddedData {\n  long value1;\n  char padding[64]; // 通常缓存行的大小为64字节\n  long value2;\n};\n\nvoid updateValue1(SharedData *data) {\n  for (long i = 0; i < ITERATIONS; i++) {\n    data->value1 += i;\n  }\n}\n\nvoid updateValue2(SharedData *data) {\n  for (long i = 0; i < ITERATIONS; i++) {\n    data->value2 += i;\n  }\n}\n\nint main() {\n  SharedData data;\n  __TIC__(TEST)\n  std::thread t1(updateValue1, &data);\n  std::thread t2(updateValue2, &data);\n  t1.join();\n  t2.join();\n  __TOC__(TEST)\n\n  PaddedData paddedData;\n  __TIC__(TEST_WITH_PADDING)\n  std::thread t3([&paddedData] {\n    for (long i = 0; i < ITERATIONS; i++) {\n      paddedData.value1 += i;\n    }\n  });\n  std::thread t4([&paddedData] {\n    for (long i = 0; i < ITERATIONS; i++) {\n      paddedData.value2 += i;\n    }\n  });\n  t3.join();\n  t4.join();\n  __TOC__(TEST_WITH_PADDING)\n\n  return 0;\n}\n```\n\n## Notes\n\n1. Release 模式编译\n1. 看 cpu 使用率 log 重定向到/dev/null。 `> /dev/null 2>&1`\n1. log 重定向到文件, 不要打印到 stdout\n   - `> output.log 2>&1` this will redirect both STDOUT and STDERR to the file.\n   - `2>&1 > output.log` the old STDOUT will be saved (copied) in STDERR and then STDOUT will be redirected to file. So, stdout will go to file and stderr will go to console.\n   - `2>&1 | tee output.log` both streams will be redirected to tee. Tee will duplicate any input to its stdout (the console in your case) and to file (output.log).\n1. GPU 函数耗时统计不能只记录一次的，GPU 可能做一些准备工作，教训： nppiResize_8u_C3R 不管大小第一次运行耗时都很大 The cuda context is lazily initialized\n1. -O3 测试\n1. perf stat ./xxx 测试程序运行时间\n\n## Tools\n\n### [likwid](https://github.com/RRZE-HPC/likwid.git)\n\n1. [AddARMSupport](https://github.com/RRZE-HPC/likwid/wiki/AddARMSupport)\n1. `likwid-topology -V 3`打开 debug 信息\n1. [各平台各性能指标计算方法](https://github.com/RRZE-HPC/likwid/tree/master/groups) 需要配合[event](https://github.com/RRZE-HPC/likwid/wiki/ARM-A57)\n1. `likwid-perfctr -e` 查看 event\n1. `likwid-perfctr -a`查看支持的 group\n1. [userguide](https://docs.nersc.gov/tools/performance/likwid/)\n1. [tutorial1](https://blog.rwth-aachen.de/hpc_import_20210107/attachments/20056127/24117298.pdf)\n1. [tutorial](https://www.vi-hps.org/cms/upload/material/tw09/vi-hps-tw09-VI-HPS_likwid.pdf)\n1. `sudo apt install likwid`\n1. 源码编译时需要修改 config.mk 的 COMPILER 字段; For ARM builds, the COMPILER flag in config.mk needs to changed to GCCARMv8 or ARMCLANG (experimental).\n1. `likwid-topology`显示有关硬件拓扑的详细信息，例如 CPU、缓存、NUMA 域等。\n1. `likwid-bench`可以算 roofline; likwid-bench: Micro benchmarking platform for CPU architectures\n1. `likwid-perfscope`: Frontend to the timeline mode of likwid-perfctr, plots live graphs of performance metrics using gnuplot\n1. [Tutorial Empirical-Roofline-Model](https://github.com/RRZE-HPC/likwid/wiki/Tutorial%3A-Empirical-Roofline-Model)\n   - `sudo apt intall gnuplot`\n   - `gnuplot plotscript.gp`\n1. `cat /proc/cpuinfo` part 不一定支持， topology.h 中查看\n\n### [gprof](http://www.tastones.com/stackoverflow/c++/profiling/profiling_with_gcc_and_gprof/)\n\n1. [gprof2dot](https://github.com/jrfonseca/gprof2dot)\n1. [link](https://jasonblog.github.io/note/ncku_embededd/tong_xue_li_yong_gprof2dot_gong_ju_ff0c_jiang_zui_.html)\n\n```\n- g++ -pg ... -o xxx (Note: do not use -g)\n- ./xxx\n- gprof -b ./xxx gmon.out > xxx.log\n-  gprof ./xxx gmon.out | less\n\nsudo pip install gprof2dot\ngprof ./xxx | gprof2dot | dot -Tpng -o report.png\ngprof ./xxx | gprof2dot | dot -Tsvg -o report.svg\n\nSET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pg\")\nSET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -pg\")\nSET(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -pg\")\n```\n\n### google-perftools\n\n```\n- g++ -O3 -o test test.cc -lprofiler\n- LD_PRELOAD=/usr/local/lib/libprofiler.so CPUPROFILE=test.prof ./test\n- google-pprof ./test test.prof --svg > test.svg\n```\n\n### valgrind\n\n1. [valgrind + massif-visualizer 看内存占用](https://www.zhihu.com/question/31382177)\n\n#### cachegrind\n\n1. cachegrind：分析 CPU 的 cache 命中率、丢失率，用于进行代码优化。\n1. `valgrind --tool=cachegrind --branch-sim=yes ls`\n1. `cg_annotatel(callgrind_annotate) cachegrind.out.88431` 各模块 cache 统计\n1. `cg_annotatel(callgrind_annotate) cachegrind.out.88431 file` 统计 file 每一行 cache 情况, 可以看出 O3 比 O1 cache 优化了\n1. [qcachegrindwin 分析生成文件](https://jaist.dl.sourceforge.net/project/qcachegrindwin/0.7.4/)\n1. Kcachegrind GUI 显示分析生成的文件\n\n#### [callgrind](https://learnku.com/articles/46663)\n\n1. callgrind\n\n```sh\nvalgrind –tool=callgrind ./tmp\ncallgrind_annotate callgrind.out.XXX\ngprof2dot.py -f callgrind callgrind.out.XXX |dot -Tpng -o report.png\n```\n\n### [pmu-tools](https://github.com/andikleen/pmu-tools)\n\n### [(good)pprof](https://github.com/google/pprof)\n\n1. `-g`和`sudo`可能有问题\n\n```sh\nsudo perf record -F 99 -a -g -- ./bandwidth64\npprof -svg perf.data\n```\n\n1. perf 结果可视化\n1. [readme](https://github.com/google/pprof/blob/main/doc/README.md)\n1. 与 google-pprof 不是一个工具\n1. [需要编译 perf_data_converter](https://github.com/google/perf_data_converter)\n   - `cp  bazel-bin/src/perf_to_profile ~/go/bin`\n\n### [gprof2dot](https://github.com/jrfonseca/gprof2dot)\n\n1. 可类似 gprof 将 perf 结果生成调用图\n1. `perf script | c++filt | gprof2dot.py -f perf | dot -Tpng -o output.png`\n\n## [perf](https://billtian.github.io/digoal.blog/2016/11/27/01.html)\n\n1. `-vvv`打印调试信息\n1. `perf stat --all-cpus --no-aggr ls`查看每一个 cpu 统计\n1. [使用 perf 进行性能分析时如何获取准确的调用栈](https://gaomf.cn/2019/10/30/perf_stack_traceback/)\n1. [good examples](https://www.brendangregg.com/perf.html)\n1. perf 是性能分析的必备工具, 它最核心的能力是能访问硬件上的 Performance Monitor Unit (PMU), 对分析 CPU bound 的问题很有帮助, 当然 perf 也支持各种软件 event.\n\n### 源码安装\n\n1.\n\n```sh\ngit clone --depth=1 https://github.com/torvalds/linux.git\ncd tools/perf/\nmake -j4\n```\n\n2. [docxgen](https://www.cs.rice.edu/~la5/doc/perf-doc/de/df8/builtin-record_8c.html)\n1. [原理解析](https://github.com/freelancer-leon/notes/blob/master/kernel/profiling/perf.md)\n\n### perf_event\n\n1. `strace perf stat ./test`strace 跟踪`perf_event_open`看 type 和 config\n1. 可 c++编程\n1. 在 Linux perf events 中，确实存在对同时使用的 raw events 的数量限制。这是因为硬件计数器的数量是有限的。当超过硬件性能计数器的数量时，需要使用复用(multiplexing)来统计所有事件。\n1. raw counter 不管是 bash 还是 c++都有个数限制，需要分时复用，有没有方法计算到利用的时间？\n1. `perf stat -vvv ./test`可以看 perf_event_attr 配置\n\n### list\n\n1. [arm55 pmu 手册](https://developer.arm.com/documentation/100442/0100/debug-descriptions/pmu/pmu-events?lang=en)\n1. 列出 event\n1. `likwid-perfctr -e` 列出所有 PMC\n1. `likwid-perfctr -e | grep MEM`列出所有内存相关 PMC, `perf stat -e r013,r066,r067` r + mask + eventsel 监控对应事件\n\n```sh\nnvidia@miivii-tegra:~$ likwid-perfctr -e | grep MEM\nMEM_ACCESS, 0x13, 0x0, PMC\nMEMORY_ERROR, 0x1A, 0x0, PMC\nMEM_ACCESS_LD, 0x66, 0x0, PMC\nMEM_ACCESS_ST, 0x67, 0x0, PMC\n\nnvidia@miivii-tegra:~$ perf stat -e r013,r066,r067 -- ls\nDesktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos\n\n Performance counter stats for 'ls':\n\n           156,045      r013:u\n           118,079      r066:u\n            37,966      r067:u\n\n       0.003111539 seconds time elapsed\n\n       0.003294000 seconds user\n       0.000000000 seconds sys\n```\n\n#### record\n\n1. `perf record ./test`\n1. `perf record -e LLC-load-misses` 只记录某个热点，可生成火焰图\n1. perf record 对可以同时记录的事件数量有限制。这个限制由硬件性能监视器计数器（hardware performance monitor counters）决定。\n1. 多进程也不行， 开多个实例记录会不准，flopsc, bandwidth 可以用来验证是否准确\n1. `likwid-perfctr -e`可以查看支持的 PMC 个数\n\n#### report\n\n#### script\n\n1. `perf script -v` -v 查看调试信息\n\n#### [stat](https://zhuanlan.zhihu.com/p/385519404)\n\n1. `perf stat -I 1000 -a sleep 10` -I 1000 每隔 1000ms 输出一次\n1. `CPUs utilized = task_clock / 总时间` task_clock 统计所有核的无意义，肯定是 1; 统计单个程序的才有意义; 可以测量一个程序对 cpu 利用率， sleep 的时间会去掉\n1. `频率 = cpu_cycles / cpu_clock or task_clock time`多核不准\n1. `perf stat -ddd -- ./test` 可以查看 cpu 运行频率，运行 cycle 数，指令数, 程序运行时间\n1. 性能有一些损耗，影响不大（-ddd 打开细节越多损失越大）\n1. `sudo perf stat -a -- sleep 10`\n1. 不计算分布，仅仅进行统计, 可以看总体性能(IPC 等)\n1. `sudo perf stat -d -d -d -a -- sleep 10`\n1. `sudo perf stat -e cache-misses ls`\n1. 可以查看 CPU 真实利用率： CPUs utilized, 不包括等待时间，自旋时间等。真实利用率比 top 查看的利用率要低很多。\n1. top 查看的利用率： 如果 CPU 没有运行在内核的 idle 线程，就认为 CPU 在被使用。当 cpu 阻塞并等待内存访问时，也可能显示较高的利用率。\n\n#### [annotate](https://developer.ibm.com/tutorials/l-analyzing-performance-perf-annotate-trs/)\n\n1. 将热点函数精确到代码行，用于对问题进行精确定位。\n1. perf report 可以选中 sympol, 按快捷键 a\n1. h 显示快捷键\n1. k 显示行号\n1. <tab> Cycle thru hottest instructions\n1. t Circulate percent, total period, samples view\n1. Cross-arch annotate: 需要 vmlinux\n1. [build-kernel](https://ctf-wiki.org/pwn/linux/kernel-mode/environment/build-kernel/)\n1. [build-linux-kernel](https://phoenixnap.com/kb/build-linux-kernel)\n1. [cross arch](https://patchwork.ozlabs.org/project/linuxppc-dev/patch/1474472876-2706-2-git-send-email-ravi.bangoria@linux.vnet.ibm.com/)\n\n#### list\n\n1. 查看支持的 events\n1. `perf stat -e`查看 events\n1. `strace perf stat`strace 跟踪系统调用\n\n#### top\n\n1. 我们知道 perf top 是通过读取 PMU 的 PC 寄存器来获取当前执行的指令进而根据汇编的 symbol 信息获得是执行的哪条指令。\n1. 能够快速的定位热点函数\n1. (只统计栈顶)可以看到具体函数占用 cpu 比例，与火焰图从上往下看，越宽的函数占比越高，被遮盖的函数占比少\n1. lib 不能被 strip， 否则函数名显示地址\n1. perf top -p xxxx\n   - perf top -p 23015,32476 // 查看这两个进程的 cpu cycles 使用情况\n   - perf top // 默认配置\n   - perf top -G // 得到调用关系图\n   - perf top -e cycles // 指定性能事件\n   - perf top -s comm,pid,symbol // 显示调用 symbol 的进程名和进程号\n   - perf top --comms nginx,top // 仅显示属于指定进程的符号\n   - perf top --symbols kfree // 仅显示指定的符号\n\n#### mem\n\n### [hotspot](https://github.com/KDAB/hotspot)\n\n1. the Linux perf GUI for performance analysis\n1. `sudo apt install hotspot`\n1. `sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5`\n1. `sudo perf record -F 99 -p 81163 --call-graph dwarf -- sleep 60`\n\n### [pyroscope](https://github.com/grafana/pyroscope)\n\n### [speedscope](https://github.com/jlfwong/speedscope)\n\n1. [在线网页](https://www.speedscope.app/)\n1. 需要 perf script 后的 unfold(可以显示各个线程结果) 或 fold(显示整体结果, 有些信息缺失) 文件， 不是原始文件\n1. 页面上边中间可选择具体线程来看占用时间\n1. time order: 时间变化\n1. left heavy: 类似火焰图\n1. Sandwidth: 占用时间比例，及调用栈\n1. 点击符号可以看到在哪个动态库中，助于调试\n1. 调用堆栈按照它们在输入文件中出现的顺序从左到右排列，这通常是安排它们被记录的时间顺序。这个视图对于理解应用程序随时间变化的行为非常有帮助，比如 \"首次从数据库获取到数据，然后为序列化准备数据，数据被序列化为 JSON\"。\n1. 可以用来看调用关系\n1. 调用栈过长可以上下滚动滑轮\n\n### [flamescope](https://github.com/Netflix/flamescope)\n\n1. [flamescope recognition](https://www.brendangregg.com/blog/2018-11-08/flamescope-pattern-recognition.html)\n1. [netflix-flamescope](https://netflixtechblog.com/netflix-flamescope-a57ca19d47bb)\n1. heatmap + flamegraph\n1. 需要 npm install\n1. 将生成的 perf 文件 copy 到 examples 目录下\n1. 可以看 pagefault\n1. perf 可以看 all， 也可以看单独进程\n1. 斜线可以大概分辨出程序帧率，因为周期性活动\n1. 为什么以 49 赫兹采样？因为 50 赫兹可能会与定时活动同步进行采样，并且计数过高或过低。为什么一开始大约是 50 赫兹？它不太慢也不太快。太慢了，我们没有足够的样本来绘制 FlameScope 的 50 行热图（行数可以更改）。太快和采样的开销会减慢应用程序。\n1. 注意显示火焰图时 url 会显示时间区间\n\n### [火焰图](https://github.com/brendangregg/FlameGraph)\n\n1. [用 CPI 火焰图分析 Linux 性能问题](https://cloud.tencent.com/developer/article/1517979) 使用 CPI 火焰图，可以很方便地做 CPU 利用率的分析，找到和定位引发 CPU 停顿的函数。一旦找到相关的函数，就可以通过 perf annotate 命令对引起停顿的指令作出进一步确认。\n1. [作者 slice](https://www.slideshare.net/brendangregg/usenix-atc-2017-visualizing-performance-with-flame-graphs)\n1. 可以跑多次，看看优化效果\n1. 开发板交叉编译 perf，或者找相同 aarch 机器，copy。perf 之后将结果 copy 到开发机生成火焰图\n1. release 模式显示不全，debug 模式更全,可能是 release 符号被保护了？因为 release 模式用到的库被 strip 了\n1. 库不能 strip\n1. 函数名可能被 mangle，需要 demangle `./stackcollapse-perf.pl data.unfold | c++filt > data.folded`\n1. If you are profiling C++ code, you may want to pipe stacks through c++filt to get readable frames.\n1. [flamegraph-rust](https://github.com/flamegraph-rs/flamegraph)\n1. [火焰图类型](https://www.infoq.cn/article/a8kmnxdhbwmzxzsytlga)\n   - on-cpu(默认): 分析 cpu 瓶颈\n   - off-cpu: 阻塞时间\n   - 内存火焰图：内存问题\n   - Hot/Cold 火焰图： on-cpu and off-cpu 结合\n1. [性能分析之 off-cpu](https://zhuanlan.zhihu.com/p/162375221)\n1. Top edge shows who is running on cpu and how much(width)\n1. `flamegraph.pl --color=java` C++和系统调用显示颜色不一样,\n1. 平顶山的火苗是瓶颈，perf top 也可以看出来 1. `flamegraph.pl --color=java` C++, 注意 C++ 普通函数会被认为是其他，比较傻瓜，索引::\n1. 第一要想到的是优化平顶\n1. 栈上空白处是没有函数调用，栈上没信息，所以不显示，也在计算，比如 for\n\n1. 为什么要叫火焰图，形象的理解：整个图形看起来就像一团跳动的火焰，这也正是其名字的由来。燃烧的火苗尖部就是 CPU 正在执行的操纵，图纵向表示调用栈的深度，横向表示消耗的时间。一个格子的宽度越大越说明其可能是瓶颈。当我们分析火焰图时，主要就是看那些比较宽大的火苗，`特别留意那些类似平顶山的火苗`。\n   火焰图是基于 stack 信息生成的 SVG 图片，用来展示 CPU 的调用栈。\n   y 轴表示调用栈，每一层都是一个函数，调用栈越深，火焰图的层数就越高，火焰就看起来越高，顶部就是正在执行的函数，下方就是它的父函数。\n   x 轴表示抽样数，表示一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长，注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。\n   火焰图是 SVG 图片，可以很方便的使用：\n   （1）鼠标悬浮\n   火焰的每一层都会标注函数名，鼠标悬浮时会显示完整的函数名、抽样抽中的次数、`占据总抽样次数的百分比`；\n   （2）点击放大\n   在某一层点击，火焰图会水平放大，该层会占据所有宽度，显示详细信息；\n   左上角会同时显示“Reset Zoom”，点击该链接，图片就会恢复原样；\n   （3）搜索\n   按下 Ctrl+F 会显示一个搜索框，用户可以输入关键词或正则表达式，所有复合条件的函数名会`高亮显示`。\n\n1. 火焰图生成\n   生成和创建火焰图需要以下几个步骤：\n   （1）捕获堆栈\n   使用 perf/systemtap/dtrace 等工具抓取程序的运行堆栈。\n   （2）折叠堆栈\n   trace 工具抓取的系统和程序运行每一时刻的堆栈信息，需要对他们进行分析组合，将重复的堆栈累计在一起，从而体现出负载和关键路径。\n   （3）生成火焰图\n   分析 stackcollapse 输出的堆栈信息生成火焰图。\n1. static 函数可能不显示，会展开\n1. 火焰图结合 perf(on-cpu) 实际使用方法\n\n```sh\n# sudo apt install -y linux-tools-generic\n# sudo rm /usr/bin/perf\n# sudo ln -s /usr/lib/linux-tools/4.15.0-162-generic/perf /usr/bin/perf\n# git clone https://github.com/brendangregg/FlameGraph.git\n# cd FlameGraph\n# perf record -F 99 -p ${PID} -a -g -- sleep 60\n# perf script > out.perf\n# ./stackcollapse-perf.pl out.perf > out.folded\n# ./stackcollapse-perf.pl out.perf | c++flit > out.folded\n# ./flamegraph.pl out.folded > out.svg\n```\n\n1. 很轻松的分析出，哪些代码会经常性的触发 pagefault，以及比重。\n1. [page-faults](https://github.com/lrita/lrita.github.io/blob/master/_posts/2019-09-27-systemtap-profiling-pagefault.md#L29) flamegraph 作者给的例子有些错误,\n   map, vector clear 会调用 explicit_bzero，容易产生 pagefault\n\n```sh\n# perf record -e page-faults -p $1 -g -- sleep 60\n# perf script > out.perf\n# ./stackcollapse-perf.pl out.perf > out.folded\n# ./flamegraph.pl out.folded > out.svg\n```\n\n1. [出现 e 大量 unknown](https://blog.csdn.net/bandaoyu/article/details/108765693) 加`--call-graph dwarf`, 而 -g 就相当于 --call-graph fp. fp 就是 Frame Pointer，即 x86 中的 EBP 寄存器，fp 指向当前栈帧栈底地址，此地址保存着上一栈帧的 EBP 值\n\n```sh\nsudo perf record -F 99 -p 81163 --call-graph dwarf -- sleep 60\n```\n\n1. 问题：\n   - perf 还有一个问题是对中断的要求，perf 很多事件都依赖中断，但 Linux 内核是可以关中断的，关中断以后，你就无法击中关中断的点了，你的中断会被延迟到开中断的时候，所以，在这样的平台上，你会看到很多开中断之后的函数被密集击中。但它们是无辜的。但更糟糕的是，如果在关中断的时候，发生了多个事件，由于中断控制器会合并相同的中断，你就会失去多次事件，让你的统计发生错误。现代的 Intel 平台，基本上已经把 PMU 中断都切换为 NMI 中断了（不可屏蔽），所以前面这个问题不存在。但在大部分 ARM/ARM64 平台上，这个问题都没有解决，所以看这种平台的报告，都要特别小心，特别是你看到\\_raw_spin_unlock()一类的函数击中极高，你就要怀疑一下你的测试结果了（注意，这个结果也是能用的，只是看你怎么用）。\n   - 你每次看 perf report 的报告，首先要去注意一下总共收集了多少个点，如果你只有几十个点，你这个报告就可能很不可信了。\n2. 哪些场景下可以利用火焰图来帮助我们处理问题\n   （1）版本更新时，对比前后两个版本的火焰图差别，有助于我们分析新旧两个版本的异同；\n   （2）CPU 异常占用时（CPU 异常打满或者 CPU 利用率一直上不去），通过火焰图，有助于我们定位异常代码；\n   （3）性能分析时，通过火焰图来了解程序实际执行时各模块对 CPU 资源的占用情况；\n   （4）问题排查，通过分析火焰图的调用栈是否符合预期，排查程序逻辑执行是否符合预期；\n\n## nsight\n\n1. [user guide](https://docs.nvidia.com/nsight-systems/UserGuide/index.html)\n1. NsightSystems-2023.2.1.122-3259852.msi 安装包\n1. Nsight_Systems_User_Guide_2023.2.1.122-3259852.pdf 文档\n1. 左上角 timeline view 可以选择 analysis summary，有各种总结\n1. 左侧右键选`show in events view`， 可以看具体时间, 可以在 all 上操作，看所有 event 运行时间\n1. 右键 reset room 显示全部\n1. `shift + mouseleftdoubleclick` timeline 可以找到对应 event 在 event view 位置\n1. `ctrl + mouseleftdoubleclick` timeline 可以 fit to screen\n1. `backspace` timeline 可以 undo room\n1. `ctrl + mouseleftdoubleclick` 可以找到 event view 对应的 timeline 位置\n1. `sudo nsys profile <app>`\n1. `nsys stats report1.nsys-rep` 输出各种 report\n1. 可以看 cpu 执行情况， tensort 可以看详细算子耗时，也有对应 cuda 执行情况\n1. analysis summary 中有各个线程的 cpu 利用率总结\n1. 可以关注 cpu 空闲的地方，为什么会空闲(同步数据？)\n1. 可以缩小看颜色占比，关注占比大的模块\n1. cudaMemcpy 会阻塞 cpu 执行， 可以多注意 cudaMemcpy 影响\n1. cudaStreamSynchronize 是 CUDA API 中的一个函数，用于等待指定的 CUDA 流上的所有 CUDA 核函数执行完毕。当 CUDA 核函数被执行时，它们会被添加到一个 CUDA 流中，这些核函数的执行可能是异步的，也可能是同步的，具体取决于如何在代码中调用它们。当我们调用 cudaStreamSynchronize 时，它将会阻塞当前 CPU 线程，直到指定的流上的所有核函数都执行完毕。\n\n## 总结(搜索 speed up C++)\n\n1. 内存连续读写速度远快于随机读写。(尽可能顺序访问内存)\n1. 内存的写入速度比读取慢不少(减少内存写操作)\n1. 用连续内存(多线程分配内存？)\n1. 少分配内存, 尽量原位操作\n1. 函数满足 RVO(return value optimization)\n1. 不满足 RVO, 用 move, 例如返回 tuple, 构造时元素要用 move\n1. 多维 vector 内存分配比较耗时\n1. 尽量用一维 vector 或 array，多维 vector 慢很多\n1. transform 不要用 back_inserter,先分配好，然后用 begin()\n1. lamda 是内联函数，比普通函数快\n1. 多用 for, transform, 少用 push_back, emplace_back\n1. transform 应用到连续内存会比较快， 比如 array, 应用到 vector 比 array 慢很多\n1. range 应用到连续内存比较快，array 比 vector 快很多，array 的 range 比 for 快很多，vector 的 range 比 for 慢\n1. range 比 transform 快\n1. 矩阵运算用一维矩阵比二维矩阵快很多。\n1. vector: resize 会调用构造函数，reserve 不会调用。reserve 比 resize 快很多。需要 empalce_back 的要先 reserve。初始化为 0 比较慢？\n1. 动态内存分配、STL 容器、string 都是一些常容易 cache 不友好的场景，核心代码处尽量不用\n\n## cpu mem 实时利用率\n\n```python\ndef ResouceUsageCatch():\n    print('ResouceUsageCatch runing ...')\n    msg = os.popen('ps -aux | grep -v grep | grep  \\'PID\\'').read()\n    msg_head = msg.split()\n    print(msg_head)\n    print(msg_head.index('%CPU'))\n    print(msg_head.index('RSS'))\n    cpu_val_list = []\n    mem_val_list = []\n\n    time.sleep(20) # wait the demo run stable\n    with open('cpu_mem.csv','w+') as file_out:\n        run_times = 0\n        cpu_mem_writer = csv.writer(file_out)\n        cpu_mem_writer.writerow(['cpu', 'mem'])\n        while True:\n            msg = os.popen('ps -aux | grep -v grep | grep  \\'visual_radar_by_camera_demo\\'').read()\n            if(len(msg) == 0):\n                break\n            msg_list = msg.split()\n            # print(msg_list[msg_head.index('%CPU')])\n            # print(msg_list[msg_head.index('RSS')])\n\n            cpu_mem_writer.writerow([float(msg_list[msg_head.index('%CPU')]), float(msg_list[msg_head.index('RSS')])])\n\n            cpu_val_list.append(float(msg_list[msg_head.index('%CPU')]))\n            mem_val_list.append(float(msg_list[msg_head.index('RSS')]))\n\n            run_times = run_times + 1\n            print(\"run times : \", run_times)\n            if run_times > 3600:\n                break\n\n            time.sleep(1)\n        os.system('killall visual_radar_by_camera_demo')\n        time.sleep(2)\n\n    with open('test_report.csv','w+') as file_out:\n        csv_writer = csv.writer(file_out)\n        csv_writer.writerow(['', 'max', 'average', 'min', 'data_unit'])\n        print('=************************= cpu usage =************************=')\n        if (len(cpu_val_list) > 0):\n            cpu_max = max(cpu_val_list)\n            cpu_min = min(cpu_val_list)\n            cpu_ave = sum(cpu_val_list)/len(cpu_val_list)\n            print(\"cpu max : %d\", cpu_max)\n            print(\"cpu min : %d\", cpu_min)\n            print(\"cpu ave : %d\", cpu_ave)\n            csv_writer.writerow(['cpu', round(cpu_max, 1), round(cpu_ave, 1), round(cpu_min, 1), '%'])\n        print('---------------------------------------------------------------')\n\n        print('=************************= mem usage =************************=')\n        if (len(mem_val_list) > 0):\n            mem_max = max(mem_val_list)/1000.\n            mem_min = min(mem_val_list)/1000.\n            mem_ave = sum(mem_val_list)/len(mem_val_list)/1000.\n            print(\"mem max : \", mem_max)\n            print(\"mem min : \", mem_min)\n            print(\"mem ave : \", mem_ave)\n            csv_writer.writerow(['mem', round(mem_max, 1), round(mem_ave, 1), round(mem_min, 1), 'M'])\n        print('---------------------------------------------------------------')\n\n```\n\n## profiling result\n\n1. 多线程分配内存(申请内存足够大，且时间大于线程开销)（或申请内存时可以做其他操作）\n\n```\nTEST : 4955us\nTEST_MT : 2786us\n\nvector<int> test1(1000000, 100);\n  vector<int> test2(1000000, 100);\n  vector<int> test11(1000000, 100);\n  __TOC__(TEST)\n\n  __TIC__(TEST_MT)\n  std::vector<int> test3;\n  std::vector<int> test4;\n  std::vector<int> test5;\n  auto fun = [](std::vector<int> &v, int num) { v.resize(num); };\n  auto f1 = async(fun, ref(test3), 1000000);\n  auto f2 = async(fun, ref(test4), 1000000);\n  auto f3 = async(fun, ref(test5), 1000000);\n  f1.get();\n  f2.get();\n  f3.get();\n  __TOC__(TEST_MT)\n\n```\n\n1. vector construct, reserve, resize （resize 会调用构造函数，reserve 不会调用。需要 empalce_back 的要先 reserve。初始化为 0 比较慢？）\n\n```\nTEST_RESERVE : 6275us\nTEST_NOT_RESERVE : 10727us\nTEST : 3740us\nTEST_zero : 3763us\nTEST_one : 3292us\nTEST_RESIZE : 3575us\n\n  __TIC__(TEST_RESERVE)\n  vector<int> test0;\n  test0.reserve(2000000);\n  for (auto i = 0u; i < 2000000; ++i) {\n    test0.emplace_back(0);\n  }\n  __TOC__(TEST_RESERVE)\n\n  __TIC__(TEST_NOT_RESERVE)\n  vector<int> test1;\n  for (auto i = 0u; i < 2000000; ++i) {\n    test1.emplace_back(0);\n  }\n  __TOC__(TEST_NOT_RESERVE)\n\n  __TIC__(TEST)\n  vector<int> test(2000000);\n  __TOC__(TEST)\n\n  __TIC__(TEST_zero)\n  vector<int> test2(2000000, 0);\n  __TOC__(TEST_zero)\n\n  __TIC__(TEST_one)\n  vector<int> test4(2000000, 1);\n  __TOC__(TEST_one)\n\n __TIC__(TEST_RESIZE)\n  vector<int> test3;\n  test3.resize(2000000);\n  __TOC__(TEST_RESIZE)\n\n```\n\n1. range and transform (array 的 transform 比 vector 的快)\n\n```\nARRAY_RANGE : 1084us\nVECTOR_RANGE : 6421us\nARRAY_TRANSFORM : 1603us\nVECTOR_TRANSFORM : 8252us\n\n  __TIC__(ARRAY)\n  array<int, 1000000> a;\n  for (auto i = 0u; i < 1000000; ++i) {\n    a[i] = i;\n  }\n  __TOC__(ARRAY)\n\n  __TIC__(ARRAY_TRAN)\n  array<int, 1000000> a1;\n  transform(a1.begin(), a1.end(), a1.begin(), [](auto &a) { return a + 1; });\n  __TOC__(ARRAY_TRAN)\n\n  __TIC__(VECTOR)\n  vector<int> v(1000000);\n  for (auto i = 0u; i < 1000000; ++i) {\n    v[i] = i;\n  }\n  __TOC__(VECTOR)\n\n  __TIC__(VECTOR_TRAN)\n  vector<int> v1(1000000);\n  transform(v1.begin(), v1.end(), v1.begin(), [](auto &v) { return v + 1; });\n  __TOC__(VECTOR_TRAN)\n\n  __TIC__(VECTOR_TRAN2)\n  vector<int> v2(1000000);\n  transform(v1.begin(), v1.end(), v2.begin(), [](auto &v) { return v + 1; });\n  __TOC__(VECTOR_TRAN2)\n\n```\n\n1. 一维 vector 和二维 vector(一维比多维快很多)\n\n```\nVECTOR2 : 3770us\nVECTOR1 : 554us\nARRAY : 627us\n\n __TIC__(VECTOR2)\n  vector<vector<int>> v(10000, vector<int>(5));\n  for (auto i = 0u; i < v.size(); ++i) {\n    for (auto j = 0u; j < 5; ++j) {\n      v[i][j] = 1;\n    }\n  }\n  __TOC__(VECTOR2)\n\n  __TIC__(VECTOR1)\n  vector<int> v1(10000 * 5);\n  for (auto i = 0u; i < 10000 * 5; ++i) {\n    v1[i] = 1;\n  }\n  __TOC__(VECTOR1)\n\n  __TIC__(ARRAY)\n  array<int, 10000 * 5> a;\n  for (auto i = 0u; i < 10000 * 5; ++i) {\n    a[i] = 1;\n  }\n  __TOC__(ARRAY)\n\n\n```\n\n1. array and vector, transform and for(array 配合 transform 比较快， vector 配合 transform 很慢)\n\n```\nARRAY : 1372us\nARRAY_TRAN : 1078us\nVECTOR : 1219us\nVECTOR_TRAN : 4595us\n\n  __TIC__(ARRAY)\n  array<int, 100000> a;\n  for (auto i = 0u; i < 100000; ++i) {\n    a[i] = i;\n  }\n  __TOC__(ARRAY)\n\n  __TIC__(ARRAY_TRAN)\n  array<int, 100000> a1;\n  transform(a1.begin(), a1.end(), a1.begin(), [](auto a) { return a + 1; });\n  __TOC__(ARRAY_TRAN)\n\n  __TIC__(VECTOR)\n  vector<int> v(100000);\n  for (auto i = 0u; i < 100000; ++i) {\n    v[i] = i;\n  }\n  __TOC__(VECTOR)\n\n  __TIC__(VECTOR_TRAN)\n  vector<int> v1(100000);\n  transform(v1.begin(), v1.end(), v1.begin(), [](auto v) { return v + 1; });\n  __TOC__(VECTOR_TRAN)\n\n```\n\n1. function return\n\n```\nstd::vector<int> m1() { return std::vector<int>(3000000, 1); }\n\nstd::vector<int> m2() { return std::move(std::vector<int>(3000000, 1)); }\n\n// fastest\nstd::vector<int> m3() {\n  std::vector<int> result(3000000, 1);\n  return result;\n}\n\nstd::vector<int> m4() {\n  std::vector<int> result(3000000, 1);\n  return std::move(result);\n}\n\nM1 : 16538117ns\nM2 : 15113944ns\nM3 : 14415912ns\nM4 : 15932611ns\n```\n\n1. range: vector and array(array 的 range 比 for 快很多，vector 的 range 比 for 慢)\n\n```\nVECTOR : 648us\nVECTOR_RANGE : 1784us\nARRAY : 743us\nARRAY_RANGE : 177us\n\n__TIC__(VECTOR)\n  vector<int> v1(10000 * 5);\n  for (auto i = 0u; i < 10000 * 5; ++i) {\n    v1[i] = 1;\n  }\n  __TOC__(VECTOR)\n\n  __TIC__(VECTOR_RANGE)\n  vector<int> v2(10000 * 5);\n  for (auto &i : v2) {\n    i = 1;\n  }\n  __TOC__(VECTOR_RANGE)\n\n  __TIC__(ARRAY)\n  array<int, 10000 * 5> a;\n  for (auto i = 0u; i < 10000 * 5; ++i) {\n    a[i] = 1;\n  }\n  __TOC__(ARRAY)\n\n  __TIC__(ARRAY_RANGE)\n  array<int, 10000 * 5> a1;\n  for (auto &i : a) {\n    i = 1;\n  }\n  __TOC__(ARRAY_RANGE)\n\n```\n\n2. range and for\n\n```\n std::vector<int> vec(500000, 0);\n\n  __TIC__(M1);\n  for (int i = 0; i < vec.size(); ++i) {\n    vec[i]++;\n  }\n  __TOC__(M1);\n\n  __TIC__(M2);\n  for (auto item : vec) {\n    item++;\n  }\n  __TOC__(M2);\n\n  __TIC__(M3);\n  for (auto& item : vec) {\n    item++;\n  }\n  __TOC__(M3);\n\n\nM1 : 5885us\nM2 : 12406us\nM3 : 11534us\n```\n\n1. transform and for\n\n```\n  std::vector<float> vec(10000, 1.111);\n  std::vector<float> vec1(10000, 2.111);\n  std::vector<float> result;\n  // 操作一个vector\n  std::transform(vec.begin(), vec.end(), std::back_inserter(result),\n                 [](const auto item) -> float { return item + 100; });\n  // for_each(vec.begin(), vec.end(), [](auto &item) { item += 100; })\n\n // 性能好很多，不要用back_inserter\n  std::vector<float> result5(vec.size(), 0);\n  std::transform(vec.begin(), vec.end(), result5.begin(),\n                 [](const auto &item) -> float { return item + 100; });\n\n\n  // 操作两个vector NOTE: 使用前需要检查vec, vec1 size是否匹配。\n  // 性能好 797us 13us(-O3)\n  std::vector<float> result1(10, 0.0);\n  std::transform(vec.begin(), vec.end(), vec1.begin(), result1.begin(),\n                 [](const auto &item1, const auto &item2) -> float {\n                   return item1 + item2;\n                 });\n\n  // 性能差 2605us 173us(-O3)\n  std::vector<float> result2;\n  std::transform(vec.begin(), vec.end(), vec1.begin(),\n                 std::back_inserter(result2),\n                 [](const auto &item1, const auto &item2) -> float {\n                   return item1 + item2;\n                 });\n  // for 463us 70us(-O3)\n  std::vector<float> result3(vec.size(), 0);\n  for (auto i = 0u; i < result3.size(); ++i) {\n    result[i] = vec[i] + vec1[i];\n  }\n\n```\n\n3. lambda and fun\n\n```\n\n// 322ns\nint add(int &a, int &b) {\n  auto result = a + b;\n  return result;\n}\n\n// 233ns\ninline int add_inline(int &a, int &b) {\n  auto result = a + b;\n  return result;\n}\n\n// 233ns\nauto l = [](int &a, int &b) { return a + b; }; // 使用lambda函数的效率与使用函数对象是一样的，都要快于函数指针。他们都能够在编译期将代码内联展开，减少函数调用的时间。\n// 编译为类\nclass __lambda_6_11\n  {\n    public:\n    inline /*constexpr */ int operator()(int a, int b) const\n    {\n      return a + b;\n    }\n\n    using retType_6_11 = int (*)(int, int);\n    inline /*constexpr */ operator retType_6_11 () const noexcept\n    {\n      return __invoke;\n    };\n\n    private:\n    static inline int __invoke(int a, int b)\n    {\n      return a + b;\n    }\n  }\n```\n\n4 for and memset\n\n```\n  int a[800000];\n  __TIC__(M1);\n  memset(a, 0, 800000 * sizeof(int)); // memset 只能用于连续内存，不能用于vector\n  __TOC__(M1);\n\n  __TIC__(M2);\n  for (auto i = 0u; i < 800000; ++i) {\n    a[i] = 0;\n  }\n  __TOC__(M2);\n\nM1 : 1401us\nM2 : 1908us\n```\n\n5. for, transform, push_back, emplace_back(少用 push_back, emplace_back)\n\n```\nvector<float> vec(1000000, -1235.23);\n\n  __TIC__(FOR)\n  vector<float> result_for(1000000, 0);\n  for (auto i = 0u; i < result_for.size(); ++i) {\n    result_for[i] = vec[i];\n  }\n  __TOC__(FOR)\n\n  __TIC__(TRANSFORM)\n  vector<float> result_trans(1000000, 0);\n  std::transform(vec.begin(), vec.end(), result_trans.begin(),\n                 [](auto i) -> float { return i; });\n  __TOC__(TRANSFORM)\n\n  __TIC__(PUSH_BACK)\n  vector<float> result0;\n  for (auto i : vec) {\n    result0.push_back(i);\n  }\n  __TOC__(PUSH_BACK)\n\n  __TIC__(PUSH_BACK1)\n  vector<float> result;\n  for (auto i : vec) {\n    result.push_back(std::move(i));\n  }\n  __TOC__(PUSH_BACK1)\n\n  __TIC__(EMPLACE_BACK)\n  vector<float> result1;\n  for (auto i : vec) {\n    result1.emplace_back(i);\n  }\n  __TOC__(EMPLACE_BACK)\n\n  __TIC__(EMPLACE_BACK2)\n  vector<float> result2;\n  for (auto &i : vec) {\n    result2.emplace_back(i);\n  }\n  __TOC__(EMPLACE_BACK2)\n\n  __TIC__(EMPLACE_BACK3)\n  vector<float> result3;\n  for (auto &i : vec) {\n    result3.emplace_back(std::move(i));\n  }\n  __TOC__(EMPLACE_BACK3)\n\n  cout << vec[0] << endl;\n\n  for (auto &i : vec) {\n    // cout << i << \" \";\n  }\n  return 0;\n\nFOR : 2042us\nTRANSFORM : 2161us\nPUSH_BACK : 4369us\nPUSH_BACK1 : 5835us\nEMPLACE_BACK : 5175us\nEMPLACE_BACK2 : 5075us\nEMPLACE_BACK3 : 5364us\n\n```\n\n1. struct bindings(多用引用)\n\n```\n  vector<float> vec(1000000, -1235.23);\n  auto tup = std::make_tuple(vec, vec, vec);\n  __TIC__(TUP1)\n  auto [x, y, z] = tup;\n  __TOC__(TUP1)\n\n  __TIC__(TUP2)\n  auto &[l, m, n] = tup;\n  __TOC__(TUP2)\n\nTUP1 : 6940us\nTUP2 : 0us\n\n```\n\n```\n// 三种方式等价\n  vector<float> vec(1000000, -1235.23);\n  __TIC__(TUP1)\n  auto tup = std::make_tuple(vec, vec, vec);\n  auto [x, y, z] = std::move(tup);\n  __TOC__(TUP1)\n\n  __TIC__(TUP2)\n  auto tup2 = std::make_tuple(vec, vec, vec);\n  auto &[x2, y2, z2] = tup;\n  __TOC__(TUP2)\n\n  __TIC__(TUP3)\n  auto [x1, y1, z1] = std::make_tuple(vec, vec, vec);\n  __TOC__(TUP3)\n\nTUP1 : 10087us\nTUP2 : 10126us\nTUP3 : 10127us\n```\n\n```\n// 构造时能用Move用move\ntuple<vector<float>, vector<float>, vector<float>> get_tup() {\n  vector<float> vec1(1000000, -1235.23);\n  vector<float> vec2(1000000, -1235.23);\n  vector<float> vec3(1000000, -1235.23);\n  return {vec1, vec2, vec3};\n}\n\ntuple<vector<float>, vector<float>, vector<float>> get_tup1() {\n  vector<float> vec1(1000000, -1235.23);\n  vector<float> vec2(1000000, -1235.23);\n  vector<float> vec3(1000000, -1235.23);\n  return {std::move(vec1), std::move(vec2), std::move(vec3)};\n}\n\n  __TIC__(TUP3)\n  auto [x1, y1, z1] = get_tup();\n  __TOC__(TUP3)\n\n  __TIC__(TUP4)\n  auto [x4, y4, z4] = get_tup1();\n  __TOC__(TUP4)\n\nTUP3 : 18522us\nTUP4 : 6687us\n```\n\n1. if and std::max (简单比较用 if，无函数调用)\n\n```\nvector<int> test(100000, 0);\n  for (auto i = 0u; i < 100000; i++) {\n    test[i] = rand();\n  }\n\n  __TIC__(TEST)\n  int max_value = 0;\n  for (auto i = 0u; i < 100000; ++i) {\n    if (test[i] > max_value) {\n      max_value = test[i];\n    }\n  }\n  __TOC__(TEST)\n\n  __TIC__(TEST2)\n  int max_value2 = 0;\n  for (auto i = 0u; i < 100000; ++i) {\n    max_value2 = std::max(max_value2, test[i]);\n  }\n  __TOC__(TEST2)\n\nTEST : 570us\nTEST2 : 994us\n\n```\n\n## Links\n\n1. [C++性能优化](https://zhuanlan.zhihu.com/p/33638344)\n1. [C++性能调优](https://segmentfault.com/a/1190000040755126)\n\n## 优化的问题\n\n1. j5 模型定点对齐输出， 后处理在需要的地方进行定浮点转换与取有效数据\n1. 模型输出 chw， 按 c 取最大值，形成 h\\*w mask；如果按 for i j k 来取，不连续。解决方法：设置第一层为最大值，后续 k-1 层没一层和第 k-1 层做对比，最大值保存在第一层，max 对应的 index 存起来\n\n```\n  // net_output: NCHW; net_output_shape: NHWC\n  auto frame_w = net_output_shape[0][2];\n  auto frame_h = net_output_shape[0][1];\n  auto channel_num = net_output_shape[0][3];\n  // cv::Mat mask_mat(frame_h,frame_w, CV_8UC1);\n  cv::Mat mask_mat = cv::Mat::zeros(frame_h, frame_w, CV_8UC1);\n  unsigned char *maskdata = mask_mat.data;\n  // for(int i=0; i<frame_h; i++){\n  //   for(int j=0; j<frame_w; j++){\n  //     int index = i*frame_w+j;\n  //     float tmp = net_output[index];\n  //     int maxk = 0;\n  //     for(int k=1; k<channel_num; k++){\n  //       int index1 = k*frame_h*frame_w+index;\n  //       if (tmp < net_output[index1]) {\n  //         tmp = net_output[index1];\n  //         maxk = k;\n  //       }\n  //     }\n  //     maskdata[index] = maxk;\n  //   }\n  // }\n\n  // net_output 和 maskdata 都连续访存, 提高cache命中率\n  int wxh = frame_h *frame_w;\n  // set layer 0 to max_value;\n  std::vector<float> max_value(wxh, 0);\n  memcpy(&max_value[0], net_output, wxh * sizeof(float));\n  // get max index from layer 1\n  int index = wxh;\n  for (auto k = 1u; k < channel_num; ++k) {\n    for (auto offset = 0u; offset < wxh; ++offset) {\n      if (net_output[index] > max_value[offset]) {\n        max_value[offset] = net_output[index];\n        maskdata[offset] = k;\n      }\n      index++;\n    }\n  }\n\n  // // not copy: 7ms\n  // int index = wxh;\n  // for (auto k = 1u; k < channel_num; ++k) {\n  //   for (auto offset = 0u; offset < wxh; ++offset) {\n  //     if (net_output[index] > net_output[offset]) {\n  //       net_output[offset] = net_output[index];\n  //       maskdata[offset] = k;\n  //     }\n  //     index++;\n  //   }\n  // }\n```\n","tags":["Profiling","Perf"],"categories":["Program","Cpp"]},{"title":"Programming-Paradigm","url":"/2021/08/22/Programming-Paradigm/","content":"\n## 概念\n1. 编程范式的实际含义：限制和规范程序员的能力。\n2. 每个编程范式的目的都是设置限制，这些编程范式主要告诉我们不能做什么，而不是可以做什么。\n3. 语法，features和范式的关系？语言的语义和句法决定了语言的features? features决定了语言的编程范式？\n4. 限制：\n   - 结构化编程：对程序控制权的直接转移进行了限制和规范， 限制goto语句， 因为if, while等包装了goto\n   - 面向对象编程：对程序控制权的间接访问进行了限制和规范， 限制函数指针, 因为多态包装了函数指针。\n   - 函数式编程：对程序中的赋值进行了限制和规范， 限制赋值语句，因为包装了变量\n5. `关系： 多态是跨越架构边界的手段，函数式编程时我们规范和限制数据存放位置和访问权限的手段，结构化编程则是个模块的算法实现基础。这和软件架构的三大关注重点不谋而合：功能性，组件独立性，数据管理`\n6. 多态归根结底不过就是函数指针的一种应用。\n\n## Procedural/Structured programming 面向过程/结构化编程\n1. 结构化程序设计方法SP(Structured Programming)的着眼点是“面向过程”。　　\n2. 它采用子程序、块结构、for循环以及while循环等结构，来取代传统的 goto。goto语句的某些用法会导致某个模块无法被递归拆分成更小的，可证明的单元，会导致无法采用分解法来将大型问题进一步拆分成更小的，可证明的部分。\n3. 可以用`顺序结构`，`分支结构`和`循环结构`这三种结构构造出任何程序。\n4. 科学和数学： 数学是要将可证明的结论证明，科学则是要将可证明的结论证伪。科学理论和定律特点：它们可以被证伪，但没有办法证明。\n3. 软件开发像是一门科学研究学科：可通过无法证伪来证明软件的正确性。测试的作用。\n4. 结构化编程最有价值的地方在于它赋予我们创造可证伪程序单元的能力。\n5. 无论在哪一个层面上，从最小的函数到最大的组件，软件开发过程都和科学研究非常类似，他们都是由证伪驱动的。软件架构师选哟定义可以方便地进行证伪的模块,组件以及服务。\n6.\n\n## Object Oriented Programming 面向对象编程\n1.面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层是线性组件相分离，底层组件可以编译成插件，实现独立于高层组件的开发和部署。\n2.`依赖反转`： 通过接口，多态来使`源代码上的依赖关系方向`与`控制流方向`相反。 中间加了接口，只有被控制端的源代码依赖关系方向反转。 面向接口编程就是利用了依赖反转来使得模块分离。\n3.依赖反转可用来打破组件间循环依赖。\n\n## Functional Programming 函数式编程\n1. 最大特点是不可变性——某个符号所对应的值永远不变，从理论上讲，函数式编程语言应该是没有赋值语句的。\n2. 如果由足够大的存储量和处理能力，应用程序就可以用完全不可变的，纯函数式的方式来编程。\n3. 一个架构设计良好的应用程序应该将状态可修改的部分和不需要修改的部分隔离成单独的组件，然后用合适的机制来保护可变量。可变状态组件的逻辑越少越好。\n4. 好处：\n   - 没有可变状态，函数就是引用透明(referential transparency)的和没有有副作用(no side effect)\n   - 可以解决并发竞争，死锁等问题\n   - 代码容易进行推理，不容易出错。\n   - 由于函数式语言是面向数学的抽象，更接近人的语言，而不是机器语言，代码会比较简洁，也更容被理解。\n5. 面向数学的抽象，将计算描述为一种表达式求值，一句话，函数式程序就是一个表达式。\n6. 函数式编程中的函数不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅仅取决于函数参数的值。\n7. 函数式编程语言中的变量不是命令式编程语言中的变量（存储状态的单元），而是代数中的变量，即一个值的名称。变量的值是不可变的。命令式编程中的\"x = x + 1\"（赋值运算），拿给程序员看说是对的，拿给数学家看，却被认为这个等式为假。\n\n\n## Imperative programming 指令式编程\n1. 面向计算机硬件的抽象\n   - 变量： 存储单元\n   - 赋值语句： 获取，存储指令\n   - 表达式： 内存引用和算数运算\n   - 控制语句： 跳转指令\n1. 冯诺依曼机的指令序列。\n\n\n## Reference\n1. <<架构整洁之道>>\n","tags":["Paradigm"],"categories":["Program","PLT"]},{"title":"Awesome Books","url":"/2021/08/16/Awesome-Books/","content":"\n## Awesome Books\n\n1. [深入理解计算机系统 Computer Systems:A Programmer's Perspective Computer Systems:A Programmer's Perspective CSAPP](https://hansimov.gitbook.io/csapp/publish-info/publisher-words)\n1. [计算机程序的构造和解释 Structure and Interpretation of Computer Programs SICP](https://github.com/sarabander/sicp-pdf)\n1. 计算机体系结构 量化研究方法\n1. 计算机组成与设计 硬件软件接口\n1. 重构\n1. 架构整洁之道\n1. 代码整洁之道\n1. 设计模式\n1. 编译原理\n1. 软件建模与设计\n1. C++ Primer\n1. [Software-Engineering-at-Google 中文版本](https://github.com/qiangmzsx/Software-Engineering-at-Google)\n1. [Software Engineering at Google](https://abseil.io/resources/swe-book)\n1. [Category Theory for Programmers](https://github.com/hmemcpy/milewski-ctfp-pdf)\n\n## links\n\n1. [cs-books/influential-cs-books](https://github.com/cs-books/influential-cs-books)\n"},{"title":"Modern Cmake","url":"/2021/07/28/Cmake/","content":"\n## code generate\n\n1. vitis ai library overview generate test_performance.... [link](https://github.com/Xilinx/Vitis-AI/blob/v2.5/src/Vitis-AI-Library/overview/cmake/XilinxTest.cmake#L346)\n\n## 版本升级\n\n1. 下载 sh 脚本，本地升级。[link](https://github.com/Kitware/CMake/releases)\n\n## 变量\n\n1. `CMAKE_SOURCE_DIR`: project\n1. `CMAKE_CURRENT_SOURCE_DIR` 当前 CMakeLists.txt 所在目录\n1. `CMAKE_BINARY_DIR`: 编译目录\n1. `CMAKE_CURRENT_BINARY_DIR`: 指向当前正在处理的 CMakeLists.txt 文件对应的构建目录。\n\n## Notes\n\n1. `-DCMAKE_TOOLCHAIN_FILE=path/to/toolchain-clang.cmake` 设置 toolchain\n1. `-DCMAKE_BUILD_TYPE=RelWithDebInfo` release 模式编译，带 debug info\n1. `-DCMAKE_VERBOSE_MAKEFILE=ON` 显示详细信息\n1. `cmake -S . -B build --trace-source=CMakeLists.txt` trace CMakeLists.txt\n1. `cmake -S . -B build --debug-find` trace find\n1. osqp\n\n```cmake\nif(CMAKE_BUILD_TYPE STREQUAL \"Debug\")                                                                                                                                                                                                                             set(OSQP_ENABLE_DEBUG ON)\n  set(CMAKE_VERBOSE_MAKEFILE ON)\n  set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nendif()\n```\n\n1. `-DCMAKE_CXX_FLAGS=\"-g\"` cmake 编译选项添加 debug info； release 模式也适用\n1. 参考官方写 CMakeLists.txt: [cmake](https://gitlab.kitware.com/cmake/cmake) [opencv](https://github.com/opencv/opencv)\n1. `Call stack`: 看出问题的顺序\n1. CMake 3.13 now allows the target_link_libraries() command to be called from any directory to add link dependencies and link interface libraries to targets created in other directories.\n1. cmake 2.8 3.1 对 string(REGEX MATCH \"lib.\\*\\.so$\" LIB ${LIB}) 处理是不同的， 2.8 需要加`\\\\.`\n1. get_filename_component(LIB ${LIB} NAME_WE) 获取文件名，无后缀\n1. 参考 opencv 等库的 CMakeLists.txt\n1. 对外 include 里如果包含，需要 PUBLIC 传递出去，如果只在实现里用则用 PRIVATE\n1. `RUNTIME_DEPENDENCIES` 3.21 之后可以安装依赖库\n1. `#cmakedefine USE_MYMATH` 条件编译能看到定义的配置\n1. 增量编译：是在源程序已经完成第一次编译的基础上再次编译时采取的一种增量性编译技术。只重新编译必须的部分，即通过依赖分析，只编译修改过的部分及其影响的路径。\n1. debug CMakeLists.txt `cmake -S . -B build --trace-source=CMakeLists.txt`\n1. 处理依赖关系时区别名，例如导入 gflags.so `add_library(gflags SHARED IMPORTED GLOBAL) add_library(gflags::gflags ALIAS gflags)`来区别 libgflags.so\n1. 注意区分`add_library(gflags SHARED IMPORTED GLOBAL)`和`libgflags.so`的区别，前者是 target, 后者是 so。为了区分两者， 可以使用`add_library(gflags SHARED IMPORTED GLOBAL) add_library(gflags::gflags ALIAS gflags)` target::target 来区分。\n1. `cmake` + `ninja` + `clang` 组合加速编译\n1. bazel、GYP、CMake 和 Meson 是文件生成器， make, ninja 是构建系统。\n1. `cmake ..`: configure the project and generate a native build system\n1. cmake 修改编译选项时需要删除 build 目录下的 `CMakeCache.txt` 否则编译选项不 work, 或者重新`cmake ..` or run script [link](https://stackoverflow.com/a/42922588)\n1. **加速编译**： `configure the project and generate a native build system`后直接执行`make -C $BUILD_DIR -j4` or `cmake --build ${BUILD_DIR}`，不用每次都重新构建编译系统\n1. [CMake] Debug build compiles and links, but Release build fails to link?\n\n```cmake\nif (CMAKE_BUILD_TYPE MATCHES Release)\n    set(CMAKE_SHARED_LINKER_FLAGS \"-s -Wl,--version-script=${PROJECT_SOURCE_DIR}/symbol.lst\")\nendif()\n```\n\n1. -DCMAKE_BUILD_TYPE=Debug: `-fPIC -O2 -Wall`\n1. -DCMAKE_BUILD_TYPE=Release: `-fPIC -O2 -DNDEBUG`\n1. `enable_testing()` 需要在第一级 CMakeLists.txt 里，否则`make test`不生效\n1. make test 中程序 pwd 路径为 build 目录程序所在路径。\n1. `Testing/Temporary/LastTest.log` 为`make test`结果\n1. `set(CMAKE_VERBOSE_MAKEFILE on)` make 时显示详细信息，等效为`make VERBOSE=1`\n1. set(CMAKE_C_COMPILER /opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc)， s\u0011et(CMAKE_CXX_COMPILER /opt/gcc-linaro-6.5.0-2018.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-g++) 要在 project 前， 会根据编译器选择环境， 无这条则会选择宿主机， 地平线 demo 问题。\n1. option 和 c++里的 definition 是不一样的 definition 需要 add_definitions()来添加\n\n## functions\n\n### add test\n\n### cpm add lib\n\n## cmake 变量\n\n### 作用域\n\n## cmake component\n\n## 依赖管理\n\n1. [CPM.cmake](https://github.com/cpm-cmake/CPM.cmake)\n1. [FetchContent](https://cmake.org/cmake/help/latest/module/FetchContent.html)\n1. CPM.cmake 封装了 FetchContent\n1. 导入已经编译好的库\n1. 导入三方库参考 cmake export 出的 cmake file。参见 cpp_sandbox/cmake/export; 查看生成的 cmake 文件，主要两个步骤\n   - add_library(xxx::xxx STATIC IMPORTED) 导入库\n   - set_target_properties 设置 include 和 link 依赖\n1. 参考 vitis ai 导入 xrt\n\n```cmake\nif(gflags_ADDED)\n  add_library(gflags INTERFACE IMPORTED GLOBAL) ## global导入， 解决cpm local scope include_directories不工作问题\n  add_library(gflags::gflags ALIAS gflags)\n  set_target_properties(\n    gflags PROPERTIES IMPORTED_LOCATION \"${gflags_SOURCE_DIR}/lib/libgflags.so\")\n  target_include_directories(gflags INTERFACE \"${gflags_SOURCE_DIR}/include\")\n  # target_link_directories(gflags INTERFACE \"${gflags_SOURCE_DIR}/lib\")\nendif()\n```\n\n## cpack\n\n### build 完之后 make package\n\n```cmake\nset(CPACK_GENERATOR \"TGZ\")\nset(CPACK_PACKAGE_FILE_NAME \"cpack-test\")                                                                                                                                                                           include(CPack)\n```\n\n## color\n\n1. [cmake 自带打印颜色](https://stackoverflow.com/a/36233927) `cmake -E cmake_echo_color --green \">>>>> Download doxygen\"`\n1. put make function in .bashrc\n\n```sh\nmake()\n{\n  pathpat=\"(/[^/]*)+:[0-9]+\"\n  ccred=$(echo -e \"\\033[0;31m\")\n  ccyellow=$(echo -e \"\\033[0;33m\")\n  ccend=$(echo -e \"\\033[0m\")\n  make \"$@\" 2>&1 | sed -E -e \"/[Ee]rror[: ]/ s%$pathpat%$ccred&$ccend%g\" -e \"/[Ww]arning[: ]/ s%$pathpat%$ccyellow&$ccend%g\"\n  return ${PIPESTATUS[0]}\n}\n```\n\n## basic\n\n1.  内置函数获取名字\n\n````cmake\nstring(REGEX MATCH \"lib.*\\.so$\" LIB ${LIB})\nif(LIB)\n    get_filename_component(LIB ${LIB} NAME_WE)\n    string(REPLACE \"lib\" \"\" LIB \"${LIB}\")\nendif()\n```\n\n1.  获取库列表名字\n\n```cmake\nexecute_process(\n  COMMAND ls\n  COMMAND sh -c \"awk '/.so\\$|.a\\$/{print \\$0}'\"\n  COMMAND sh -c \"awk -F '.' '{print substr($1,4)}'\"\n  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n  OUTPUT_VARIABLE LIBS\n  OUTPUT_STRIP_TRAILING_WHITESPACE)\nmessage(STATUS, \"LIBS=${LIBS}\")\nstring(REPLACE \"\\n\" \";\" LIBS \"${LIBS}\")\nlist(LENGTH LIBS len)\nmessage(STATUS, \"len=\\\"${len}\\\"\")\nstring(REPLACE \" \" \";\" SEXY_LIST ${LIBS})\nforeach(LIB ${LIBS})\n  message(STATUS, \"LIB=\\\"${LIB}\\\"\")\nendforeach()\n\n````\n\n1. `include(CMakePrintHelpers) cmake_print_variables(MY_VARIABLE)\" 打印信息\n1. `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON` 代码补全使用\n1. `cmake -LA` after build in build dir:list a set of available options in the cmake\n1. 如果 CMAKE_BUILD_TYPE 的值为\"Debug\"就采用 debug 模式编译；如果 CMAKE_BUILD_TYPE 的值为\"Release\"就采用 release 模式编译；如果 CMAKE_BUILD_TYPE 的值为空，默认采用 release 模式\n1. debug release set\n\n1. CMakeLists.txt\n\n```cmake\nSET(CMAKE_BUILD_TYPE \"Debug\")\nor\nSET(CMAKE_BUILD_TYPE \"Release\")\n```\n\n1. build script\n\n```sh\nmkdir Release\ncd Release\ncmake -DCMAKE_BUILD_TYPE=Release ..\nmake\n```\n\n1. `set(CMAKE_CXX_COMPILER \"g++\")` 选择编译器\n1. 查看 target properties\n\n```cmake\n# Get all propreties that cmake supports\nif(NOT CMAKE_PROPERTY_LIST)\n    execute_process(COMMAND cmake --help-property-list OUTPUT_VARIABLE CMAKE_PROPERTY_LIST)\n\n    # Convert command output into a CMake list\n    string(REGEX REPLACE \";\" \"\\\\\\\\;\" CMAKE_PROPERTY_LIST \"${CMAKE_PROPERTY_LIST}\")\n    string(REGEX REPLACE \"\\n\" \";\" CMAKE_PROPERTY_LIST \"${CMAKE_PROPERTY_LIST}\")\nendif()\n\nfunction(print_properties)\n    message(\"CMAKE_PROPERTY_LIST = ${CMAKE_PROPERTY_LIST}\")\nendfunction()\n\nfunction(print_target_properties target)\n    if(NOT TARGET ${target})\n      message(STATUS \"There is no target named '${target}'\")\n      return()\n    endif()\n\n    foreach(property ${CMAKE_PROPERTY_LIST})\n        string(REPLACE \"<CONFIG>\" \"${CMAKE_BUILD_TYPE}\" property ${property})\n\n        # Fix https://stackoverflow.com/questions/32197663/how-can-i-remove-the-the-location-property-may-not-be-read-from-target-error-i\n        if(property STREQUAL \"LOCATION\" OR property MATCHES \"^LOCATION_\" OR property MATCHES \"_LOCATION$\")\n            continue()\n        endif()\n\n        get_property(was_set TARGET ${target} PROPERTY ${property} SET)\n        if(was_set)\n            get_target_property(value ${target} ${property})\n            message(\"${target} ${property} = ${value}\")\n        endif()\n    endforeach()\nendfunction()\n\nprint_target_properties(xxx)\n```\n\n1. 查看 cmake property\n\n```\nget_cmake_property(_variableNames VARIABLES)\nforeach (_variableName ${_variableNames})\n    message(STATUS \"${_variableName}=${${_variableName}}\")\nendforeach()\n```\n\n1. 查看 include_director\n\n```\nget_property(dirs DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY INCLUDE_DIRECTORIES)\nforeach(dir ${dirs})\n  message(STATUS \"include dir='${dir}'\")\nendforeach()\n\nget_property(dirs DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY LINK_DIRECTORIES)\nforeach(dir ${dirs})\n  message(STATUS \"link dir='${dir}'\")\nendforeach()\n```\n\n1. ctest -N 查看 test 列表\n1. target_compile_definitions(full_flow PRIVATE \"-DGIT_INFO=\\\"${GIT_BRANCH}-${GIT_COMMIT_HASH}\\\"\") 代替 add_definitions(-DGIT_INFO)\n1. add_subdirectory(protobuf) 添加子文件夹，子文件夹下 CmakeLists.txt 管理相应文件夹。\n1. cmake_minimum_required(VERSION 3.8） 版本要求\n1. project(HELLO) 定义工程名\n1. message(STATUS, \"“） 打印消息\n1. aux_source_directory(. DIR_SRCS) 查找指定目录下的所有源文件并将结果存入变量名\n1. add_excutable(hello, ${DIR_SRCS}) 定义了工程生成的可执行程序文件名，源文件为 DIR_SRCS 变量中定义的源文件列表\n1. add_library(libname [SHARED | STATIC | MODULE] source_files) 定义了库文件名 静态库，动态库不能重名\n1. add_library(hello_static STATIC ${LIBHELLO_SRC}) set_target_properties(hello_static PROPERTIES OUTPUT_NAME \"hello\") 有 libhello.so 的情况下生成 libhello.a\n1. CMAKE_INSTALL_PREFIX 变量类似于 configure 脚本的 – prefix,常见的使用方法看 cmake -DCMAKE_INSTALL_PREFIX=/usr .\n1. install(TARGETS name [ARCHIVE|LIBRARY|RUNTIME] [DESTINATION <dir>] ...) 安装库和可执行程序\n1. install(FILES include/quicksort.hpp DESTINATION include) 安装头文件\n1. include_directories(/usr/include/hello) 添加头文件搜索路径\n1. link_directories(dir1 dir2...) 添加链接库路径\n1. 官网不推荐使用 link_directoris，而是推荐使用 find_package 和 find_library 寻找共享库的绝对路径，再传给 target_link_libraries 使用\n1. find_library(LIBQUICKSORT_PATH quicksort ./lib)\n1. find_path(GLOG_INCLUDE_DIR glog/logging.h PATHS ${GLOG_ROOT_DIR}) 先查找路径再查找库 find_library(GLOG_LIBRARY glog PATHS ${GLOG_ROOT_DIR} PATH_SUFFIXES lib lib64)\n1. target_link_libraries(main hello) 为可执行程序添加 libhello.so 链接库\n1. add_definitions(\"-DNDEBUG\" \"-O3\") 向编译器添加编译选项\n1. set(CMAKE_CXX_FLAGS \"$(CMAKE_CXX_FLAGS) -std=c++11\") 设置 C++编译选项 等价于 add_definitons(\"-std=c++11)\n1. option 选项，让你可以根据选项值进行条件编译 option(DEBUG \"Debug mode.\" OFF)\n1. cmake --help-module FindProtobuf ；cmake --help-module FindThreads 查看模块的 cmake 用法\n1. list\n1. file\n1. string\n1. foreach\n1. if 用法\n\n```\noption(DEBUG \"Debug mode.\" OFF)\nif(DEBUG)\n    message(STATUS \"Use Debug mode\")\nelse()\n    message(STATUS \"Don't use Debug mode\")\nendif\n\n```\n\n## Concepts\n\n1. CMake is not a build system. It's the build system generator.\n2. add_subdirectory 最好只有一层，避免嵌套，只添加顶层文件夹\n\n## Target and Property\n\n1. 现代化的 CMake 是围绕 Target 和 Property 来定义的，并且竭力避免出现变量 variable 的定义。Variable 横行是典型 CMake2.8 时期的风格。现代版的 CMake 更像是在遵循 OOP 的规则，通过 target 来约束 link、compile 等相关属性的作用域。\n\n### Target\n\n1. 如果把一个 Target 想象成一个对象（Object），会发现两者的组织方式非常相似：\n\n```\n构造函数：\nadd_executable\nadd_library\n成员函数：\nget_target_property()\nset_target_properties()\nget_property(TARGET)\nset_property(TARGET)\ntarget_compile_definitions()\ntarget_compile_features()\ntarget_compile_options()\ntarget_include_directories()\ntarget_link_libraries()\ntarget_sources()\n成员变量\nTarget properties（太多）\n```\n\n### Properties\n\n1. target_xxx 命令 PRIVATE/PUBLIC...后为 property，例如\n\n```\ntarget_source(MyEXE PRIVATE \"main.cpp\")  ## main.cpp为source属性\ntarget_link_library(MyEXE PRIVATE Poco::Net Poco::Util) ## Poco:Net Poco::Util为link属性\ntarget_compile_definition(MyEXE PRIVATE std_cxx_14) ## std_cxx_14为编译属性\n```\n\n## Build-Requirements and Usage-Requirements\n\n1. `Build-Requirements`： 包含了所有构建 Target 必须的材料。如源代码，include 路径，预编译命令，链接依赖，编译/链接选项，编译/链接特性等。\n1. `Usage-Requirements`：包含了所有使用 Target 必须的材料。如源代码，include 路径，预编译命令，链接依赖，编译/链接选项，编译/链接特性等。这些往往是当另一个 Target 需要使用当前 target 时，必须包含的依赖\n\n## PRIVATE/INTERFACE/PUBLIC\n\n1. 定义了`Target属性`的传递范围。\n1. `PRIVATE`: 表示 Target 的属性只定义在当前 Target 中，任何依赖当前 Target 的 Target 不共享 PRIVATE 关键字下定义的属性。\n1. `INTERFACE`：表示 Target 的属性不适用于其自身，而只适用于依赖其的 Target。\n1. `PUBLIC`：表示 Target 的属性既是 build-requirements 也是 usage-requirements。凡是依赖。凡是依赖于当前 Target 的 Target 都会共享本属性。\n\n## Modern Cmake Using Steps\n\n1. Always create targets with no sources first.\n1. Use `target...` commands to add build-/usage-requirements\n1. Use `IMPORTED` targets for external libraires. But, prefer `find_package` or `EXPORTED` targets ro creating them yourself.\n\n## 3.13 之默认生成绝对路径\n\n1. 3.13 之前\n\n```\nadd_library( MyTarget SHARED )\ntarget_sources ( MyTarget\n    PRIVATE    src/A.cpp\n               src/B.cpp\n               headers/B.hpp\n    PUBLIC     ${CMAKE_CURRENT_SOURCE_DIR}/headers/A.hpp\n    INTERFACE  ${CMAKE_CURRENT_SOURCE_DIR}/headers/C.hpp\n)\n```\n\n1. 3.13 之后生成绝对路径\n\n```\nadd_library( MyTarget SHARED )\ntarget_sources ( MyTarget\n    PRIVATE    src/A.cpp\n               src/B.cpp\n               headers/B.hpp\n    PUBLIC     headers/A.hpp\n    INTERFACE  headers/C.hpp\n)\n```\n\n## CMakeLists.txt\n\n1. top level CMakeLists.txt begining:\n\n```\ncmake_minimum_required( VERSION 3.15...3.17 )\n\nset( CMAKE_PROJECT_INCLUDE_BEFORE\n     \"${CMAKE_CURRENT_LIST_DIR}/common-project-info.in\" )\n# include( \"${CMAKE_CURRENT_LIST_DIR}/common-project-include.in\" )\n\nproject (MyRootProject\n    VERSION ${project_version}\n    DESCRIPTION ${project_description}\n    HOMEPAGE_URL ${project_homepage}\n    LANGUAGES C CXX )\n\n```\n\n```\n# common-project-info.in\n\nset ( project_version 1.2.3 )\nset ( project_description \"test....\" )\nset ( project_homepage \"https://www....\" )\n```\n\n## [find_package](https://zhuanlan.zhihu.com/p/658727351)\n\n1. `export CMAKE_PREFIX_PATH=/usr/lib/x86_64-linux-gnu:/usr/local/lib/x86_64-linux-gnu` or `set(CMAKE_FIND_ROOT_PATH /usr/lib/x86_64-linux-gnu /usr/local/lib/x86_64-linux-gnu)`设置查找路径\n1. find_package 采用两种模式搜索库：The “better” way(Config 模式) to do things is to have an installed package provide its own details to CMake; [link](https://hsf-training.github.io/hsf-training-cmake-webpage/09-findingpackages/index.html#findpackage)\n\n   - `Module模式`：搜索 CMAKE_MODULE_PATH 指定路径下的 FindXXX.cmake 文件，执行该文件从而找到 XXX 库。其中，具体查找库并给 XXX_INCLUDE_DIRS 和 XXX_LIBRARIES 两个变量赋值的操作由 FindXXX.cmake 模块完成。\n   - `Config模式`：搜索 XXX_DIR 指定路径下的 XXXConfig.cmake 文件，执行该文件从而找到 XXX 库。其中具体查找库并给 XXX_INCLUDE_DIRS 和 XXX_LIBRARIES 两个变量赋值的操作由 XXXConfig.cmake 模块完成\n\n1. 两种模式看起来似乎差不多，不过 cmake 默认采取 Module 模式，如果 Module 模式未找到库，才会采取 Config 模式。如果 XXX_DIR 路径下找不到 XXXConfig.cmake 文件，则会找/usr/local/lib/cmake/XXX/中的 XXXConfig.cmake 文件。总之，Config 模式是一个备选策略。通常，库安装时会拷贝一份 XXXConfig.cmake 到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。\n\n## find_path and include\n\n```\nfind_path(XRT_INCLUDE_DIRS\n    NAMES xrt.h\n    PATH_SUFFIXES xrt\n    )\nmessage(\"config types: ${XRT_INCLUDE_DIRS}\")\n```\n\n## pkg-config\n\n1. 如果 find_package 找不到库，如果系统中有库的.pc 配置文件，可以使用 pkg-config 替代。\n\n```cmake\nfind_package(glog QUIET)\nif (NOT glog_FOUND)\n    find_package(PkgConfig)\n    pkg_search_module(PKG_GLOG REQUIRED IMPORTED_TARGET GLOBAL libglog)\n    add_library(glog::glog ALIAS PkgConfig::PKG_GLOG)\nendif(NOT glog_found)\n```\n\n## 组件变量\n\n## samples\n\n1. 例子 1：最基础例子\n\n```\ncmake_minimum_required(VERSION 3.8)\nproject(QUICKSORT)\naux_source_directory(. DIR_SRCS)\nadd_definitions(\"-DNDEBUG\" \"-O3\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nadd_executable(quicksort ${DIR_SRCS})\n```\n\n2. 例子 2： 使用静态库并安装\n\n```\ncmake_minimum_required(VERSION 3.8)\nproject(QUICKSORT)\n#aux_source_directory( DIR_SRCS)\n#add liabrary\nadd_library(quicksort\n    include/quicksort.hpp\n    src/quicksort.cpp)\ninstall(TARGETS quicksort DESTINATION lib)  #安装静态库\n\n#add target\nset(SRC_LIST src/main.cpp)\nadd_definitions(\"-DNDEBUG\" \"-O3\" \"-std=c++11\")\n#set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nadd_executable(main ${SRC_LIST})\n\n#link library\ninclude_directories(include)\ntarget_link_libraries(main quicksort)\n\n#install program\ninstall(TARGETS main RUNTIME DESTINATION bin)\n```\n\n1. 例子 3 只使用动态库\n\n```\ncmake_minimum_required(VERSION 3.8)\nproject(QUICKSORT)\n#aux_source_directory( DIR_SRCS)\n#add shared liabrary\nadd_library(quicksort SHARED\n    include/quicksort.hpp\n    src/quicksort.cpp)\ninstall(TARGETS quicksort LIBRARY DESTINATION lib)\ninstall(FILES include/quicksort.hpp DESTINATION include)\n\n#add target\nset(SRC_LIST src/main.cpp)\nadd_definitions(\"-DNDEBUG\" \"-O3\" \"-std=c++11\")\n#set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nadd_executable(main ${SRC_LIST})\n\n#link library\ninclude_directories(include)\ntarget_link_libraries(main quicksort)\n```\n\n1. 例子 4 安装静态库和动态库\n\n```\ncmake_minimum_required(VERSION 3.8)\nproject(QUICKSORT)\n#aux_source_directory( DIR_SRCS)\n#add shared liabrary\nadd_library(quicksort SHARED\n    include/quicksort.hpp\n    src/quicksort.cpp)\n#add static liabrary\nadd_library(quicksort_static STATIC\n    include/quicksort.hpp\n    src/quicksort.cpp)\nset_target_properties(quicksort_static PROPERTIES OUTPUT_NAME \"quicksort\")\n\nSET_TARGET_PROPERTIES(quicksort PROPERTIES CLEAN_DIRECT_OUTPUT 1)\nSET_TARGET_PROPERTIES(quicksort_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)\ninstall(TARGETS quicksort LIBRARY DESTINATION lib)\ninstall(TARGETS quicksort_static ARCHIVE DESTINATION lib)\ninstall(FILES include/quicksort.hpp DESTINATION include)\n\n#add target\nset(SRC_LIST src/main.cpp)\nadd_definitions(\"-DNDEBUG\" \"-O3\" \"-std=c++11\")\n#set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nadd_executable(main ${SRC_LIST})\n\n#link library\ninclude_directories(include)\ntarget_link_libraries(main quicksort)\n\n# 参考 https://www.cnblogs.com/zhoug2020/p/5904206.html\n```\n\n1. 例子 5 添加 glog 库\n\n```\ncmake_minimum_required(VERSION 3.8)\nproject(QUICKSORT)\n#aux_source_directory( DIR_SRCS)\n#add shared liabrary\nadd_library(quicksort SHARED\n    include/quicksort.hpp\n    src/quicksort.cpp)\n#add static liabrary\nadd_library(quicksort_static STATIC\n    include/quicksort.hpp\n    src/quicksort.cpp)\nset_target_properties(quicksort_static PROPERTIES OUTPUT_NAME \"quicksort\")\n\nSET_TARGET_PROPERTIES(quicksort PROPERTIES CLEAN_DIRECT_OUTPUT 1)\nSET_TARGET_PROPERTIES(quicksort_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)\ninstall(TARGETS quicksort LIBRARY DESTINATION lib)\n#install(TARGETS quicksort_static ARCHIVE DESTINATION lib)\ninstall(FILES include/quicksort.hpp DESTINATION include)\n\n#add target\nset(SRC_LIST src/main.cpp)\nadd_definitions(\"-DNDEBUG\" \"-O3\" \"-std=c++11\")\n#set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nadd_executable(main ${SRC_LIST})\n\n#link library\ninclude_directories(include /home/jiaxiyang/workspace/glog/lib/include) #添加glog include目录\nlink_directories(/home/jiaxiyang/workspace/glog/lib/lib) #添加glog库安装路径\ntarget_link_libraries(main quicksort glog)\ninstall(TARGETS main RUNTIME DESTINATION bin)\n```\n\n1. 例子 6 链接自己编译的库\n\n```\ncmake_minimum_required(VERSION 3.8)\nproject(QUICKSORT)\n\n#SET_TARGET_PROPERTIES(quicksort PROPERTIES CLEAN_DIRECT_OUTPUT 1)\n#SET_TARGET_PROPERTIES(quicksort_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)\n#install(TARGETS quicksort LIBRARY DESTINATION lib)\n#install(TARGETS quicksort_static ARCHIVE DESTINATION lib)\n#install(FILES include/quicksort.hpp DESTINATION include)\n\n#add target\nset(SRC_LIST src/main.cpp)\nadd_definitions(\"-DNDEBUG\" \"-O3\" \"-std=c++11\")\n#set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nadd_executable(main ${SRC_LIST})\n\n#link library\ninclude_directories(/home/jiaxiyang/workspace/algorithm/quicksort1/include /home/jiaxiyang/workspace/glog/lib/include) #添加glog include目录\nlink_directories(/home/jiaxiyang/workspace/glog/lib/lib) #添加glog库安装路径\n#link_directories(/home/jiaxiyang/workspace/algorithm/quicksort1/lib) #添加glog库安装路径   如果没有find_library，出现在add_executable后面会出错 建议用find_library\nfind_library(LIBQUICKSORT_PATH quicksort ./lib)\nMESSAGE(STATUS ${LIBQUICKSORT_PATH} \" found\")\n\ntarget_link_libraries(main ${LIBQUICKSORT_PATH} glog)\ninstall(TARGETS main RUNTIME DESTINATION bin)\n\n```\n\n## Links\n\n1. [More Modern CMake](https://hsf-training.github.io/hsf-training-cmake-webpage/)\n1. [参考文档: 构建百科全书， 测试百科全书，命令行参考文档，查询参考文档](https://bazel.build/reference?hl=zh-cn)\n1. [Cmake Tutorial](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)\n1. [Cmake Forum](https://discourse.cmake.org/)\n1. [Professional CMake pdf](https://github.com/jiaxiyang/documents/blob/master/pcmake.pdf)\n1. [Cmake Buildsystem](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html)\n1. [Effective Modern Cmake](https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1)\n1. [Effective Modern Cmake video](https://www.youtube.com/watch?v=bsXLMQ6WgIk)\n1. [Deniz Bahadir 2019](https://www.youtube.com/watch?v=y9kSr5enrSk)\n1. [Deniz Bahadir 2018 traditional and modern camke](https://www.youtube.com/watch?v=y7ndUhdQuU8)\n1. [Beniz Bahadir PPT](https://github.com/Bagira80/More-Modern-CMake)\n1. [OO Cmake](https://zhuanlan.zhihu.com/p/76975231)\n1. [Cmake Concept](https://ukabuer.me/blog/more-modern-cmake)\n","tags":["Cmake"],"categories":["Tools","Cmake"]},{"title":"Cpp-concurrency-in-action","url":"/2021/07/20/Cpp-concurrency-in-action/","content":"\n## Notes\n\n1. [C++ Concurrency in action 2](https://b-ok.lat/book/3688262/d57395?dsource=recommend&regionChanged=&redirect=4729105)\n1. [C++ Concurrency in action Chinese](https://github.com/xiaoweiChen/CPP-Concurrency-In-Action-2ed-2019)\n1. 多线程写共享数据时，需要加锁`const std::lock_guard<std::mutex> lock(results_len_mutex_);`\n1. 异步程序并行度跟有几个耗时的模块相关，例如：yolox 推理和后处理最耗时，异步并行度设为 2，做当前帧的后处理同时做下一帧的模型推理。\n1. 异步需要考虑 timeout 问题， 可以使用 `condition_variable`\n1. . 流控：\n\n```c++\nconst auto time_start = std::chrono::steady_clock::now();\nconst auto time_end = std::chrono::steady_clock::now();\nauto cost_ms =\n    std::chrono::duration_cast<std::chrono::milliseconds>(time_end - time_start);\nstd::this_thread::sleep_for(\n    std::chrono::milliseconds(static_cast<int>(1000.0 / fps)) - cost_ms);\n```\n\n## 1. Hello, world of concurrency in C++\n\n### 1.1 并发是什么\n\n1. 多进程并发优点： 操作系统在进程间提供的保护操作和更高级别的通信机制，可以更容易编写安全的并发代码。还有一个优势，可以使用远程连接的方式，在不同的机器上运行独立的进程。\n\n### 1.2 为什么使用并发\n\n1. `分离程序`： 将相互独立的部分分开就行操作。如 DVD 用户界面和播放功能应分离。\n1. `性能`：两种方式：任务并行（将单一任务分成几部分并行）和数据并行（每个线程在不同的数据块上执行相同的操作）\n\n#### 1.2.1 什么时候不使用并发\n\n1. 收益比不上成本，除非潜在性能足够大，否则不使用并发，需要脑力成本和维护成本，代码更复杂，难以理解。\n1. 资源有限： 太多线程的会耗尽资源。可以使用线程池进行优化。太多的线程上下文切换导致的性能损耗可能比增加线程的收益更多。\n\n### 1.3 并发和多线程\n\n#### 1.3.1 C++多线程历史\n\n1. C++98 标准不支持多线程，没有内存模型。\n1. 各种非标准多线程库：MFC，Boost，大部分使用的是 RAII\n\n#### 1.3.2 支持并发\n\n1. C++11: `线程管理，共享数据保护，线程间同步操作，原子操作`\n1. C++11 之后，C++标准支持多线程，也就是说可以跨平台编写高效，可移植的代码。编译器可以搞定具体平台，用户无需担心。\n\n#### 1.3.4 C++线程库的效率\n\n1. 高级工具（使用高级 API, 抽象高）和低级工具（使用低级 API，抽象低)有开销差，即抽象代价（abstraction penalty)。C++标准库设计时尽量使得高级 API 和低级 API 具有相同的性能。\n1. 低级工具：为了达到终极性能，需要提供给硬件打交道的低级 API。为了这个目的，形成了原子操作库。\n1. 高级工具：为了使得编写多线程代码更简单。因为有额外的代码需要执行，这些工具会带来性能开销。\n1. 如果很看重性能或者高级工具开销过高，可以通过低层工具来实现。绝大多数情况，有过高的复杂度和过大的出错率，来交换小幅度的性能收益是不划算的。\n\n## 2. Managing threads\n\n1.  文件锁用在进程之间，线程之间锁不住，文件锁是应用于进程中的一种锁，由于多线程是通过修改文件描述符指向的文件结构体中的成员变量实现，所以文件锁不能用于线程之间。 见[fslock](https://docs.rs/fslock/0.1.6/fslock/struct.LockFile.html)\n\n### 2.5 线程标识\n\n1. `std::this_thread::get_id()`获取当前线程的 ID.\n\n## 3. Sharing data between threads\n\n1. 错误的数据共享是多线程产生 bug 的主要原因。\n1. `data race`: the specific type of race condition that arises because of concurrent modification to a single object\n1. 数据竞争时间敏感，Bug 可能很难复现，很难查找。\n\n### 3.2 使用互斥量\n\n1. 访问共享数据前将数据锁住，访问结束将数据解锁。\n1. 互斥量是 C++保护数据最通用的机制。\n1. 互斥量问题： 死锁，对数据保护太多。\n1. 一个互斥量只能用于一个资源的互斥访问。\n1. 互斥量(互斥锁)本质上是一把锁。\n\n#### 3.2.1 互斥量\n\n1. `std::mutex`创建互斥量，`lock`对互斥量上锁，unlock 为解锁。\n1. RAII 管理互斥量：C++标准库为互斥量提供了 RAII 模板类`std::lock_guard`，在构造时提供已锁的互斥量（lock_guard 对象在构造时对传进来的 mutex 上锁），并在析构时解锁，从而保证互斥量被正确的解锁。\n1. 大多数情况下，互斥量通常会与需要保护的数据放在同一类中，而不是定义成全局变量。\n1. C++17 提供`std::scoped_lock`加强版的`std::lock_guard`, 可以接受多个参数。\n\n#### 3.2.4 死锁\n\n1. 死锁一般解决方法：按顺序上锁。要么将两个都锁住，要么一个都不锁。\n1. `std::lock`能同时锁住多个互斥量。\n1. C++17 中的`std::scoped_lock<>`是一种新的 RAII 模板类型。能接受不定数量的互斥量类型作为模板参数。在构造 scoped_lock 对象时对传入的 mutex 上锁，析构时解锁。\n1. `std::lock`锁上 mutex 之后不负责释放，还需要配合 lock_guard 或者手动释放 mutex。`std::scoped_lock`生命周期结束后会自动释放锁。\n1. C++17 特性：`自动推导模板参数`。可以简写为`std::scoped_lock lk(m1, m2);` 而不用写为`std::scoped_lock<std::mutex, std::mutex> lk(m1, m2);`\n\n### actomic\n\n1. 从效率上来说，原子操作要比互斥量的方式效率要高。\n1. 互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。\n1. store 和 load 来赋值和读取， 除了初始化不要使用赋值\n1. [atomic 不一定免锁](https://zh.cppreference.com/w/cpp/atomic/atomic/is_lock_free)\n1. 对结构体需要链接 `-latomic`\n1. `-fsanitize=thread`可以检测数据竞争\n\n## 4. Synchronizing concurrent operations on atomic types\n\n### 4.1 等待时间或条件\n\n1. 当一个线程等待另一个线程完成时，有几种选择：\n   - 持续检查共享数据标志，浪费资源查询\n   - 在等待线程时，使用`std::this_thread::sleep_for()`进行周期性间歇，节省执行时间，问题：很难确定休眠时间\n   - 通过标准库提供的工具。例如：`condition variable`\n\n#### [condition_variable](https://blog.csdn.net/wxj1992/article/details/116888582)\n\n1. condition*variable 是一个类，搭配互斥量 mutex 来用，这个类有它自己的一些函数，这里就主要讲 wait 函数和 notify*\\*函数，故名思意，wait 就是有一个等待的作用，notify 就是有一个通知的作用。主要用法这里就不再赘述了，简而言之就是程序运行到 wait 函数的时候会先在此阻塞，然后自动 unlock，那么其他线程在拿到锁以后就会往下运行，当运行到 notify_one()函数的时候，就会唤醒 wait 函数，然后自动 lock 并继续下运行。\n1. wait 线程：当 condition 不满足的时候需要等待，直到条件满足了才做自己的事情。\n1. notify 线程：做完自己的事情后修改 condition 变量并唤醒等待线程。\n1. wait 时未持有锁，wait 之后占有锁\n1. wait 会先判断条件，如果满足，直接返回。\n1. wait_for() 解阻塞时获得 lock， 无论是 notify_all() 或 notify_one() 还是超时都会解阻塞。\n1. `wait_for() 若经过 rel_time 时限后谓词 pred 仍求值为 false 则为 false ，否则为 true` 中途被通知后 pred 为 true 则直接返回 true，如果为 false，继续等待。\n1. 先获得锁，再检测条件？\n1. 解锁之后再 notify， 否则可能出现当前线程还未释放锁，被接收的线程被唤醒后拿不到锁立即就又休眠。\n\n### 4.2 future\n\n1. async（sender)函数是一种 promise,负责发送数据， future（receiver)负责接收数据。`future fut = async([]{return 3+4;}); cout << fut.get() << endl;`\n\n## 5. The C++ memory model and operations on atomic types\n\n### 5.1 内存模型\n\n#### 5.1.1 对象和内存模型\n\n1. C++程序中数据都是由对象构成。\n1. 每个变量都是对象\n1. 每个对象至少占有一个内存位置。\n\n#### 5.1.2 对象，内存位置和并发\n\n1. 当多个线程访问同一内存位置时，如果只读数据，不需要保护，如果有线程对数据进行修改，就可能会产生条件竞争。\n1. 为了避免条件竞争，两个线程就要以一定的`顺序执行`。有两种方式：`互斥量`和`原子操作`\n\n### 5.2 原子操作和原子类型\n\n1. `原子操作`是不可分割的操作。系统的所有线程中，不可能观察到原子操作完成了一半，要么是做了，要么是没做，只有两种可能。非原子操作可能会被另一线程观察到只完成一半，如果是一个存储操作，那么其他线程看到的值，可能既不是存储前的值，也不是存储后的值。\n1. 原子操作是一种操作（函数），互斥量（一种锁）是实现这种操作的一种方式。\n\n#### 5.2.1 标准的原子类型\n\n1. 标准的原子类型定义在头文件`<atomic>`中，这些类型操作都是原子的。\n1. 可以使用互斥量来模拟原子操作。\n1. 原子操作可以替代互斥量来完成同步操作。如果操作内部使用互斥量实现，那么不可能有性能提升，可以使用无锁数据结构来实现。\n1. 通常标准的原子类型是不能进行拷贝和赋值的，他们没有拷贝构造函数和拷贝赋值函数。但是可以隐式的转化为内置类型进行赋值。\n\n## 6. Designing lock-based concurrent data structures.\n\n## 7. Designing lock-free concurrent data structures\n\n## 8. Designing concurrent code\n\n## 9. Advanced thread managment\n\n## 10. Parallel algorithms\n\n## 11. Testing and debugging multithreaded applications\n\n## others\n\n### 什么是临界区\n\n1. 临界区(critical section)是指包含有共享资源的一段代码，这些代码可能被多个线程访问 或修改。 临界区的存在就是为了保证当有一个线程在临界区内执行的时候，不能有其他任何 线程被允许在临界区执行。\n","tags":["Cpp","Concurrency"],"categories":["Program","Cpp"]},{"title":"Rust grammar","url":"/2021/07/11/Rust-grammar/","content":"\n## [顶层概念](https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM)\n\n![概念层次图](https://static001.infoq.cn/resource/image/2d/91/2d36b45f6905a13a310e6447778ca391.jpg)\n\n<!-- more -->\n\n## Grammar\n\n1. unimplemented! and todo!来表明函数未实现，先跳过\n1. indent with four spaces, not a tab\n1. Most lines of Rust code end with a semicolon(;)\n1. `println!()` ! means call macro, not a function\n1. Cargo is Rust's build system and package manager.\n1. Cargo expects your source files to live inside the src directory. The top-level project directory is just for README files, license information, configuration files, and anything else not related to your code.\n1. `cargo run` Compile the code and then run the resulting executable all in one command.\n1. `cargo check` is much faster than `cargo build`\n1. `cargo build --release` compile the project with optimizations. Run faster but compile slower.\n1. The `main` function is the entry point into the program.\n1. The `fn` syntax declares a new function, the parentheses, `()`, indicate there are no parameters, and the curly bracket, `{`, starts the body of the function.\n1. `let` is used to create a variable. In Rust, variables are immutable by default.\n1. `String::new()` An associated function is implemented on a type, in this case String, rather than on a particular instance of a String. Some languages call this a static method. This new function creates a new, empty string. You’ll find a new function on many types, because it’s a common name for a function that makes a new value of some kind.\n1. `{}` is a place holder when using `println!`\n1. Crate is a coleection of Rust source code files.\n1. Cargo.toml dependencies rand = \"0.5.5\"; In this case, we’ll specify the rand crate with the semantic version specifier 0.5.5. Cargo understands Semantic Versioning (sometimes called SemVer), which is a standard for writing version numbers. The number 0.5.5 is actually shorthand for ^0.5.5, which means “any version that has a public API compatible with version 0.5.5.”\n1. `cargo doc --open` It will build documentation provided by all of your dependencies locally and open it in your browser.\n1. `match` is like `switch` in C++\n1. shallow copy, deep copy(clone), move(let s2 = s1; // s1 is invailid)\n1. Differences Between Immutable Variables and Constants:\n   - You declare constants using the const keyword instead of the let keyword, and the type of the value must be annotated.\n   - Constants can be declared in any scope, including the global scope\n   - Constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.\n1. trait can add some useful functions for user's own struct.\n1. trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。\n1. Rust 编译时会将泛型代码单态化(monomorphization)来保证效率，单态化是指编译时用具体类型来填充泛型。\n1. 用户会将重复代码泛化（抽象），编译器会将泛化代码具体化。\n1. trait 类似其他语言中接口(interfaces)功能，虽然有些不同。\n1. 只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。\n1. 在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。当在 debug 模式编译时，Rust 检查这类问题并使程序 panic\n1. Rust 的浮点数默认类型是 f64。数字类型默认是 i32。\n1. Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。\n1. Rust 有两个原生的复合类型：元组（tuple）和数组（array）。\n1. `tuple:` `let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; //结构 let five_hundred = tup.0;`\n1. `struct:`\n\n```rust\nstruct User {\n    username: String,\n    email: String,\n}\n\nlet mut user1 = User {\n    email: String::from(\"someone@example.com\"), //实例中字段的顺序不需要和它们在结构体中声明的顺序一致\n    username: String::from(\"someusername123\"),\n};\n\nuser1.email = String::from(\"anotheremail@example.com\");\n```\n\n1. 我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）因为它们类似于 ()，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。\n1. 方法与函数类似：它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n```\n\n1. impl 块的另一个有用的功能是：允许在 impl 块中定义 不 以 `self` 作为参数的函数。这被称为 `关联函数（associated functions）`，因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 String::from 关联函数了。使用结构体名和 `::` 语法来调用关联函数。\n\n## Project Manage\n\n1. 包`packages`: Cargo 的一个功能，允许你构建、测试和分享 crate\n1. `crates`: 一个模块的`树形`结构，它形成了库或二进制项目。\n1. 模块`modules and use`: 允许你控制作用域和路径的私有性。\n1. 路径`path`: 一个命名机结构体、函数或模块等项的方式。\n1. 在 Rust 中，代码包也被称为 crates\n1. 一个包中可以包含多个二进制 crate 和一个可选的 crate 库。\n1. 包中至少包含一个 crate，无论是库还是二进制，至多包含一个库 crate\n1. `cargo new`会创建一个包。\n1. Cargo 准守一个约定： `src/main.rs`就是一个与包同名的二进制 crate 的 crate 根。同理，`src/lib.rs`是库 crate 的 crate 根。如果同时包含，则它有两个 crate。\n1. 通过将文件放在`src/bin`目录下，一个包可以拥有多个二进制 crate：每个`src/bin`下的文件都会被编译成一个独立的二进制 crate。\n1. 模块让我们可以将一个 crate 中的代码进行分组，以提高重用性。\n1. `模块的定义`是以`mod`(module)关键字为起始，然后指定模块的名字，并且用或花括号包围模块的主题。\n1. `模块的声明`是以`mod`为起始，指定模块名字，以`;`结尾，不带有花括号。在与模块名同名的.rs 文件中定义该模块。\n1. 模块一般是在上一级文件声明，不是在本文件中声明，如可以在 lib.rs 中声明模块，然后在相应.rs 文件中定义该模块。\n1. crate 的组织结构类似于文件系统的目录，被称为模块树(module tree)。\n1. Rust 通过路径来查找一个项的位置。\n1. `绝对路径(absolute path)` 从 crate 根开始，以 crate 名或者字面值`crate`开头。\n1. `相对路径(relative path)` 从当前模块开始，以`self`、`super`或当前模块的表示符开头。\n1. 只有在同一 crate 中才能使用`crate::`关键字为起始的绝对路径。\n1. 模块不仅对你组织代码很有用。它们还定义了 Rust 的私有性边界：这条界限不允许外部代码了解、调用和依赖被封装的实现细节。\n1. Rust 中默认所有项(函数、方法、结构体、枚举、模块、和常量）都是私有的。\n1. 项是指：函数、方法、结构体、枚举、模块和常量。\n1. 父模块中的项不能使用子模块中的私有项，但是子模块可以使用它们父模块中的项。\n1. Rust 通过这种方式来实现模块系统功能，因此隐藏内部实现细节，这样你就知道可以更改内部代码的哪部分而不会破坏外部代码。\n1. 可以使用`super`开头来构建父模块开始的相对路径。类似于文件系统的`..`语法。\n1. 如果请偶们将枚举设置为公有，则它的所有成员都将变为共有。\n1. 在作用域中增加`use`类似于在文件系统中创建软连接。\n1. 使用`use`引入结构体、枚举和其他项时，习惯是指定它们的完整路径。\n1. 使用`use`将两个同名类型引入同意作用域的一个解决办法：在类型后面使用`as`指定一个新的本地名称或者别名。\n1. `use std::{cmp::Ordering, io};`使用嵌套路径减少 use 的使用。\n1. `use std::io:*` 将`std::io`中定义的所有公有项引入当前作用域。使用时要多加小心，常用于测试模块`tests`中。\n1. Rust 将 package 分成多个 crate，将 crate 分成模块，通过绝对或相对路径从一个模块引用另一个模块。\n1. Cargo 提供了叫工作空间`workspaces`的功能，它可以帮助我们管理多个相关的协同开发的包。\n1. 工作空间是一系列共享同样的 cargo.lock 和输出目录的包。\n1. 工作空间顶级目录中的 Cargo.toml 中不包含`[package]`等信息，相反，它以`[workspace]`部分作为开始。\n1. 工作空间在顶级目录有一个`target`目录，`member`并没有自己的 target 目录。通过共享的 target 目录，工作空间可以避免其他 crate 多余的重复构建。\n1. cargo 不假定工作空间中的 crates 包会相互依赖，所以需要明确表明工作空间中 crate 包的依赖关系。一个包用到了其他包，需要在该包的 Cargo.toml 文件`[dependencies]`域中加入依赖\n1. 工作空间只在根目录有一个 Cargo.lock，而不是在每一个 crate（就当是 packge)目录都有 Cargo.lock。这确保了所有的 crate 都使用完全相同版本的依赖。也节省了空间，避免多个拷贝。\n1. Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。\n\n## 类型系统\n\n1. [类型大小](https://zhuanlan.zhihu.com/p/21820917)\n2. Rust 中有一个重要的 trait Sized，可以用于区分一个类型是不是 DST。所有的 DST 类型都不满足 Sized 约束。我们可以在泛型约束中使用 Sized、!Sized、?Sized 三种写法。\n3. Rust 还支持 0 大小类型（Zero Sized Type）。 () 类型和空结构体类型，都是 0 大小类型。\n\n## Ownership 所有权\n\n1. 区分值(内存)和变量。\n1. 所有权是指： 每一个值都只有一个所有者（变量）, 当变量离开作用于时，值被丢弃。\n1. 当变量离开作用域，Rust 为我们调用一个特殊的函数 drop。在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）。\n1. `move:` `let s1 = String::from(\"hello\"); let s2 = s1;` 这个操作被称为移动（move），而不是浅拷贝。Rust 则认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。\n1. Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。\n1. `clone:` 当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源\n1. `copy:` `let x = 5; let y = x;` x 在栈上，copy 操作。Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。\n1. 如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用。如 String 没有实现 Copy trait, i32 实现了。\n1. Copy and Clone: Copy 是隐性调用，Clone 显性。 Copies happen implicitly, for example as part of an assignment y = x. The behavior of Copy is not overloadable; it is always a simple bit-wise copy. Cloning is an explicit action, x.clone()\n1. [link](https://doc.rust-lang.org/beta/std/marker/trait.Copy.html) Clone is a supertrait of Copy, so everything which is Copy must also implement Clone. If a type is Copy then its Clone implementation only needs to return \\*self\n1. Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。\n1. 任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s 进入作用域\n\n    takes_ownership(s);             // s 的值移动到函数里 ...\n                                    // ... 所以到这里不再有效\n\n    let x = 5;                      // x 进入作用域\n\n    makes_copy(x);                  // x 应该移动函数里，\n                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x\n} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，\n  // 所以不会有特殊操作\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n    println!(\"{}\", some_string);\n} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n    println!(\"{}\", some_integer);\n} // 这里，some_integer 移出作用域。不会有特殊操作\n```\n\n1. 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。\n1. 将获取引用作为函数参数称为 借用（borrowing）。\n1. 可变引用有一个很大的限制：在特定作用域中的特定数据只能有一个可变引用。\n1. 也不能在拥有不可变引用的同时拥有可变引用。\n1. Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。\n1. 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。\n1. `另一个没有所有权的数据类型是 slice(部分引用 &[T])。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合`。\n1. “字符串 slice” 的类型声明写作 &str, 字符串字面值就是 slice\n1. [胖指针](https://zhuanlan.zhihu.com/p/76945648)\n\n## Enums 枚举 and 模式匹配\n\n1. 枚举允许你通过列举可能的 成员（variants） 来定义一个类型\n1. 用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。\n\n```rust\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n```\n\n1. 结构体和枚举还有另一个相似点：就像可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法\n1. `Option` 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。\n1. Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 Option<T>，而且它定义于标准库中，如下:\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\n1. Option<T> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要 Option:: 前缀来直接使用 Some 和 None。即便如此 Option<T> 也仍是常规的枚举，Some(T) 和 None 仍是 Option<T> 的成员。\n1. 只要一个值不是 Option<T> 类型，你就可以安全的认定它的值不为空。\n1. Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n1. 对于 if, 表达式必须返回一个布尔值，而 match 可以是任何类型的。\n1. 一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 Coin::Penny 而之后的 => 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 1。每一个分支之间使用逗号`,`分隔。\n1. 如果想要在分支中运行多行代码，可以使用大括号`{}`。\n1. 匹配 Option<T>:\n\n```rust\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n```\n\n1. Rust 中的匹配是 穷尽的（exhaustive）：必须穷举到最后的可能性来使代码有效。\n1. `_`通配符：\n\n```rust\nlet some_u8_value = 0u8;\nmatch some_u8_value {\n    1 => println!(\"one\"),\n    3 => println!(\"three\"),\n    5 => println!(\"five\"),\n    7 => println!(\"seven\"),\n    _ => (),\n}\n```\n\n1. if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况。\n\n```rust\n\nlet some_u8_value = Some(0u8);\nmatch some_u8_value {\n    Some(3) => println!(\"three\"),\n    _ => (),\n}\n\nif let Some(3) = some_u8_value {\n    println!(\"three\");\n}\n```\n\n1. 使用 if let 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 match 强制要求的穷尽性检查。match 和 if let 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。\n1. 可以在 if let 中包含一个 else。else 块中的代码与 match 表达式中的 \\_ 分支块中的代码相同\n\n```rust\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!(\"State quarter from {:?}!\", state);\n} else {\n    count += 1;\n}\n```\n\n1. 如果你的程序遇到一个使用 match 表达起来过于啰嗦的逻辑，记住 if let 也在你的 Rust 工具箱中。\n\n## 常见集合 collections\n\n1. 不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。\n1. vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。\n1. `let v: Vec<i32> = Vec::new();` 创建空的 vector\n1. 为了方便 Rust 提供了 vec! 宏。这个宏会根据我们提供的值来创建一个新的 Vec。`let v = vec![1, 2, 3];`\n1. 对于新建一个 vector 并向其增加元素，可以使用 push 方法\n\n```rust\nlet mut v = Vec::new();\n\nv.push(5);\nv.push(6);\n```\n\n1. 访问 vector 中一个值的两种方式，索引语法或者 get 方法：\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\n\nlet third: &i32 = &v[2];\nprintln!(\"The third element is {}\", third);\n\nmatch v.get(2) {\n    Some(third) => println!(\"The third element is {}\", third),\n    None => println!(\"There is no third element.\"),\n}\n```\n\n1. 使用 & 和 [] 返回一个引用；或者使用 get 方法以索引作为参数来返回一个 Option<&T>。\n\n## Error Handling 错误处理\n\n1. 当函数返回为 Result 时: `?`运算符放在 Result 之后的含义：如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序继续执行，如果是 Err，Err 中的值将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传递给调用者。\n1. `cargo clippy` 报更多的错误\n1. Rust 将错误组合成两个主要类别，可恢复错误和不可恢复错误。\n1. 可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件。\n1. 不可恢复错误通常是 Bug 的同义词，比如访问超过数组结尾的位置。\n1. 大部分语言并不区分这两类错误，并采用类似异常这样方式统一处理他们。\n1. Rust 没有异常，但是有可恢复错误`Result<T, E>`和不可恢复错误`panic!`\n1. 执行 Rust 的`panic!`宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。\n1. 出现 panic 时，程序默认是`展开(unwinding)`，这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据。另一种选择是`终止(abort)`，这回不清理数据就退出程序。可以在 Cargo.toml 的[profile]部分增加`panic = 'abort'`，可以由展开切换为终止。\n1. 使用`RUST_BACKTRACE`环境变量运行程序会得到一个 backtrace，backtrace 是一个执行到目前位置所有被调用的函数的列表。\n1. Rust 的 backtrace 跟其他语言一样：阅读 backtrace 的`关键`是`从头开始读直到发现你自己编写的代码`，这就是问题的根源。`这一行往上是你的代码所调用的代码，往下则是调用你的代码的代码(栈)`\n1. 为了获取带有详细信息的 backtrace，`必须是debug模式`\n1. Result 枚举的定义。`enum Result<T, E> { Ok(T), Err(E), }`，其中`T`代表返回的`Ok`成员中的`数据类型`，而`E`代表失败是返回`Err`成员中的错误的类型。\n1. Result 常与 match 进行联合使用\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let f = File::open(\"hello.txt\"); // f值是Ok(file)或者是Err(error)\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => {\n            panic!(\"Problem opening the file: {:?}\", error)\n        },\n    };\n}\n```\n\n1. `unwrap`函数作用于 Result，如果 Result 的值是成员 OK，unwrap 会返回 Ok 中的值，如果是成员 Err，unwrap 会为我们调用`panic!`\n1. `expect`与`unwrap`使用方式一样，`expect`用来调用`panic!`的错误信息将会作为参数传递给`expect`，而不像`unwrap`那样使用默认的`panic!`信息。`expect`更容易查找错误信息位置。\n1. 每一个 Result 都需要被处理，否则会出现警告。\n\n## Lifetimes 生命周期\n\n1. [link](https://skyline75489.github.io/post/2017-7-27_rust_mm.html) rust 生命周期包含变量和引用，C++ RAII 主要是变量的生命周期管理，引用除了 smart pointer C++不负责检查引用的对象是否存在\n1. 生命周期的目的是**避免悬垂指针**. 生命周期帮助编译器执行一个简单的规则：引用不应该活得比所指对象长(no reference should outlive its referent)。\n1. 生命周期之所以如此令人困惑，其部分原因在于 Rust 的很多写作中，生命周期这个词被宽泛地用来指代三种不同的东西——`变量真实的生命周期、生命周期约束和生命周期标注`。 [link](https://juejin.cn/post/6862976475860041741)\n1. 只是用来检查生命周期关系，不影响生命周期\n1. Lifetime annotations don’t change how long any of the references live. Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.\n1. One lifetime annotation by itself doesn’t have much meaning,\n1. `longest<'a>(x: &'a str, y: &'a str) ->&'a str` 它的实际含义是 longest 函数保证返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致（x 作用域和 y 作用域重叠的那一部分）。并没有改变传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。\n1. `struct Test<'a> { part: &'a str, }` Test 的实例不能比 part 字段中的引用存在的更久，Test 实例应先离开作用域。（后定义的存在的应更短）\n1. 每一个`引用`都有一个生命周期，我们需要为那些使用了引用的函数或者结构体指定生命周期。\n1. 只有引用才需要指定生命周期。\n1. 函数或方法的参数的生命周期被称为输入生命周期，二返回的生命周期被成为输出生命周期。\n1. 函数或方法生命周期省略规则，需满足下面三条且无冲突\n\n- 每一个输入参数都有自己的生命周期参数\n- 如果只有一个输入周期，那么它将被赋予所有的输出生命周期参数\n- 如果有多个输入生命周期且其中一个是`&self`或者`&mut self`(说明是个对象的方法）；那么所有的输出生命周期参数将被赋予`self`的生命周期。\n\n12. 生命周期省略简记：\n\n- 只有一个输入参数\n- 有多个输入且其中一个是`&self`\n\n13. Rust 中 struct 和其方法未封装到一起，C++相当于将 struct 和方法封装到类中。C 也有 struct 和函数，但不具有 trait 或接口功能。\n14. 方法签名中，`&self` 来替代 `rectangle: &Rectangle`，因为该方法位于`impl Rectangle`上下文中，所以 Rust 知道`self`类型是`Rectangle`\n15. `impl`不以`self`作为参数的函数，被称为关联函数。是函数不是方法。(类似 C++的静态函数）)\n16. `self`是 keyword. 方法中如果想改名字，可以这样传参`self1: &Rectangle`\n17. 方法定义中的生命周期注解应用于关联函数，方法（含有`&self`)可省略。\n18. 静态生命周期： `'static`，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有`'static`生命周期。\n19. 生命周期也是泛型`test<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str where T: Display` 因为生命周期也是泛型，所以`'a`和泛型参数`T`都位于函数名后的同一尖括号列表中。\n20. PhantomData Zero-sized type used to mark things that \"act like\" they own a T. 用在 ffi 封装指针上。\n21. `fn longest<'a>(x: &'a str, y: &'a str) -> &'a str ` 当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。\n\n## Traits\n\n1. trait object 用来实现泛型函数里动他分发\n2. Trait Object，表现为 &dyn Trait (无所有权） 或者 Box<dyn Trait>（有所有权）。\n3. 在 Rust 里，类型的行为是通过 Trait 来赋予的，几乎所有的数据结构都实现了一个到多个 Trait。泛型编程时只有指定 trait bound(限制)才能使用接口。\n4. Rust 可以同时支持“静态分派(static dispatch)”和“动态分派(dynamic dispatch)”\n5. 利用泛型：编译器会根据实际调用参数的类型不同，直接生成不同的函数版本，类似 C++ 的 template 一样。通过泛型函数实现的“多态”，是在编译阶段就已经确定好了调用哪个版本的函数，因此被称为“静态分派”。\n6. Rust 中的“动态分派”靠 Trait Object 来完成。\n7. 指向 trait 的指针就是 Trait Object。如 Box<dyn Bird>.\n8. [Object Safe](https://zhuanlan.zhihu.com/p/23791817): 以下条件下 Trait Object 是无法构造出来：\n   - 当 trait 有 Self:Sized 约束时\n   - 当函数中有 Self 类型作为参数或者返回类型时\n   - 当函数第一个参数不是 self 时\n   - 当函数有泛型参数时\n9. 使用工厂模式时， 如果 trait 返回 Self，例如：fn get(&self) -> Self; `fn get(self: Box<Self>) -> Box<dyn InfoManager>; ` [link](https://users.rust-lang.org/t/boxed-self-in-a-trait-method/1742/2)\n10. Rust 的动态分派，和 C++的动态分派，内存布局有所不同。在 C++里，如果一个类型里面有虚函数，那么每一个这种类型的变量，内部都包含一个指向虚函数表的地址。而在 Rust 里面，对象本身不包含指向虚函数表的指针，这个指针是存在于 trait object 指针里面。`如果一个类型实现了多个 trait，那么不同的 trait object 指向的虚函数表也不一样`。\n11. You can implement traits for types you didn't define, whereas interfaces can only be implemented for your own classes.\n12. `孤儿规则`(orphan rule)，简称 OR：\"当你为某类型实现某 trait 的时候，必须要求类型或者 trait 至少有一个是在当前 crate 中定义的。 你不能为第三方的类型实现第三方的 trait 。\n13. Trait Object 的底层逻辑不过就是胖指针（fat pointer） —— 一个包含两个指针的数据结构。其中，一个指针指向数据本身，另一个则指向虚函数表（vtable）。在这张表里，包含具体类型的一些信息，如 size，aligment 以及一系列函数指针：[link](https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=2649829038&idx=1&sn=b9459537ff93d2aee56b822d09d6a80a&chksm=8704acb2b07325a4a9c46f0bbac3df2db2fadeb2b7928e3949072f01df0d975eaecb36a6e8dd&scene=178&cur_album_id=1701598373151047686#rd)\n\n## Generic Types 泛型\n\n3. [透过 Rust 探索系统的本原：泛型](https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=2649829038&idx=1&sn=b9459537ff93d2aee56b822d09d6a80a&chksm=8704acb2b07325a4a9c46f0bbac3df2db2fadeb2b7928e3949072f01df0d975eaecb36a6e8dd&scene=178&cur_album_id=1701598373151047686#rd)\n4. 泛型编程，与其说是一种技术，不如说是一种思想。它不仅仅是类型参数化，函数泛型化那么简单，背后体现的是程序员的抽象思维能力。抽象思维的能力，和语言无关，和工具无关，它是一种在实践中不断探索，不断学习，不断历练得出的能力。支持泛型的语言并不能帮助你更好地做泛型编程，就好比给我一台斯坦威钢琴，并不意味着我就具备了演奏李斯特《钟》的能力。\n5. 定义数据结构时： 参数化类型（Parameterized Type）\n6. 定义函数时： 泛型函数（Generic Function）\n7. 泛型函数: 静态分派（static dispatch 泛型为具体类型 T）和动态分派（dynamic dispatching 泛型为 trait object）\n8. 编译器在编译时就能捕获到使用的类型，从而进行对应的处理，这被称之为静态分派（static dispatch）。\n9. ![静态分派和动态分派](https://mmbiz.qpic.cn/mmbiz_png/SER9L29WQ0icrEMnzjvMNTzSZbaPboUnMUFBia3wHebkuX9e6Ah70g3CKC9v8bVicGeGJEq0Dd38AnesVU5ffXmdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n## Iterators and Closures 迭代器与闭包\n\n1. 函数式编程：包含将函数作为参数值或其他函数的返回值，将函数赋值给变量以供之后执行等等。\n1. 闭包：一个可以储存在变量里的类似函数的结构\n1. 迭代器：一种处理元素序列的方式。\n1. Rust 的闭包是可以保存进变量或作为参数传递给其他函数的匿名函数（可以捕获环境的匿名函数）。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。\n1. 不同于函数，闭包允许捕获调用者作用域的值。\n1. 在程序的一个位置指定某些代码，并只在程序的某处实际需要结果的时候执行这些代码。这正式闭包的用武之地。\n1. 闭包通常很短，并只关联于小范围的上下文而非任意情境。在有限的上下文中，编译器能可靠的推断参数和返回值的类型。\n1. 闭包语法：`let test = |num1, num2| { println(\"num1: {}\",num1); num2 + 1 };` `|num1, num2|`是参数，`num2+1`是返回值。`let`表明`tet`是一个匿名函数的定义。不是调用匿名函数的返回值。`test`存储的是代码。\n1. 带类型注解的闭包 `let test = |num1: u32, num2: u32| -> u32 { println(\"num1: {}\",num1); num2 + 1 };`\n1. 如果闭包体只有一行则大括号可以省略。例如： `let add_one = |x| x+1;`\n1. 如果调用多次闭包，编译器会根据第一次使用时的参数类型，如果对同一闭包使用不同类型会得到类型错误。\n1. ...\n1.\n1.\n1. 迭代器负责遍历序列中的灭一项和决定序列何时结束的逻辑。\n1. 迭代器是惰性的，在调用方法使用之前它都不会有效果。\n1. 迭代器的实现方式提供了对多种不同的序列使用相同逻辑的灵活性，减少了重复代码并消除了潜在的混乱。\n1. 迭代器都实现了定义于标准库的 trait `Iterator`。包含`next`方法。\n1. 迭代器的`sum`方法返回迭代的次数，会消费适配器。迭代器调用`sum`方法后不再允许使用迭代器，因为`sum`会获取迭代器所有权。\n1. 迭代器的方法：`迭代器适配器(iterator adaptors)` 允许将迭代器变为不同类型的迭代器。\n1. `v1.iter().map(|x| x+1);`迭代器适配器方法`map`使用闭包来调用每个元素以生成新的迭代器。这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。因为迭代器适配器是惰性的，这里需要消费迭代器。\n1. `collect`方法会消费迭代器并将结果收集到一个数据结构中。\n1. 下面例子会调用`map`方法创建一个新的迭代器，接着调用`collect`方法消费新迭代器并创建一个 vector。\n\n```rust\nlet v1: Vec<i32> = vec![1, 2, 3];\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\nassert_eq!(v2, vec![2, 3, 4]);\n```\n\n## Smart Pointers 智能指针\n\n1. 指针是一个包含内存地址的变量的通用概念，这个地址指向一些其他数据。\n1. Rust 最常见的指针是引用，他们没有任何额外的开销，所以应用的最多。\n1. `智能指针(smart pointers)`是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。\n1. `引用计数(reference counting)` 是智能指针类型，其允许数据有多个所有者。引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。\n1. 在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有他们指向的数据。\n1. 智能指针通常使用结构体实现。\n1. 智能指针区别于常规结构体的显著特性在于其实现了`Deref`和`Drop`trait。\n1. `Deref` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用，又用于智能指针的代码。\n1. `Drop` trait 允许我们自定义当智能指针离开作用域时运行的代码。\n1. 很多库都拥有自己的智能指针而你也可以编写属于你的智能指针。\n1. `Box<T>`用于在堆上分配值。\n1. `Rc<T>`一个引用计数类型，其数据可以有多个所有者。\n1. `Ref<T>`和`RefMut<T>`通过`RefCell<T>`访问。\n1. 最简单直接的智能指针是`box`，其类型是`Box<T>`，box 允许你将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针。\n1. 除了数据被存储在堆上而不是栈上之外，box 没有性能损失，不过也没有很多额外的功能。多用于\n   - 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候。（box 作为链表的指针实现链表）\n   - 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候。\n   - 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是具体类型的时候\n1. `Box<T>`类型是一个只能智能指针，因为它实现了`Deref`trait，它允许`Box<T>`的值被当做引用对待。\n1. 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。\n1. & 符号就是 引用，允许你使用值但不获取其所有权。\n1. 我们将获取引用作为函数参数称为 借用（borrowing）。\n\n## AsRef and Deref\n\n1. Deref is different from the other two: one type can only be derefed to one target type, and \\*d always has the same type.\n2. Borrow and AsRef both give a reference to the underlying data, but Borrow requires that the original type and the borrowed type have the same behavior, while AsRef does not have the same requirement.\n3. 当我们在示例中输入 _y 时，Rust 事实上在底层运行了如下代码：`_(y.deref()) ` Rust 将 \\* 运算符替换为先调用 deref 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 deref 方法了。Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 Deref 的类型。\n4. 解引用强制多态（deref coercions）是 Rust 在函数或方法传参上的一种便利。其将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，解引用强制多态将自动发生。这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。\n5. 解引用强制多态的加入使得 Rust 程序员编写`函数和方法`调用时无需增加过多显式使用 & 和 \\* 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。\n6. [deref](https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/deref.html)\n\n## Concurrency 并发\n\n## Asynchronous Programming\n\n1. async function 是一种 promise(sender). promise 调用 await 时，执行并返回 future(reciever).\n\n## 异步编程\n\n1. 主要作用： makes it possible for a thread to continue doing useful work while it waits for the value to become available. 例如：IO DMA\n1. [深入浅出 Tokio](https://zhuanlan.zhihu.com/p/107820568)\n1. [同步异步，阻塞非阻塞区别](https://www.cnblogs.com/mhq-martin/p/9035640.html)\n1. 同步异步区别是在调用一个功能时，没得到`结果`之前，是否继续后续操作\n1. 阻塞非阻塞区别是`线程/程序`在等待调用结果时，是否一直等待（挂起当前线程）\n1. 阻塞和非阻塞关注的是程序在`等待调用结果`（消息，返回值）时的`状态`.\n1. 进程线程锁是用来同步的，lock()函数是阻塞式，不拿到锁不返回，线程被阻塞。try_lock()是非阻塞式的，如果拿不到锁也返回。\n1. 异步是目的，而多线程是实现这个目的的方法\n1. Async/Await is a paradigm that is orthogonal to threading, which means that it has the potential to run tasks on a single thread OR on multiple threads depending on the executor that is used.\n1. async/await 与多线程 [link](https://qvault.io/rust/concurrency-in-rust-can-it-stack-up-against-gos-goroutines/)\n\n```\nuse async_std::task;\nuse futures::executor::block_on;\nuse std::time::Duration;\n\nfn main() {\n    let future = async_main();\n    block_on(future); // 执行器单线程执行，总共需要15秒，多线程可能就快很多\n}\n\nasync fn async_main() {\n    print_for_five(\"await\").await; // await: function 阻塞\n\n    let async_one = print_for_five(\"async 1\");\n    let async_two = print_for_five(\"async 2\");\n\n    futures::join!(async_one, async_two);\n}\n\nasync fn print_for_five(msg: &str) {\n    for _ in 0..5 {\n        // task::sleep(Duration::from_secs(1)).await; //async 1, 2 循环执行，task await会异步阻塞\n        std::thread::sleep(std::time::Duration::from_secs(1)); //执行器单线程时顺序执行，因为不会阻塞\n        println!(\"one second has passed: {}\", msg)\n    }\n}\n\n```\n\n## Object Oriented 面向对象\n\n## Macros 宏\n\n1. 从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）\n2. 元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数扮演的角色。但宏有一些函数所没有的附加能力。\n3. derive 属性，其生成各种 trait 的实现\n4. 一个函数标签必须声明函数参数个数和类型。相比之下，宏能够接受不同数量的参数：用一个参数调用 println!(\"hello\") 或用两个参数调用 println!(\"hello {}\", name) 。\n5. 宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现。\n6. 实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。\n7. hello_macro(不是宏) 中定义的 trait(可包含多个接口）， hello_macro_derive 中实现的过程式宏。在一个类型上指定 #[derive(HelloMacro)] 时，hello_macro_derive 函数将会被调用。\n\n## Program with C/C++\n\n1. [Rustonomicon](https://doc.rust-lang.org/nomicon/index.html)\n1. [rust bindgen](https://github.com/rust-lang/rust-bindgen)\n1. [rust with C](https://doc.rust-lang.org/stable/embedded-book/interoperability/index.html)\n\n## 日志\n\n1. [env_logger](https://docs.rs/env_logger/0.8.3/env_logger/)\n2. actix_web 使用了 env_logger [actix_web::middleware::Logger](https://github.com/actix/actix-web/blob/master/src/middleware/logger.rs#L51)\n","tags":["Rust"],"categories":["Program","Rust"]},{"title":"Tools and Linux Command","url":"/2021/06/29/Bash-usage/","content":"\n## Useful Tools (can install from github release)\n\n### windows\n\n1. 滴答清单 windows + phone\n1. sticky 便利贴 `win+alt+t` always on top\n1. [files 文件管理器](https://files.community/)\n1. [PowerToys](https://github.com/microsoft/PowerToys)\n   - color pick: win + shift + c\n   - 鼠标荧光笔\n1. 罗技 master3 鼠标， 大拇指 + 左右， workspace 切换\n1. [PowerToys/run 快速启动](https://docs.microsoft.com/zh-cn/windows/powertoys/run)\n   - alt + space\n   - search startup 开机启动\n1. [windows terminal](https://github.com/microsoft/terminal)\n   - win + ` 上半部分显示\n1. [windows quicklook 预览](https://github.com/QL-Win/QuickLook)\n1. [quicklook plugins](https://github.com/QL-Win/QuickLook/wiki/Available-Plugins)\n1. [CopyQ 粘贴板](https://github.com/hluk/CopyQ)\n   - F6\n   - win + v(系统自带)\n1. [snipaste 截图](https://zh.snipaste.com/index.html)\n1. [ShareX](https://github.com/ShareX/ShareX)\n   - tools OCR 图片文字识别\n1. [flameshot 截图工具](https://github.com/flameshot-org/flameshot)\n1. [screentogif](https://www.screentogif.com/)\n1. [zoomit 投影演示 倒计时](https://docs.microsoft.com/en-us/sysinternals/downloads/zoomit)\n1. [WSL2](https://docs.microsoft.com/zh-cn/windows/wsl/install)\n1. [Dadroit JSON Viewer](https://dadroit.com/)\n\n<!-- more -->\n\n#### [shortcuts](https://support.microsoft.com/en-us/windows/keyboard-shortcuts-in-windows-dcc61a57-8ff0-cffe-9796-cb9706c75eec)\n\n1. `win + f` 全屏\n1. `win + v`历史复制\n1. `win + 1` 设置为打开 vscode\n\n### linux\n\n1. [sshx web 连接，可分享](https://github.com/ekzhang/sshx)\n1. [inshellisense](https://github.com/microsoft/inshellisense)\n1. [screenshot-to-code](https://github.com/abi/screenshot-to-code)\n1. [autocomplete](https://github.com/withfig/autocomplete)\n1. [cfonts](https://github.com/dominikwilkowski/cfonts)\n1. [neofetch](https://github.com/dylanaraps/neofetch) and [asciiart](https://www.asciiart.eu/vehicles/cars)\n1. [tmux](https://github.com/tmux/tmux/wiki)\n1. [z.lua(zh, zb)](https://github.com/skywind3000/z.lua)\n1. [zoxide](https://github.com/ajeetdsouza/zoxide)\n1. [fzf(C-r, M-c, kill -9 <tab>)](https://github.com/junegunn/fzf)\n1. [rg](https://github.com/BurntSushi/ripgrep)\n1. [fd](https://github.com/sharkdp/fd)\n1. [bat](https://github.com/sharkdp/bat)\n1. [shfmt](https://github.com/mvdan/sh)\n1. [gping](https://github.com/orf/gping)\n1. [commitizen](https://github.com/commitizen/cz-cli)\n1. [zsh](https://github.com/ohmyzsh)(.zsh_history 保存常用命令)\n1. [exa](https://github.com/ogham/exa)\n1. [hexyl](https://github.com/sharkdp/hexyl)\n1. [tldr](https://github.com/tldr-pages/tldr)\n1. [vimium](https://github.com/philc/vimium)\n1. [htop](https://htop.dev/)\n1. [doxygen](https://docxgen.readthedocs.io/en/latest/)\n1. [samba](https://www.samba.org/)\n1. [hexo](https://hexo.io/zh-cn/)\n1. [docusaurus](https://github.com/facebook/docusaurus)\n1. [mkdocs](https://github.com/mkdocs/mkdocs/)\n1. [sphinx-doc](https://github.com/sphinx-doc/sphinx)\n1. [snap 通用的 linux 软件包](https://cn.ubuntu.com/blog/what-is-snap-application)\n1. [snap store](https://snapcraft.io/store)\n1. [7yuv linux](https://vball.fun/2021/11/23/build-7yuv-snap-package/)\n1. [imgcat](https://github.com/eddieantonio/imgcat)\n1. [watchman](https://github.com/facebook/watchman)\n1. [日志查看 lnav](https://github.com/tstack/lnav)\n1. [日志分析 miller](https://github.com/johnkerl/miller)\n1. [termius](https://termius.com/)\n\n### 文件传输\n\n1. mount or pipe + rsync\n1. scp 适用于文件较少\n1. rsync 适用于大量文件，增量传输\n   - rsync 同步数据， 可以启服务备份数据 `rsync -avzr --progress test --exclude=test/5 10.10.0.98:/home/jiaxiyang/` 多用 rsync，少用 scp\n   - `sshpass -p \"\" rsync -avz -e \"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\" test root@10....` sshpass + rsync\n1. pipe 适用于大量文件，第一次传输\n   - `tar cf - read_shape | ssh root@10.31.1.153 \"tar xf - -C ~/xiyang/\"`通过管道传输，免去了单独操作麻烦, 用管道来压缩和解压，降低了磁盘 IO(两次), 直接内存里操作\n\n### tmux\n\n1. c-m 或 enter： 换行\n1. `tmux send-keys -t .3 \"ls -al\" c-m` 向当前 windows pannel 3 发送 ls 命令\n1. `tmux list-panes | wc -l` 当前 panel 个数\n1. 创建固定个数 panel，每个 panel 执行不同命令\n\n```sh\n#!/bin/bash\n\nPANEL_NUM=6\nwhile [ $(tmux list-panes | wc -l) -lt ${PANEL_NUM} ]; do\n\ttmux split-window \\; #select-pane -L\n    tmux select-layout tiled\ndone\n\n# even-horizontal even-vertical main-horizontal main-vertical tiled\n# tmux select-layout even-horizontal\ntmux select-layout tiled\n\nCURRENT_PANEL=$(tmux display -pt \"${TMUX_PANE:?}\" '#{pane_index}')\nfor i in $(seq 1 ${PANEL_NUM}); do\n\techo ${i}\n\tif [ ${i} -ne ${CURRENT_PANEL} ]; then\n\t\ttmux send-keys -t .${i} \"echo ${i}; ls -al\" c-m\n\tfi\ndone\n\n```\n\n## 查看系统系统\n\n1. `top` and `htop`\n1. `sudo iotop`\n1. `iftop`\n1. `iostat -x 1 10` 查看 io 情况\n1. `sudo watch pidstat -d` 看哪个进程占用 IO 多。\n1. `who`, `w`, `last` and `lastlog` 查看最后用户登录\n\n## [文件权限](https://www.runoob.com/linux/linux-file-attr-permission.html)\n\n1. never use 777\n1. u,g,o,a 分别代表 属主，数组，其他用户，所有用户\n1. +,-,= 分别代表 增加，减去，设置一个权限\n1. `chmod o+w` 给其他用户添加写权限\n1. `o+w`会高亮文件夹\n1. mount 问题解决`chmod o+w -R .` `find . -type f | xargs chmod o+w` `chmod o+w $(find . -type f)` 给其他用户加写权限， 不会有 git 历史，umask 022\n1. `o-r` 不让其他用户看\n\n## Add User and Group\n\n```sh\n# 查看用户和组id\n% id -u && id -g\n\n# 添加组\n% sudo groupadd xiyang -g 1022\n\n# 添加用户到组，zsh作为默认shell\n% sudo useradd -g xiyang -ms /bin/zsh xiyang -u 2022\n\n# 删除用户密码\n% passwd -d xiyang\n\n# 查看当前用户group，注意添加之后重新开terminal才生效\n% groups\n\n# 添加到sudo group\n% sudo  usermod -aG sudo xiyang\n\n# xiyang作为main group\n% sudo usermod -g xiyang xiyang\n\n# 改变用户id\n% sudo usermod -u 1022 xiyang\n\n# 改变组id\n% sudo groupmod -g 1022 xiyang\n\n# 删除用户 -r 删除目录\n% userdel -r xxx\n\n# 查看所有用户uid\n% cat /etc/passwd\n\n# sample\n% sshpass -p nvidia ssh nvidia@10.31.1.187\n% sudo groupadd xiyang -g 1022\n% sudo useradd -g xiyang sudo  -ms /bin/bash xiyang -u 1022\n% sudo passwd -d xiyang\n% sudo su - xiyang\n% passwd\n```\n\n## awk\n\n1. 列出.so 或.a 库 `ls | awk '/.so$|.a$/{print $0}'`\n1. 分割字符串 注意从$1 开始，$0 表示输入 `echo test.so | awk -F '.' '{print $1}'`\n1. 获取 so 库的名字 `echo libtest.so | awk -F '.' '{print substr($1,4)}'`\n1. 获取库名字 `ls | awk '/.so$|.a$/{print $0}' | awk -F . '{print substr($1, 4)}'`\n1. 获取第一个匹配行 `cat file | grep -n \"#i[fn]\\|#pragma\" | awk -F ':' '{print $1}' | awk 'NR==1'`\n1. `(ldd ${BINS} | grep \"=> /\" | awk '{print $3}' | xargs -I '{}' cp -v '{}' ${OUTPUT_DIR}/lib` copy all link libs\n1. 查看库链接关系 `for i in $(ldd test | grep \"=> /\" | awk '{print $3}'); do echo \"***************$i **************\"; ldd $i | grep flowsdk; done`\n1. 查看加载用到的库 `readelf -d build/dog/dog_test1 | grep 'NEEDED'`\n\n## [sed](https://www.gnu.org/software/sed/manual/html_node/Command_002dLine-Options.html#Command_002dLine-Options)\n\n1. 双引号才能使用变量\n1. 删除匹配： `sed -i \"/fancyfoot/d\" latex/refman.tex`\n1. 在匹配后加入一行 `sed -i '/{fancyplain}/a\\\\\\rhead{}' latex/refman.tex`\n1. 在匹配前加一行 `sed -i '/doxysection/i\\\\\\newpage' latex/refman.tex`\n1. 删除 1 到 n 行： `sed -i \"1, ${n}d\" file`\n1. 匹配字符所在行替换：`sed -i '/config/c\\This line is relace.' test.json`\n\n## curl\n\n1. `curl -fsSL https://mirrors.xxx.xx/xx.sh | bash -ex` 一键运行\n1. curl -L http:xxx 不加 -L 会自动转换为 https\n1. -s, --silent Silent mode\n1. -S, --show-error Show error even when -s is used\n1. -f, --fail Fail silently (no output at all) on HTTP errorsc 出错退出\n1. -O, --remote-name Write output to a file named as the remote file 保存为文件名\n1. -o, --output <file> Write to file instead of stdout\n\n## Useful Commond\n\n1. `timeout 3s xxxx` 超时退出; 可用于无法停止程序测试；不用 ctrl-c\n1. `alias mc='cmd(){ date;pwd;who|wc -l;};cmd'` alias 执行多条命令\n1. `pidof firefox | xargs kill -9 ` or `kill $(pidof firefox)` kill process by name\n1. `nl file` 显示行号\n1. `ftp`: 搭建 ftp 服务器，脚本 put:`scp -r $@ user@IP:path`上传文件，脚本 get:`for i in $@; do scp -r user@IP:path/${i}; done`获取文件。get-ls:`ssh xiyang@xsjsda153 \"cd /var/ftp/pub/xiyang/ && ls $@\"`, get-list-all:`ssh user@IP \"cd path && ls -alhrt\"`, get-list:`ssh user@IP \"cd path && ls -lhrt | tail -n 10\"`获取 ftp 服务器列表。ftp 服务器上可以放常用文件，各服务器方便取。也可用于服务器(包括 windows)间数据交换。\n\n## Miscellaneous\n\n1. `dpkg-query -l`查看安装库版本\n1. `nice -n 10 ./test` 调整程序优先级(不设置默认是 0), nice 值越高，优先级越低。top 或 ps -l 可查看优先级（NI: nice）Niceness values range from -20 (the highest priority) to 19 (the lowest).\n1. `renice -n 10 -p <pid>` 重新设置 nice 值\n1. `hostname -I` 查看 IP 地址\n1. htop 显示 io,需要新版本； 配置文件`~/.config/htop/htoprc` [link](https://superuser.com/a/1730191) [changelog](https://github.com/htop-dev/htop/blob/main/ChangeLog)\n\n```sh\nwget -c https://github.com/htop-dev/htop/releases/download/3.2.2/htop-3.2.2.tar.xz && tar xf htop-3.2.2.tar.xz && cd htop-3.2.2\n./autogen.sh && ./configure && make -j4\n```\n\n1. htop `S -> Meters添加修改监控内容` 可添加 CPU average， disk io 等，也可修改布局和 style， 都该成 bar；\n1. htop `S -> Display Option` Also show CPU frequency 显示 cpu 频率\n1. htop `S -> Screens`可以添加 IO_RATE, IO_READ_RATE, IO_WRITE_RATE, CWD\n1. `gdb attach <pid> =>  info proc all` 查看进程是否设置了 coredump\n1. `gcore $(pidof processname)` 命令行直接执行产生 coredump `-a`产生更详细信息\n1. json config tree `main_file=test.json; parse_json() { local file=\"$1\" indent=\"$2\"; if [[ ! -f \"$file\" ]]; then echo \"${indent}$file (not found)\"; return; fi; local json_refs=$(grep -oE '\"[^\"]+\\.json\"' \"$file\" || echo \"\"); local count=0; local total=$(echo \"$json_refs\" | grep -c .); for ref in $json_refs; do count=$((count + 1)); local ref_file=$(echo $ref | tr -d '\"'); if [[ $count -eq $total ]]; then echo -n \"${indent}└── \"; local new_indent=\"${indent}    \"; else echo -n \"${indent}├── \"; new_indent=\"${indent}│   \"; fi; if [[ -f \"$ref_file\" ]]; then echo \"$ref_file\"; parse_json \"$ref_file\" \"$new_indent\"; else echo \"$ref_file (not found)\"; fi; done; }; echo; echo \"$main_file\"; parse_json \"$main_file\" \"\"; echo`\n1. `./pg_perf_monitor_threads.sh 535  | sed 's/\\x1b\\[[0-9;]*m//g' | tee output.txt` 去除彩色\n1. `stdbuf -oL command | sed 's/\\x1b\\[[0-9;]*m//g' > output.txt` 修改缓存行为，以行为单位写入到文件\n1. `ls /proc/[PID]/task/` or `ps -T -p [PID]`获取进程线程号\n1. `echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid` sudo echo 写文件\n1. `pidof test`根据 name 查看 pid\n1. `du -sh * | sort -h` 按大小排序 sort -h enables human-readable sort, so it understands sizes like K, M, and G.\n1. `update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1` 修改默认程序版本\n1. `cat test* > test.bin` 合并文件\n1. `split -d -n 3 -a 1 total_dummy_input@0.bin00 total_dummy_input@0_ && ls total_dummy_input@0_* | xargs -I {} mv {} {}.bin` 统一重命名\n1. `split -d -n 5 xxx xxxx` slipt 文件\n1. `split -b 262144 total_flow_predictions.bin total_flow_predictions_split.bin` slipt 文件为两部分，第一部分 262144bytes\n1. `grep -v grep` -v 显示不包含的行， 显示不包含 grep 的行\n1. `tar -C build -zcf install.tgz output` 打包 build/output, 不保留 build 文件夹\n1. `pwdx` - report current working directory of a process 查看进程工作路径, 有用，可用来看机器被谁占用, `ll /proc/<pid>/` 查看 cwd\n1. `for pid in $(ps -e -o pid=); do cmd=$(ps -p $pid -o args=); dir=$(sudo pwdx $pid 2>/dev/null | grep -v \": /$\" | cut -d ' ' -f2-); if [[ ! -z $dir ]]; then echo -e \"\\033[31m$pid: $dir\\033[0m\\n        ------  \\033[34m$cmd\\033[0m\"; fi; done` 显示所有进程 pwd 及命令\n1. `pid=PID; cmd=$(ps -p $pid -o args=); dir=$(sudo pwdx $pid 2>/dev/null | grep -v \": /$\" | cut -d ' ' -f2-); if [[ ! -z $dir ]]; then echo -e \"\\033[31m$pid: $dir\\033[0m\\n        ------  \\033[34m$cmd\\033[0m\"; fi;` 查看单个 pid 信息\n1. `for pid in $(ps -e -o pid=); do sudo pwdx $pid; done | grep -v \": /$\"` 查看所有进程路径\n1. `for pid in $(ps | awk '{print $1}'); do /userdata/pwdx $pid; done | grep -v \": /$\"`j5 查看所有进程路径\n1. `ps -eo pid,%mem,cmd --sort=-%mem | awk 'NR>1 {print $1, $2\"%\", $3; s+=$2} END {print \"Total:\", s \"%\"}'` 查看所有进程占用内存百分比及其和\n1. `cat -n test.cpp` or `less -N test.cpp` 打印带行数\n1. `readelf -a $(which find)` 命令里可以调用其他命令\n1. `lsblk` List information about block devices.查看有哪些磁盘可挂载\n1. 解决 ssh 经常断开问题 [link](https://blog.csdn.net/qq_15505637/article/details/80881770)\n   - `sudo /etc/init.d/ssh restart`\n1. `stat`: 获取文件各种信息\n1. `fd -e py -e h -e hpp -e cpp -e cc -e png -e jpg -e txt -e md -e cmake -e json | xargs chmod 644` 统一改变文件权限\n1. `fd --type f '.*\\.(c|cpp|h|hpp|hxx|cxx)' . -x clang-tidy {}`\n1. `/etc/profile` sh shell ssh 执行配置\n1. `echo $SHELL` 查看系统用的 shell\n1. `file`查看编码格式\n1. `nohup` no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。\n1. `less` is more\n1. nv12 to jpg: `ffmpeg -s 1920x1080 -pix_fmt yuv420p -i nv12_1080p.yuv test-1920-1080.jpg`\n1. png to nv12: `ffmpeg -i input.png -pix_fmt nv12 1920x1080.yuv`\n1. `(ldd ${BINS} | grep \"=> /\" | awk '{print $3}' | xargs -I '{}' cp -v '{}' ${OUTPUT_DIR}/lib` copy all link libs\n1. `wget -rcN -np -nH -q --cut-dirs=100 -R \"index.html*\" https://mirrors.phigent.io/xxx/xx -P output_dir` wget 下载文件夹， `--cut-dirs=n` 从/开始往后忽略几级文件夹， `-q` quite\n1. `wget -r -nH --cut-dirs=100 --reject \"index.html*\" --no-parent https://mirrors.phigent.io/xxx/xx -P output_dir`\n1. `ls -Al --si --time-style long-iso` `-A`:不显示.和.., `--si` human readable `--time-style long-iso`时间显示为 2022-06-10\n1. `truncate --size 1M file_name` 创建大小为 1M 的文件 file_name\n1. `dd if=/dev/urandom of=random_input.bin bs=983040 count=1` 创建大小为 bs 的随机文件\n1. [imagemagick](https://guides.wp-bullet.com/batch-resize-images-using-linux-command-line-and-imagemagick/): 命令行 resize 图片\n1. `watch cat /proc/sys/fs/file-nr` get the current number of open files\n1. `pidof firefox | xargs kill -9 ` or `kill $(pidof firefox)` kill process by name\n1. `pkg-config --cflags --libs gstreamer-1.0`\n1. `export PKG_CONFIG_PATH=${PIXI_PATH}/env/share/pkgconfig:${PIXI_PATH}/env/lib/pkgconfig:${PKG_CONFIG_PATH}`设置 pkgconfig 查找路径\n1. `pkg-config --modversion poppler-data` 查看库版本 , pkg-confg 配置文件在/usr/share/pkgconfig 下(pkg-config 一般为开发者使用，文件系统中勾选-dev)\n1. `ldconfig -p `查看系统安装的库\n1. `ldconfig -p | grep pcap` 查看系统是否安装 pcap\n1. 打洞： A1, A2, A3..., B, C; A 能连接 B, B 能连接 C, A 不能连接 C。C 上配置`~/.ssh/config`:\n\n```\nconfig\n```\n\nB 上执行`ssh `登录到 C，再打开一个 C 连接，就能和 A 之间使用 scpc 传数据。如果 A 连网，C 如果想连网，B 执行完 ssh 命令后，登录到 C 上，再执行`ssh `后登录到 A 上，再打开一个 C 连接，就能上网了。\n\n1. ssh -L 8000:10.31.1.177:80 xiyang@10.31.1.225\n1. [link](https://github.com/damaainan/ceshisina/blob/master/Linux/blog/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/06linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%85%AD%EF%BC%9A%E7%BD%91%E7%BB%9C.md#L454)\n\n   - 假设 A 为 windows 机器，打开 mobarxterm 本地执行 ssh -L 2222:C_IP:22 xiyang.jia@B_IP 登录 B, 将所有发送 2222 端口的数据通过中间主机`B`转发至目标主机`C`的`22`端口，\n   - A 再开一个窗口，执行 ssh -p 2222 root@localhost，A 直接连接 C\n\n1. sed -i \"s/查找字段/替换字段/g\" `grep 查找字段 -rl 路径`\n1. `cat url-list.txt | xargs wget -c`xargs 将参数列表转换成小块分段传递给其他命令\n1. `fd pdf | xargs -n1 -I {} cp {} pdf/` cp 所有 pdf 到 pdf/文件夹\n1. ssh scp 免密登录`ssh-keygen -t rsa && ssh-copy-id -i ~/.ssh/id_rsa.pub root@10.10.129.25` 或将一台机器的 id_rsa.pub 复制到另一台机器~/.ssh/authorized_keys 文件中\n1. `tree -L 2` 查看二级目录结构\n1. `lsb_release -a` 查看操作系统版本，是 Ubuntu 还是 CentOS，是 14.04 还是 16.04\n1. [link](https://blog.csdn.net/u011630575/article/details/52151995)\n   `./test.sh 2>&1 | tee test.log` log 同时输出到前台和文件中 可以不带 2>&1(将标准错误输出到标准输出)\n   `./test.sh &>test.log` 将标准输出, 标准错误重定位到 test.log, &>file 意思是把标准输出 和 标准错误输出 都重定向到文件 file 中, 在 Bash 中，&>与 2>&1 的含义相同。\n   `./test.sh 2>test.log 1>&2` 将标准输出重定位到标准错误， 标准错误重定位到 test.log\n   `./test.sh >test.log 2>&1` 将标注错误重定位到标准输出，标准输出重定位到 test.log\n   ` ls a.txt b.txt 1>file.out 2>file.err` \"1>\" 通常可以省略成 \">\"\n1. IP 地址别名，如服务器别名 `/etc/hosts 10.10.0.61 dg16`\n1. `ssh -v root@10.10.129.25` 通过[-v]参数，查看 ssh 连接的具体过程\n1. `echo123456 | sudo -S ./winless.sh` 以 root 权限来执行文件 这里 123456 是密码，参数-S 专门为执行 sudo 命令的时候要输入密码而准备的，表示标准输入。\n1. ssh 打洞，中间机器运行 `ssh -R10115:${IP1}:22 ${IP2}`\n   然后运行 `rsync -avz --progress -e 'ssh -p 10115' ${FILES} localhost:${PATH}`\n1. w 查看登录的用户 who 向登录用户发消息 `echo jia > /dev/pts/20 ` `for i in $(who | awk '{print $2}'); do echo \"${i}\" > /dev/${i}; done`\n1. `nslookup www.baidu.com` 域名查询命令\n1. split 将一个大文件分割成多个小文件\n1. `chmod 777 -R work_space` 改变目录下所有文件权限\n1. `time program` 测试程序运行时间\n1. `ssh -XY jiaxiyang@10.10.0.61` 需要的时候显示图形界面\n1. `arp -na` 查看网络中连接情况\n1. `find . -name '*' -exec touch {} \\;` 修改当前目录及子目录中所有文件的时间\n1. `chattr` 修改文件（夹）属性 不能被删除\n1. `figlet \"jia\" -f scrpt(ls /usr/share/figlet)` 改变输出字体大小\n1. `ln -s source target` 创建软连接\n1. ln 非常有用，可以使用 ln 来重新命名文件，可以提供一层虚拟层，文件名字路径改变只需重新链接一下，上层代码不用改变。例如 xilinx 所有硬盘都连接到 /proj/rdi/staff/xiyang 方便操作\n1. `watch -d -n 1 ./Re reg` 每隔 1 秒查看程序变化\n1. `axel -n 15（线程数）URL` 多线程下载\n1. `apt-cache search trash` 搜索安装包\n1. `sudo dpkg --install atom-amd64.deb` dpkg 安装.deb 软件包\n1. `export PATH=\"/home/zxy/Desktop:$PATH\"` 添加环境变量\n1. `linuxlogo` 命令行显示 linux logo\n1. `sudo mount -t tmpfs -o size=8G tmpfs ramdisk/` 创建内存文件系统， 可以加快程序运行时间。\n1. `hostname` 查看主机名\n1. `tar -zxvf aa.tar.gz BOOT.BIN` 单独解压 某个文件 `tar -tf` 压缩包名称，可以查看压缩包内容 https://www.cnblogs.com/manong--/p/8012324.html\n1. `speedtest-cli` 测下载上传网速\n1. `curl -O -u jiaxiyang:jiaxiyang -s[-#]`\n1. `wget -c url` 支持断点续传 好用，可以用来下载大文件，比如： petalinux cache 30G\n1. `crontab -e` 定时执行脚本 cat /var/mail/jiaxiyang 查看结果\n1. `syncthing` 文件同步神器\n1. `realpath` 查看文件全路径\n1. `shotwell` \\*.jpg 打开图片\n1. `vimdiff dp` 快速移动不同\n1. `stat - display file or file system status`\n1. `stat -c %s file` 查看文件长度\n1. `stat -c %z file` 查看文件修改时间\n1. `rm file || true` 如果不存在执行 true，还是会报错，但$?返回为 0 使用，使用 bash -ex 时不会退出。\n1. `cat file | grep -v '^#'` 输出不以#号开头的行\n1. `SCRIPT_PATH=$(dirname $(realpath xx.sh)) ` 比 pwd 要好，pwd 显示的是虚拟链接地址。\n1. `PROJECT_NAME=$(basename $(SCPRIT_PATH))` 当前脚本所在的工程名字\n1. sshpass 如果没带 nocheck 需要 ssh 先登录一次, 或者 StrictHOstkeyChecking=no\n1. `sshpass -p root（密码） ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@10.10.129.22 '/etc/init.d/led start'` 跨机器执行命令 在机器 A 上调用，在机器 B 上执行，将结果输出到 A 上。\n1. `sshpass -p root（密码） ssh(scp) -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@10.10.129.22 ssh -y -y root@zu9-2 \" ' cd /home && ls'\" `zu9 上执行 cd /home && ls 注意 要同时加双引号和单引号。`sshpass -p jiaxiyang scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null static_ip.txt jiaxiyang@10.10.0.96:~`\n1. `scp -o ProxyJump=nvidia@10.31.1.12 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r dir_test  root@10.31.1.180:/userdata/mount/xiyang/`跨机器传文件\n1. `ssh -o ProxyJump=nvidia@10.31.1.12 root@10.31.1.180 'ls /userdata'` 跨机器执行， host -> 12 ->180 执行\n1. `tar -cf - zu9_test | sshpass -p root ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@10.10.129.133 \"tar -xvf - -C /var\"` 跨机器 cp 文件并免密\n1. `rm -rf /etc/localtime && ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime` 设置北京时区\n1. 多网卡不能同时配置一个网关?\n\n## Links and Reference\n\n1. [The art of command line](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md)\n1. [Awesome shell](https://github.com/alebcay/awesome-shell)\n1. [Awesome bash](https://github.com/awesome-lists/awesome-bash)\n1. [Bash cheatsheet](https://github.com/zhouyiqi91/awesome-cheatsheets/blob/master/languages/bash.sh)\n","tags":["Bash"],"categories":["Tools","Bash"]},{"title":"Elisp","url":"/2021/06/27/Elisp/","content":"\n## Useful Command\n\n1. C-u before command to insert the result into the current buffer.\n2. crux-eval-and-replace 将表达式替换为结果， 例如(+ 1 1) -> 2\n3. 创建新 buffer: switch-to-buffer\n4. 需要到命令行工作时，不用关闭 emacs, 使用 suspend-frame(C-z) 回到命令行，使用 fg 命令返回 emacs\n\n## grammer\n\n1. (car list) first element\n1. (nth n list) nth element\n1. (car (last list)) last element\n\n```emacs-lisp\n(car (list \"a\" \"b\" \"c\") )   ; \"a\"\n(nth 1 (list \"a\" \"b\" \"c\") ) ; \"b\"\n(car (last (list \"a\" \"b\" \"c\")) )   ; \"c\"\n```\n\n1. `(setq temp (append temp (list 1)))` addpend to list temp\n1. loop list\n\n```emacs-lisp\n  (dolist (element (extract-rectangle start end)) ;; extract-rectangle to lists\n    (setq LIST (append LIST (split-string element)))) ;; apend to list\n```\n\n## functions\n\n1. `(message \"%s=%d\" \"test\" 1)` minibuf 打印\n1. ` (split-string \"1 2 3 4\")` => (\"1\" \"2\" \"3\" \"4\")\n1. ` (seq-map 'string-to-number (split-string \"1 2 3 4\"))` => (1 2 3 4)\n1. `(vconcat [] (split-string \"1.2.3\" \"\\\\.\"))` => [\"1\" \"2\" \"3\"]\n1. max, min, sum and mean\n1. `(extract-rectangle start end)` extract-rectangle to lists\n\n```emacs-lisp\n(defun count-of-nums (xs)\n  (length xs))\n\n(defun min-of-nums (xs)\n  (apply #'min xs))\n\n(defun max-of-nums (xs)\n  (apply #'max xs))\n\n(defun sum-of-nums (xs)\n  (apply #'+ xs))\n\n(defun mean-of-nums (xs)\n  (float (/ (float (sum-of-nums xs))\n            (count-of-nums xs))))\n```\n\n1. 对 region 进行统计，注意不能是 rectangle [http://sugano-nu.github.io/emacs-lisp-stat-attitude/](link)\n\n```emacs-lisp\n(defun statistics-in-region (start end)\n  (interactive \"r\")\n  (setq LIST (split-string (buffer-substring start end)))\n  (setq LIST (mapcar* #'(lambda (X) (math-read-number X)) LIST))\n  (message \"length:%s, mean:%s, variance:%s, standard deviation:%s, meidan:%s, max:%s, min:%s\"\n           (length LIST)\n           (math-format-number (calcFunc-vmean (cons 'vec LIST)))\n           (math-format-number (calcFunc-vvar (cons 'vec LIST)))\n           (math-format-number (calcFunc-vsdev (cons 'vec LIST)))\n           (math-format-number (calcFunc-vmedian (cons 'vec LIST)))\n           (math-format-number (calcFunc-vmax (cons 'vec LIST)))\n           (math-format-number (calcFunc-vmin (cons 'vec LIST)))))\n\n;; not chose a string with character, it will be as 0\n(defun statistics-in-rectangle (start end)\n  \"statistics-in-rectangle.\"\n  (interactive \"r\")\n  (setq LIST nil)\n  (dolist (element (extract-rectangle start end)) ;; extract-rectangle to lists\n    (setq LIST (append LIST (split-string element)))) ;; apend to list\n  ;; (setq LIST (seq-map 'string-to-number LIST)) ;;  convert to num\n  (setq LIST (mapcar* #'(lambda (X) (math-read-number X)) LIST))\n  (message \"length:%s, mean:%s, variance:%s, standard deviation:%s, meidan:%s, max:%s, min:%s\"\n           (length LIST)\n           (math-format-number (calcFunc-vmean (cons 'vec LIST)))\n           (math-format-number (calcFunc-vvar (cons 'vec LIST)))\n           (math-format-number (calcFunc-vsdev (cons 'vec LIST)))\n           (math-format-number (calcFunc-vmedian (cons 'vec LIST)))\n           (math-format-number (calcFunc-vmax (cons 'vec LIST)))\n           (math-format-number (calcFunc-vmin (cons 'vec LIST)))))\n```\n\n1. toggle function: cycle status\n\n```emacs-lisp\n;; http://xahlee.info/emacs/emacs/elisp_toggle_command.html\n(defun company-toggle-delay (@n)\n  \"Company toggle idle delay.\"\n  (interactive \"p\")\n  (let* (\n         ($values [0.2 nil])\n         ($index-before\n          (if (get 'company-toggle-delay 'state)\n              (get 'company-toggle-delay 'state)\n            0))\n         ($index-after (% (+ $index-before (length $values) @n) (length $values)))\n         ($next-value (aref $values $index-after)))\n\n    (put 'company-toggle-delay 'state $index-after)\n    (setq company-idle-delay  $next-value)\n    (message \"company idle delay to %s\" $next-value)))\n```\n\n1. if mode then\n\n```emacs-lisp\n(if (derived-mode-p 'c++-mode)\n    (message \"The mode is on\")\n    (message \"The mode is off\")\n)\n```\n\n1. yes or no\n\n```emacs-lisp\n(if (yes-or-no-p \"Do you really want to remove everything?\")\n    (message \"yes\")\n    (message \"no\"))\n```\n\n1. auto add, commit and push\n\n```emacs-lisp\n(defun aborn/simple-git-commit-push ()\n  \"Simple commit current git project and push to its upstream.\"\n  ;; (interactive \"sCommit Message: \")\n  (interactive)\n  (when (and buffer-file-name\n             (buffer-modified-p))\n    (save-buffer))                   ;; save it first if modified.\n  (magit-diff-unstaged)\n  (when (yes-or-no-p \"Do you really want to commit everything?\")\n    (magit-stage-modified)\n    ;; (magit-mode-bury-buffer)\n    (magit-diff-staged)\n    (setq msg (read-string \"Commit Message: \"))\n    (when (= 0 (length msg))\n      (setq msg (format-time-string \"commit by magit in emacs@%Y-%m-%d %H:%M:%S\"\n                                    (current-time))))\n    (message \"commit message is %s\" msg)\n    ;;(magit-commit (list \"-m\" msg))\n    (magit-call-git \"commit\" \"-m\" msg)\n    (magit-push-current-to-upstream nil)\n    (message \"now do async push to %s\" (magit-get \"remote\" \"origin\" \"url\")))\n  (magit-mode-bury-buffer))\n```\n\n## Reference\n\n1. [Xah 教程](http://ergoemacs.org/emacs/elisp_basics.html)\n1. [BuildYourOwnLispCn](https://github.com/ksco/BuildYourOwnLispCn)\n"},{"title":"Haskell","url":"/2021/06/22/Haskell/","content":"\n\n\n## Higher Order Functions\n1. Haskell functions can take functions as parameters and return functions as return values. A function that does either of those is called a higher order function.\n1. Every function in Haskell officially only takes one parameter.\n1. `map` takes a function and a list and applies that function to every element in the list, producing a new list.\n1. `filter` is a function that takes a predicate (a predicate is a function that tells whether something is true or not, so in our case, a function that returns a boolean value) and a list and then returns the list of elements that satisfy the predicate.\n1. `folds` They're sort of like the map function, only they reduce the list to some `single value`.\n1.[map, filter, fold 示意图](https://excalidraw.com/#json=5033777575231488,ixM2dP13DMyzxCvIDEpzqg)\n1. map是一种抽象，屏蔽了对list操作的具体实现，不用关心是迭代或是递归实现的，只能感受到list每个元素都经过了转化，不用考虑控制结构，只需要考虑策略。(link: SICP)\n\n## Functors, Applicatives And Monads\n1. defination\n\n```\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n\nclass (Functor f) => Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n\nclass (Applicative m) => Monad m where\n    return :: a -> m a\n    (>>=) :: m a -> (a -> m b) -> m b\n    (>>) :: m a -> m b -> m b\n    x >> y = x >>= \\_ -> y\n    fail :: String -> m a\n    fail msg = error msg\n\nclass Monoid m where  -- 注意是Monoid不是Monad\n    mempty :: m\n    mappend :: m -> m -> m\n    mconcat :: [m] -> m\n    mconcat = foldr mappend mempty\n```\n1.  type of fmap, (<\\*>) and (>>=)\n\n```\nfmap :: (Functor f) => (a -> b) -> f a -> f b           -- 先解f a封装到a, a -> b, b再封装到f b; 操作2次封装\n(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b    -- 先解f a封装到a, 解f(a -> b)封装， a -> b, b再封装到f b; 操作3次封装\n(>>=) :: (Monad m) => m a -> (a -> m b) -> m b          -- 先解m a封装到a, a -> mb; 操作1次封装\n```\n\n3. Functor, Applicative and Monad都是封装，可以封装原始类型。\n4. <$> 是 fmap 的中缀表达式版本\n5. functors: you apply a function to a wrapped value using fmap or <$>\n6. applicatives: you apply a wrapped function to a wrapped value using <*> or liftA\n7. monads: you apply a function that returns a wrapped value, to a wrapped value using >>= or liftM\n8.  conclusion\n  - A functor is a data type that implements the Functor typeclass.\n  - An applicative is a data type that implements the Applicative typeclass.\n  - A monad is a data type that implements the Monad typeclass.\n  - A Maybe implements all three, so it is a functor, an applicative, and a monad.\n9. 区别\n## Reference\n1. [Learn you haskell book](http://learnyouahaskell.com/chapters)\n3. [Functors, Applicatives, And Monads In Pictures](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n"},{"title":"Chrome shortcuts","url":"/2021/05/21/Chrome-config/","content":"\n## [shortcuts](https://support.google.com/chrome/answer/157179?hl=zh-Hans&co=GENIE.Platform%3DDesktop)\n\n1. `C-l`或`M-d`: 地址栏\n1. `M-Enter`: open another tab when search: it's very usefull\n1. `C-k` 或 `C-e`: 搜索\n1. `Tab`: 下一个可点击项\n1. `M-left`: 后退浏览历史\n1. `M-right`: 前进浏览历史\n1. `C-r`: 刷新网页\n1. `Space`: pgDn\n1. `S-Space`: pgUp\n1. `C-t`: 新标签\n1. `C-n`: 新窗口\n1. `C-w`: 关闭当前标签\n1. `C-Tab`: 切换标签\n1. `C-S-t`: 恢复关闭的标签\n1. `C-h`: history\n1. `C-j`: download\n1. `C-1`: 跳转到第一个标签\n1. `C-9`: 跳转到第一个标签\n1. `C-Backspace`: 删除一个单词\n1. `S-Esc`: 任务管理器\n1. `C-S-b`: 显示或隐藏书签栏\n1. `C-f` + `C-g`: 查找与跳转\n\n## [自定义 shortcuts](https://chrome.google.com/webstore/detail/shortkeys-custom-keyboard/logpjaacgmcbpdkdchjiaagddngobkck?hl=zh-CN)\n\n1. `M-h`：Select previous tab\n1. `M-l`：Select next tab\n1. `M-k`：Select last tab\n1. `M-b`: 后退浏览历史\n1. `M-f`: 前进浏览历史\n1. `M-s`: fullscreen\n1. `M-3`：new tab\n1. `M-8`：close tab\n1. `M-w`：Duplicate current tab\n\n## [vimium 快捷键](https://vimium.github.io/)\n\n1. `yy`: copy URL to clipboard\n1. `/`: find\n1. `j`: Scroll down\n1. `k`: Scroll up\n1. `h`: Scroll left\n1. `l`: Scroll right\n1. `gg`: Scroll to the top of the page\n1. `G`: Scroll to the bottom of the page\n\n## 搜索设置\n\n1. chrome 快捷搜索设置\n\n```\ngitlab l https://gitlab.phigent.io/?sort=name_asc&name=%s&sort=name_asc\ngithub g https://github.com/search?q=%s\ncppreference cpp https://duckduckgo.com/?sites=cppreference.com&q=%s&ia=web\ntranslate t https://translate.google.cn/?source=osdd&who=test&sl=en&tl=zh-CN&text=%s&op=translate\nblog blog https://github.com/jiaxiyang/blog/tree/master/source/_posts\nlinks links https://jiaxiyang.github.io/2020/06/29/Links/\n100ms 100ms https://github.com/jiaxiyang/100ms_dot_emacs/blob/master/init.el\nlead lead https://github.com/jiaxiyang/leader-key-mode/blob/master/leader-key-mode.el\nmelpa m https://melpa.org/#/?q=test&sort=downloads&asc=false\nexcalidraw e https://excalidraw.com/\nbaidu b https://www.baidu.com/#ie={inputEncoding}&wd=%s\n```\n\n## 插件\n\n1. [onetab 节省内存](https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall) 快捷键`alt+shift+1` 改为 `alt+1`。 `alt+2`发送当前标签页至 OneTab\n1. [广告屏蔽](https://chrome.google.com/webstore/detail/adblocker-ultimate/ohahllgiabjaoigichmmfljhkcfikeof/related?hl=zh-CN)\n1. [sourcegraph 插件](https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack)\n1. [octotree](https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN)\n1. [gitzip 插件](https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn)\n1. [vimiu](https://vimium.github.io/)\n1. [shortkeys](https://chrome.google.com/webstore/detail/shortkeys-custom-keyboard/logpjaacgmcbpdkdchjiaagddngobkck/related?hl=zh-CN)\n1. [magical](https://chrome.google.com/webstore/detail/magical-text-expansion/iibninhmiggehlcdolcilmhacighjamp/related?hl=zh-CN)\n1. [colorzilla](https://chrome.google.com/webstore/detail/colorzilla/bhlhnicpbhignbdhedgjhgdocnmhomnp?hl=zh-CN)\n1. [google translate](https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb/related?hl=en)\n1. [omni](https://github.com/alyssaxuu/omni)\n1. [easy-auto-refresh](https://chrome.google.com/webstore/detail/easy-auto-refresh/aabcgdmkeabbnleenpncegpcngjpnjkc/related)\n1. [markdown-diagrams](https://chrome.google.com/webstore/detail/markdown-diagrams/pmoglnmodacnbbofbgcagndelmgaclel)\n1. [svg-export](https://chrome.google.com/webstore/detail/svg-export/naeaaedieihlkmdajjefioajbbdbdjgp/related?hl=zh-CN)\n1. [whatfont](https://chrome.google.com/webstore/detail/whatfont/jabopobgcpjmedljpbcaablpmlmfcogm/related?hl=zh-CN)\n","tags":["Tools"],"categories":["Tools","Chrome"]},{"title":"Jetson test","url":"/2021/05/14/Jetson-test/","content":"\n## basic\n1. 使用TensorRT中的trtexec测性能\n2. 模型转化为engine后运行\n\n## links\n1. https://github.com/NVIDIA-AI-IOT/jetson_benchmarks\n1. https://developer.nvidia.com/embedded/jetson-benchmarks\n1. https://github.com/dusty-nv/jetson-inference\n1. https://github.com/NVIDIA/TensorRT/tree/release/7.1/samples/opensource/trtexec\n","tags":["Jetson"],"categories":["Computer","GPU"]},{"title":"3d Detection","url":"/2021/05/10/3d_detection/","content":"\n## lidar data\n\n1. [format](https://www.shuangyi-tech.com/news_161.html)\n2. pts、LAS、PCD、.xyz 和.pcap\n\n## PCL\n\n1. install pcl and pcl-dev or install from source\n2. [dependency](https://pcl.readthedocs.io/projects/tutorials/en/latest/compiling_pcl_posix.html)\n3. pcl version > 1.10 否则匹配不上 vtk\n4. notes: update yum source when dependency error\n5. [pcd](https://blog.csdn.net/a464057216/article/details/54864591)\n6. yum search boost; yum infoe boost;\n7. yum install boost169 boost169-devel libusbx-devel\n8. `cmake -DBOOST_INCLUDEDIR=/usr/include/boost169 -DBOOST_LIBRARYDIR=/usr/lib64/boost169 ..`\n9. rm find_package(openni) and rm with_openni\n10. [passthrough 例子](https://pointclouds.org/documentation/tutorials/passthrough.html)\n\n## ouster lidar\n\n1. [forum](https://forum.ouster.at/)\n1. 不支持 pcd 格式输出，支持 pcap 格式\n\n## links\n\n1. [survey](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9127813)\n2. [A_Survey_on_3D_Object_Detection_Methods_for_Autonomous_Driving_Applications](A_Survey_on_3D_Object_Detection_Methods_for_Autonomous_Driving_Applications)\n3. [SECOND](https://github.com/traveller59/second.pytorch)\n4. [pointpillars](https://blog.csdn.net/W1995S/article/details/114498082?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242)\n5. [点云目标检测之 VoxelNet、SECOND、PointPillars、PV-RCNN](https://zhuanlan.zhihu.com/p/75103748)\n","tags":["AI"],"categories":["Algorithm","AI"]},{"title":"TensorRT","url":"/2021/04/13/TensorRT/","content":"\n## base\n\n1. NVIDIA TensorRT is an SDK for optimizing trained deep learning models to enable high-performance inference. TensorRT contains `a deep learning inference optimizer for trained deep learning models`, and `a runtime for execution`.\n1. [转换模型步骤](https://docs.nvidia.com/deeplearning/tensorrt/archives/tensorrt-861/quick-start-guide/index.html#ecosystem)\n1. [多种转换和部署方式](https://docs.nvidia.com/deeplearning/tensorrt/archives/tensorrt-861/quick-start-guide/index.html#conv-deploy-opt)\n1. all operations in your model must be supported by TensorRT (or you must provide custom plug-ins for unsupported operations)\n1. at inference, we pick a small batch size when we want to prioritize latency and a larger batch size when we want to prioritize throughput.\n1. TensorRT supports TF32, FP32, FP16, and INT8 precisions.\n1. One of the most performant and customizable options for `both model conversion and deployment` are to use the TensorRT API, which has both C++ and Python bindings.\n1. TensorRT C++ API 中的接口类以前缀 I(interface 的意思) 开头，例如 ILogger 、 IBuilder 等。\n1. 两种方式：\n   - onnx --> engine --> c++ inference\n   - onnx --> c++ convert and inference\n1. 使用 trtexec 先将 ONNX 转换成 engine\n   - 优点：\n     - 简单性：trtexec 是一个命令行工具，可以很容易地用于转换模型，并且不需要编写任何额外的代码。\n     - 灵活性：trtexec 提供了许多命令行选项，用于优化和调试转换过程。\n     - 性能测试：您可以使用 trtexec 来测试模型的性能，这在评估优化策略时很有用。\n     - 重用：一旦创建了 engine 文件，您可以在不同的应用程序或设备上多次重用它，而不必再次进行优化。\n   - 缺点： -两步流程：首先需要使用 trtexec 创建 engine，然后在 C++程序中加载它。这使得整体流程分为两个步骤，可能不如单步流程简洁。\n1. 直接使用 C++ 接口转换 ONNX 然后进行推理\n   - 优点：\n     - 集成：整个流程，从加载 ONNX 模型到执行推理，都在一个 C++程序中完成。这对于集成到大型系统或自动化流程中很有用。\n     - 动态性：可以根据需要进行动态优化或调整，例如基于不同的输入尺寸或条件。\n   - 缺点：\n     - 复杂性：与使用命令行工具相比，需要编写和维护更多的代码。\n     - 优化时间：每次运行程序时，如果不保存和重用 engine，都可能需要重新进行模型的优化步骤。\n1. 同步推理: `executeV2`方法; 异步推理: `enqueueV2`\n1. ![NVIDIA 推理堆栈](https://developer-blogs.nvidia.com/wp-content/uploads/2023/01/nvidia-inference-stack.png)\n1. 在 TensorRT 8.5 及更高版本中， cuDNN 和 cuBLAS 内核是可选的添加，以减少 TensorRT 库的部署大小。\n1. NHWC 格式的输入非常适合 NVIDIA 上的 Tensor Core GPU 。由于 ONNX 仅支持 NCHW 格式(?)，因此必须使用技巧启用 NHWC 作为输入张量。将输入维度设置为 NHWC ，并在 CUDA 或 TensorRT EP 删除的输入之后插入 Transpose 操作\n\n## 查看版本\n\n1. jtop -> INFO\n1. jetson_release\n1. nvidia-smi\n1. `dpkg-query -W tensorrt` tensorrt 版本\n1. `cat /proc/driver/nvidia/gpus/0000\\:02\\:00.0/information` 查看硬件型号\n\n## 查看模型信息\n\n1. [polygraph](https://github.com/NVIDIA/TensorRT/tree/main/tools/Polygraphy/examples/cli/inspect/)\n   - `polygraphy inspect model tensorrt/resnet50/model.onnx`\n   - `polygraphy inspect capability model.onnx` Inspecting TensorRT ONNX Support\n   - `polygraphy inspect model op16_iter7_refine_filter_fb.trt --model-type=engine --show layers`\n   - `polygraphy run dynamic_identity.onnx --trt --onnxrt` Comparing TensorRT And ONNX-Runtime Outputs\n   - `polygraphy run dynamic_identity.onnx --trt --fp16 --onnxrt --input-shapes X:[1,2,4,4]` Comparing TensorRT Precisions\n\n## op 支持\n\n1. [onnx operators.md](https://github.com/onnx/onnx-tensorrt/blob/main/docs/operators.md)\n\n## TensorRT, CUDA, cuDNN\n\n1. CUDA 是`并行计算框架`，提供 API，可以运行在 Nvdia GPU 上\n2. cuDNN 是深度神经网络加速库，cuDNN 可大幅优化标准例程（例如用于前向传播和反向传播的卷积层、池化层、归一化层和激活层）的实施。世界各地的深度学习研究人员和框架开发者都依赖 cuDNN 实现高性能 GPU 加速。借助 cuDNN，研究人员和开发者可以`专注于训练神经网络及开发软件应用`，而不必花时间进行低层级的 GPU 性能调整。cuDNN 可加速广泛应用的深度学习框架，包括 Caffe2、Chainer、Keras、MATLAB、MxNet、PyTorch 和 TensorFlow。\n3. TensorRT 是用于高性能深度学习`推理`的 SDK。此 SDK 包含深度学习推理优化器和`运行时环境`，可为深度学习推理应用提供低延迟和高吞吐量。借助 TensorRT，开发者可专注于创建新颖的 AI 支持应用，无需费力调节性能来部署推理工作。\n\n## [trt-engine-explorer](https://github.com/NVIDIA/TensorRT/tree/main/tools/experimental/trt-engine-explorer)\n\n## trtexec\n\n### 转模型\n\n1. trtexec --onnx=./bisenetv2_310102_1280x1920.onnx --shapes=input:1x3x540x960 --saveEngine=bisenetv2-xavier-fp16-540x960.engine --allowGPUFallback --fp16 --workspace=16024\n1. onnx 模型转化为 engine or trt 后运行\n1. trtexec 在转换模型时做了一些优化，以提高模型的推理性能。这些优化包括：\n   - `算子融合：`trtexec 会尝试将多个算子融合为一个算子，以减少推理过程中的开销。\n   - `内存优化：`trtexec 会尝试将模型的权重和激活值存储在更高效的内存中，以提高推理速度。\n   - `模型裁剪：`trtexec 会尝试将模型的参数量减少，以减少推理过程中的计算量。\n   - `图优化?`\n1. trtexec 执行步骤：\n   - trtexec 会将模型转换为 TensorRT 的内部表示。\n   - trtexec 会对模型进行分析，以确定可以进行优化的算子。\n   - trtexec 会对模型进行优化，以提高推理性能。\n\n### 推理\n\n1. [Comparing TensorRT And ONNX-Runtime Outputs](https://github.com/NVIDIA/TensorRT/tree/main/tools/Polygraphy/examples/cli/run/01_comparing_frameworks#comparing-tensorrt-and-onnx-runtime-outputs)\n1. 推理时可以看各种信息：\n   - Build Options：\n     - 输入输出 name\n     - input output 格式(fp32, fp16...)\n     - batch\n     - layout(chw or hwc)\n   - Inference Options\n     - 推理次数\n   - Device Information\n   - Performance summary\n1. `trtexec --loadEngine=test.trt`\n1. `trtexec --loadEngine=test.trt --plugins=lib/libtrtplugins.so --duration=10` 带 plugin\n1. `trtexec --loadEngine=test.trt --plugins=lib/libtrtplugins.so --iterations=N --verbose=1`\n1. `trtexec --loadEngine=my_model.trt --dumpProfile=1`推理时显示每层耗时\n1. 动态输入 `trtexec --onnx=fcn-resnet101.onnx --fp16 --workspace=64 --minShapes=input:1x3x256x256 --optShapes=input:1x3x1026x1282 --maxShapes=input:1x3x1440x2560 --buildOnly --saveEngine=fcn-resnet101.engine && trtexec --shapes=input:1x3x1026x1282 --loadEngine=fcn-resnet101.engine` Where --shapes sets the input sizes for the dynamic shaped inputs to be used for inference.\n\n## links\n\n1. [tensorrt docs](https://docs.nvidia.com/deeplearning/tensorrt/index.html)\n1. [各种版本 doc](https://docs.nvidia.com/deeplearning/tensorrt/archives/index.html)\n1. [release notes](https://docs.nvidia.com/deeplearning/tensorrt/release-notes/index.html) Ensure you are familiar with the NVIDIA TensorRT Release Notes for the latest new features and known issues.\n1. [官方 c++ sample 讲解](https://developer.nvidia.com/zh-cn/blog/tensorrt-c-interface-cn/)\n1. [官方博客](https://developer.nvidia.com/zh-cn/blog/search-posts/?q=tensorrt)\n1. [c++ api](https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#c_topics)\n1. [官方 sample](https://github.com/NVIDIA/TensorRT/tree/main/samples)\n1. [samples](https://github.com/wang-xinyu/tensorrtx)\n1. [trtexec](https://github.com/NVIDIA/TensorRT/tree/release/7.1/samples/opensource/trtexec)\n1. [nvidia tensorrt pdf](http://www.hpc.iitkgp.ac.in/pdfs/Nvidia-2.pdf)\n1. [plugins](https://github.com/NVIDIA/TensorRT/tree/main/plugin)\n1. [Understanding TensorRT Runtimes](https://github.com/NVIDIA/TensorRT/blob/main/quickstart/IntroNotebooks/5.%20Understanding%20TensorRT%20Runtimes.ipynb)\n1. [c++ api 教程](https://github.com/cyrusbehr/tensorrt-cpp-api)\n1. [基于 NVIDIA 的 PC 的端到端 AI ： ONNX Runtime 中的 CUDA 和 TensorRT 执行提供程序](https://developer.nvidia.com/zh-cn/blog/end-to-end-ai-for-nvidia-based-pcs-cuda-and-tensorrt-execution-providers-in-onnx-runtime/)\n","tags":["TensorRT"],"categories":["Program","AI"]},{"title":"Actix","url":"/2021/03/22/Actix/","content":"\n\n## basic\n\n```\nuse actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};\n\n#[get(\"/\")]\nasync fn hello() -> impl Responder {\n    HttpResponse::Ok().body(\"Hello world!\")\n}\n\n#[post(\"/echo\")]\nasync fn echo(req_body: String) -> impl Responder {\n    HttpResponse::Ok().body(req_body)\n}\n\nasync fn manual_hello() -> impl Responder {\n    HttpResponse::Ok().body(\"Hey there!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .service(hello)\n            .service(echo)\n            .route(\"/hey\", web::get().to(manual_hello))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n```\n1. Use App::service for the handlersusing routing `macros` and App::route for `manually` routed handlers, declaring the `path` and `method`.\n1. `path`: http URL,例如：http://github.com/xxx/xx/xx\n2. `method`: path的响应\n3. All actix-web servers are built around the `App` instance.\n\n## Links\n1. [official docs](https://actix.rs/docs/)\n","tags":["Rust"],"categories":["Program","Rust"]},{"title":"Web","url":"/2021/03/16/Web/","content":"\n## 前端开发\n\n1. HTML: Markup Language 构建网页，例如：建筑骨架\n2. CSS: Styling Language 网页样式: 例如： 建筑外观，墙的颜色\n3. JavaScript: Programming Language 网页功能 例如：建筑功能，电梯\n4. 常用库： REACT, ANGULAE, VUE\n\n## MVC\n\n1. [维基百科](https://zh.wikipedia.org/wiki/MVC)\n1. MVC 模式在概念上强调 Model, View, Controller 的分离，各个模块也遵循着由 Controller 来处理消息，Model 掌管数据源，View 负责资料显示的职责分离原则，因此在实现上，MVC 模式的 Framework 通常会将 MVC 三个部分分离实现\n1. View 负责格式化数据并把它们呈现给用户，业务逻辑和表示层分离，同一个 Model 可以被不同的 View 重用，所以大大提高了代码的可重用性。\n\n## Controller, Service, and Repository\n\n## 增删改查（CRUD)\n\n1. [维基百科](https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%88%AA%E6%9F%A5%E6%94%B9)\n2. 增删查改（英语：CRUD[注 1]），全称增加（Create，意为“创建”）、删除（Delete）、查询（Read，意为“读取”）、改正（Update，意为“更新”），在计算机程序语言中是一连串常见的动作行为，而其行为通常是为了针对某个特定资源所作出的举动（例如：创建资料、读取资料等）。这四个行为最常见的用途是在使用 SQL 数据库与网站的 API 端口口的时候。\n\n## HTTP\n\n1. [简介](https://www.jianshu.com/p/80e25cb1d81a)\n2. [http methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)\n\n## URI\n\n1. [维基百科](https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6)\n2. 统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。\n3. URL 是一种 URI\n4. `URI = scheme “://” authority “/” path [ “?” query ][ “#” fragment ]`\n5. scheme: 指底层用的协议，如 http、https、ftp\n   host: 服务器的 IP 地址或者域名\n   port: 端口，http 中默认 80, https 中默认 443\n   path: 访问资源的路径，就是咱们各种 web 框架中定义的 route 路由\n   query: 为发送给服务器的参数\n   fragment: 锚点，定位到页面的资源，锚点为资源 id\n6.\n\n## CORS 跨域资源共享\n\n1. [所有人都应该知道的跨域及 CORS](https://zhuanlan.zhihu.com/p/53996160)\n\n## CGI 通用网关接口\n\n1. Restful 风格 API 的出现，让 CGI 获得了续命。CGI 解析前端请求，再转发给对应后端；然后从后端取回数据，给前端返回 XML 或 JSON。然后前端 JS 利用 XML/JSON 中的数据来进行填充。可以绘制出丰富的界面或用作他用。JS 可以使用 Ajax 技术来向后台 CGI 发起数据请求。Ajax 完成的是不需要刷新整个页面就可以加载后端数据（比如从数据库中取出）。\n2. 请注意区分 Web Server 和后台 Server。\n3. [图解](https://zhuanlan.zhihu.com/p/25013398)\n4. [百科](https://baike.baidu.com/item/CGI/607810)\n\n## REST API\n\n1. [postman](https://learning.postman.com/docs/getting-started/installation-and-updates/#installing-postman-on-windows)\n1. [online test](https://reqbin.com/)\n1. [youtube samples](https://www.youtube.com/watch?v=7YcW25PHnAA)\n1. [接口规范](https://i6448038.github.io/2017/06/28/rest-%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/)\n1. [github API](https://api.github.com/)\n1. [github REST API](https://docs.github.com/en/rest)\n\n## OpenAPI\n\n1. [openapi](https://swagger.io/docs/specification/about/)\n"},{"title":"Pybind11","url":"/2021/03/15/Pybind11/","content":"\n## Pybind11\n1. python与C/C++相互调用\n1. 轻量级，只含有头文件\n\n## Links\n1. [tutorial](https://pybind11.readthedocs.io/en/latest/)\n2. [github](https://github.com/pybind/pybind11)\n3. [python调用C++之pybind11入门](https://blog.csdn.net/fitzzhang/article/details/78988682)\n","tags":["Python"],"categories":["Program","Python"]},{"title":"First-Emacs-Plugin","url":"/2021/03/12/First-Emacs-Plugin/","content":"\n## 功能\n保存位置，高亮所在行，单个buffer跳转\n\n## 参考插件\n1. hightlight\n1. symbol-overlay\n1. dogears\n1. set-mark-command\n\n## 思路\n1. dogears加高亮\n1. symbol-overlay改造\n1. [函数修改](https://stackoverflow.com/questions/14454219/how-to-highlight-a-particular-line-in-emacs)\n\n\n## Links\n","tags":["Emacs"],"categories":["Tools","Emacs"]},{"title":"Git bisect to debug","url":"/2021/03/05/git-biset-to-debug/","content":"\n## Function\n1. Use binary search to find the commit that introduced a bug\n\n## Command\n\n```\n$ git bisect start\n$ git bisect bad                 # Current version is bad\n$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good\n$ git bisect log\n$ git bisect skip                 # Current version cannot be tested\n$ git bisect reset\n\n# run script\n$ git bisect run my_script arguments\n$ cat ~/test.sh\n#!/bin/sh\nmake || exit 125                     # this skips broken builds\n~/check_test_case.sh                 # does the test case pass?\n$ git bisect start HEAD v1.3.1 --      # HEAD is bad, v1.2 is good\n$ git bisect run ~/test.sh\n# git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\"\n$ git bisect reset                   # quit the bisect session\n```\n\n\n## Links\n1. [git bisect](https://git-scm.com/docs/git-bisect)\n1. [Git 二分调试法，火速定位疑难Bug](https://juejin.cn/post/6844903537860673544)\n","tags":["Git"],"categories":["Tools","Git"]},{"title":"FFmpeg","url":"/2021/02/23/FFmpeg/","content":"\n## [视频处理基本概念](https://www.ruanyifeng.com/blog/2020/01/ffmpeg.html)\n1. `容器(封装)`：`ffmpeg-formats` 视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。\n1. `编码格式`：`ffmpeg-codecs` 视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。\n2. `编码器`：`ffmpeg-encoders` 编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。\n\n## 工作流程\n1. ffmpeg的主要工作流程相对比较简单，具体如下。\n  - 解封装（Demuxing）\n  - 解码（Decoding）\n  - 编码（Encoding）\n  - 封装（Muxing）\n1. 其中需要经过6个步骤，具体如下。\n  - 读取输入源\n  - 进行音视频的解封装\n  - 解码每一帧音视频数据\n  - 进行音视频的重新封装\n  - 输出到目标\n1. \n                _______              ______________\n               |       |            |              |\n               | input |  demuxer   | encoded data |   decoder\n               | file  | ---------> | packets      | -----+\n               |_______|            |______________|      |\n                                                          v\n                                                      _________\n                                                     |         |\n                                                     | decoded |\n                                                     | frames  |\n                                                     |_________|\n                ________             ______________       |\n               |        |           |              |      |\n               | output | <-------- | encoded data | <----+\n               | file   |   muxer   | packets      |   encoder\n               |________|           |______________|\n\n## ffmpeg\n1. FFmpeg框架的基本组成包含AVFormat、AVCodec、AVFilter、AVDevice、AVUtil等模块库\n1. 主要命令\n  - ffmpeg主要用于音视频编解码\n  - ffprobe主要用于音视频内容分析\n  - ffplay主要用于音视频播放、可视化分析\n\n### ffmpeg\n1. 总共分为5部分：`ffmpeg {1} {2} -i {3} {4} {5}`\n\n```\n$ ffmpeg \\\n[全局参数] \\\n[输入文件参数] \\\n-i [输入文件] \\\n[输出文件参数] \\\n[输出文件]\n```\n\n### ffplay\n1. FFmpeg不但可以提供转码、转封装等功能，同时还提供了播放器相关功能，使用FFmpeg的avformat与avcodec，可以播放各种媒体文件或者流。如果想要使用ffplay，那么系统首先需要有SDL来进行ffplay的基础支撑。\n\n### ffprobe\n1. ffprobe也是FFmpeg源码编译后生成的一个可执行程序。ffprobe是一个非常强大的多媒体分析工具，可以从媒体文件或者媒体流中获得你想要了解的媒体信息，比如音频的参数、视频的参数、媒体容器的参数信息等。\n2. `./ffprobe –show_streams output.mp4`\n\n## ffmpeg硬编解码\n1. 当使用FFmpeg进行软编码时，常见的基于CPU进行H.264或H.265编码其相对成本会比较高，CPU编码时的性能也很低，所以出于编码效率及成本考虑，很多时候都会考虑采用硬编码，常见的硬编码包含Nvidia GPU与Intel QSV两种，还有常见的嵌入式平台，如树莓派、瑞芯微等\n\n## ffmpeg流媒体\n1. 随着互联网、移动互联网的发展，人们获取信息的方式开始从纸质媒体转向互联网文字媒体，又从文字媒体转向音视频流媒体。音视频流媒体又称为流媒体，而用于处理流媒体的压缩、录制、编辑操作，开源并强大的工具屈指可数，FFmpeg就是常见的流媒体处理工具。\n2. 流类型：RTMP, RTSP, HTTP, UDP/TCP, HDS, DASH\n\n## ffmpeg filter\n1. FFmpeg除了具有强大的封装/解封装、编/解码功能之外，还包含了一个非常强大的组件——avfilter。avfilter组件经常用于进行多媒体的处理与编辑。例如加水印，画中画，多宫格视频等\n\n## ffmpeg视频采集\n1. 可以使用FFmpeg采集本地的音视频采集设备的数据，然后进行编码、封装、传输等操作\n\n## Links\n1. [Official Documents](https://ffmpeg.org/documentation.html)\n1. [FFmpeg从入门到精通（书）](http://jxz1.j9p.com/pc/dgsdfhghgh.pdf)\n","tags":["FFmpeg"],"categories":["Program","FFmpeg"]},{"title":"Gstreamer","url":"/2021/02/23/Gstreamer/","content":"\n## Why Gstreamer\n\n1. 构建一个视频分析应用，需要考虑的内容有：视频流获取、视频流解码、预处理、算法推理、数据编码、数据显示、数据传输等。常常需要引入一些第三方的开发包，如 OpenCV，FFmpeg，Caffe，TensorRT，OpenGL 等。GStreamer 是一个用于开发流式多媒体应用的跨平台开源框架，应用程序可以通过管道(Pipeline)的方式，`将多媒体处理的各个步骤串联起来`，达到预期的效果。\n\n## Gstreamer\n\n1. `核心`为`Pipeline`框架以及用于扩展功能的`Plugins`。plugin 负责实现音视频传输协议、音视频输入输出源、音视频编解转码等真实的媒体处理功能，而 plugin 之间通过 pipeline 关联在一起，pipeline 负责将上一个 plugin 的数据流(data flow)传输给下一个 plugin，最终形成一个完整的多媒体处理应用；\n2. 原理：GStreamer 的程序通过连接数字媒体处理的元素注入管道（pipeline）。每个元素(element)是由一个插件提供。元素可组合为箱（bins），箱可以进一步聚合，从而形成架构图。元素沟通是透过垫（pads）。来源垫（source pad）上一个元素可以被连接到一个接收垫（sink pad）在另一个。当管道是在播放状态，数据缓冲流（data buffers flow）从来源垫（source pad）流向接收垫（sink pad）。\n3. 箱柜(bin)是由多个 element 构成的容器，同时 bin 本身也是一种 element，所以能够像操作普通 element 一样操作一个 bin，改变 bin 的状态可以改变 bin 内部所有 elements 的状态。bin 可以发送总线消息给它的子集 elements ，包括：错误消息(error messages)，标签消息(tag messages)，EOS 消息(EOS messages)。\n4. 管道(pipeline)是一个特殊的 bin，当设定管道暂停或播放状态的时候，数据流将开始流动，并且媒体数据处理也开始处理。\n5. element 被封装成 plugin 才能被 gstreamer 使用。\n\n## 3 层架构（plugin, core, app)\n\n![overview](https://gstreamer.freedesktop.org/documentation/application-development/introduction/images/gstreamer-overview.png)\n\n1. 最底层：element(plugins)\n1. 中间层：插件框架、pipeline 架构、媒体类型处理机制、等等，也就是处理 Elements 的方式方法.\n1. 最上层：tools, 多媒体应用\n\n## GStreamer plug-ins could be classified\n\n1. protocols handling\n2. sources: for audio and video (involves protocol plugins)\n3. formats: parsers, formaters, muxers, demuxers, metadata, subtitles\n4. codecs: coders and decoders\n5. filters: converters, mixers, effects, ...\n6. sinks: for audio and video (involves protocol plugins)\n\n## GStreamer tools\n\n1. gst-launch-1.0: 命令行建立和运行 pipeline, 不用编写 C 代码； `gst-launch-1.0 videotestsrc ! autovideosink`\n2. gst-inspect-1.0: 查看可用的插件和它们的相关信息； `gst-inspect-1.0 videotestsrc`\n3. gst-discoverer-1.0: 查看媒体文件的内部结构； `gst-discoverer-1.0 /root/Desktop/video.mp4`\n4. GST*DEBUG=\"GST_TRACER:7\" GST_TRACERS=\"proctime\" gst-launch-1.0 ... `查看每个element性能` [link](https://developer.ridgerun.com/wiki/index.php?title=GstShark*-\\_Processing_Time_tracer)\n5. [gst-shark](https://github.com/RidgeRun/gst-shark)\n\n## Links\n\n1. [About Gstreamer](https://gstreamer.freedesktop.org/documentation/application-development/introduction/index.html?gi-language=c)\n2. [Gstreamer tools](https://gstreamer.freedesktop.org/documentation/tutorials/basic/gstreamer-tools.html?gi-language=c)\n3. [Gstreamer tutorials](https://gstreamer.freedesktop.org/documentation/tutorials/basic/index.html?gi-language=c)\n4. [Gstreamer tutorials rust](https://github.com/sdroege/gstreamer-rs/tree/master/tutorials)\n5. [由 GStreamer 到 DeepStream](http://orangeamoy.com/2019/06/28/GStreamerAndDeepStream/)\n6. [插件例子](http://ericnode.info/post/gstreamer_intro/)\n7. [中文基础概念](https://www.shangyexinzhi.com/article/571316.html)\n","tags":["Gstreamer"],"categories":["Program","Gstreamer"]},{"title":"Docker","url":"/2021/02/02/Docker/","content":"\n## NOTES\n\n1. wsl2 中设置`--net=host`会影响 port 设置\n1. `docker image prune -a` 清理任何为用的的 image\n1. [docker build 以及 docker run 时使用 host 网络的方法](http://www.debugself.com/2018/01/17/docker_network/)\n1. docker 开发使用： docker image(路径无关) + docker.sh(路径相关)\n1. [tvm docker 启动 bash](https://github.com/apache/tvm/blob/main/docker/bash.sh)\n1. [windwos wsl2 + docker 开发](https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers) docker desktop 需要启动\n1. `docker attach CONTAINER`\n1. `docker info` 查看 docker 信息\n1. `docker stats` 可以看哪个 container 占用率高\n1. `sudo usermod -aG docker $USER` 将当前用户加入到 docker 组中，否则必须使用 sudo 来运行 docker\n1. `--user root --gpus all` 使用 gpu\n1. `--privileged` 使用 systemctl\n1. `docker save -o fedora-all.tar fedora` 保存镜像\n1. `docker commit my-container my-image` 保存 container 为镜像\n1. `docker load --input fedora.tar` or `docker load < busybox.tar.gz`\n1. `docker login --username=xiyang.jia hub.xxx.io` 登录后才能 push\n1. `docker commit efb954281fd3 j5-dsp-xiyang-dev:v1`\n1. `docker tag [ImageId] hub.xx.io/avp/[ImageName]:[镜像版本号]`\n1. `docker push docker.io/my-username/my-image:v1.0.0`\n1. `docker docker image rm eb3f9d403e36` 删除 image\n\n## usefull docker\n\n1. [gcc](https://hub.docker.com/_/gcc)\n\n## Command\n\n1. ![一图胜千言](https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf14142a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n2.\n\n```dockerfile\ndocker run -id --name gcc.xiyang -v /data0/users/teams/software/heterogeneous/xiyang.jia/:/data0/users/xiyang.jia -w /data0/users/xiyang.jia/d/working -p 10099:22 -v /etc/localtime:/etc/localtime gcc\n```\n\n1.\n\n```sh\n\n% docker pull openexplorer/ai_toolchain_centos_7:v1.12.5\n% docker run -id \\\n    --name openexplorer.xiyang \\\n    -v /data0/users/xiyang.jia:/data0/users/xiyang.jia \\\n    -w /data0/users/xiyang.jia/d/working \\\n    -p 10090:22 \\\n    --privileged \\\n    -v /etc/localtime:/etc/localtime \\\n    openexplorer/ai_toolchain_centos_7:v1.12.5\n\n% docker exec -it openexplorer.xiyang bash\n% docker ps\n% docker stop openexplorer.xiyang\n% docker rm openexplorer.xiyang\n% docker images\n% docker image rm xxx\n% docker logs openexplorer.xiyang\n% docker start <name> // start docker when it exit\n\n```\n\n### [docker load](https://docs.docker.com/engine/reference/commandline/load/)\n\n```sh\n% docker load < busybox.tar.gz\n% docker load --input fedora.tar\n```\n\n## Concept\n\nDocker 包括三个基本概念:\n\n1. 镜像（Image）\n1. 容器（Container）\n1. 仓库（Repository）\n   理解了这三个概念，就理解了 Docker 的整个生命周期。\n\n### [Image](https://yeasy.gitbook.io/docker_practice/basic_concept/image)\n\n1. Docker 镜像（Image），就相当于是一个 root 文件系统\n1. Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n### [Container](https://yeasy.gitbook.io/docker_practice/basic_concept/container)\n\n1. 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n### [Repository](https://yeasy.gitbook.io/docker_practice/basic_concept/repository)\n\n1. `Docker Registry`: 一个集中的存储、分发镜像的服务\n1. 一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n1. 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n## 传统虚拟化与 docker 虚拟化\n\n![传统虚拟化](https://gblobscdn.gitbook.com/assets%2F-M5xTVjmK7ax94c8ZQcm%2F-M5xT_hHX2g5ldlyp9nm%2F-M5xTdXNYDmRWNH-Lqez%2Fvirtualization.png?alt=media)\n![docker虚拟化](https://gblobscdn.gitbook.com/assets%2F-M5xTVjmK7ax94c8ZQcm%2F-M5xT_hHX2g5ldlyp9nm%2F-M5xTdXP2scg0hxytUHA%2Fdocker.png?alt=media)\n\n## VNC\n\n1. `vncserver :1`\n1. `vncserver -kill :1`\n1. `ps -ef | grep vnc`查看是否运行及端口号\n1. `cat .vnc/password.txt` 查看密码(自己设置)\n\n## Links\n\n1. [从入门到实践](https://yeasy.gitbook.io/docker_practice/introduction/why)\n1. [30 分钟快速入门](https://juejin.im/post/5cacbfd7e51d456e8833390c)\n1. [资源整理](https://juejin.cn/post/6844903450203914253)\n1. [简单聊聊 k8s，和 docker 之间的关系](https://juejin.cn/post/7224149297951195193)\n","tags":["Docker"],"categories":["Tools","Docker"]},{"title":"Kalman Filters","url":"/2021/01/30/Kalman-Filters/","content":"\n## Concept\n1. 卡尔曼滤波是一个递归的`估计`，只要获知`上一时刻的状态估计`和`当前状态的观测`就可以计算`当前状态的估计`。\n1. 卡尔曼滤波器不需要观测/估计的历史记录。\n1. 卡尔曼滤波器是一个纯粹的`时域滤波器`，而不像低通滤波器那样，需要在频率设计，然后转到时域应用。\n1. 两个阶段：\n   - `预测`：由上一状态的估计做出对当前状态的估计\n   - `更新`：利用当前状态的观测值`优化`预测阶段的估计值，以获取一个`更精确的当前状态估计`\n1. 两种数据：\n   - `估计值`\n   - `观测值`：传感器测量值，如GPS位置。\n1. 线性系统与非线性系统：\n   - 判断标准：能不能通过上一次系统估计状态直接乘以某个矩阵得到预测状态？ 矩阵都是具体的值，与估计状态相乘后只是估计状态的线性变换。（还是测量状态不能直接与估计状态求差？）\n   - `线性系统`： 预测状态 = F * 上一次估计状态。例如：预测汽车位置，传感器获得位置值，假设很短时间内，系统是匀速运动或匀加速运动（对应两种模型）。可以通过上一时刻状态乘以矩阵得到预测值。\n   - `非线性系统`：预测状态不能直接由上一次估计状态乘以一个矩阵得到。 如雷达跟踪飞机，估计状态为(x, y). 测量状态为径向距离r和夹脚。\n\n## Formulas\n1. ![5 basic formulas](/images/kalman/formulas.jpg)\n\n## links\n1. [Kalman-and-Bayesian-Filters-in-Python](https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python)\n1. [Using in car](https://blog.csdn.net/codesamer/article/details/81191487)\n1. [基于Kalman滤波器的进行物体的跟踪](https://www.jianshu.com/p/d51a3a7736ca)\n1. [图说卡尔曼滤波](https://zhuanlan.zhihu.com/p/39912633)\n1. [Youtube Matlab tutorial](https://www.youtube.com/watch?v=VFXf1lIZ3p8)\n","tags":["Filters"],"categories":["Algorithm","Kalman"]},{"title":"Redis","url":"/2021/01/11/Redis/","content":"\n## 锁设计原则\n1. 所有操作都可分为增删改查，改可用删除和增加来实现，但改更快并且具有原子性。\n1. 只有获得锁才能对锁进行删和改。\n1. 注意区分又状态和无状态。凡是涉及到有状态的API(lock, unlock)要特别小心。要与无状态API(圆的面积)模块区分开。\n1. 系统状态尽可能的少，太多状态容易出问题。\n\n\n## 基于Redis的分布式锁\n1. Redis Lua脚本具有原子性\n\n### 实现思想：\n1. 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。\n1. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n1. 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。\n\n### 超时后又多个程序获得锁解决方法\n1. 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成\n1. `为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间`\n\n### [使用守护线程特点](https://segmentfault.com/a/1190000022935064)\n1. `一定要用SET key value NX PX milliseconds 命令`:如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key永久存在)\n1. `value要具有唯一性`:这个是为了在解锁的时候，需要验证value是和加锁的一致才删除key。这是避免了一种情况：假设A获取了锁，过期时间30s，此时35s之后，锁已经自动释放了，A去释放锁，但是此时可能B获取了锁。A客户端就不能删除B的锁了。\n\n\n\n## Redis server\n\n``` shell\ngit clone https://github.com/redis/redis.git\ncd redis && make\ncd src\n./redis-server\n```\n\n## Redis client\n\n``` shell\n./redis-cli\n\n## cmd\nset foo bar\nget foo\n\n## change dump.rdb path\nconfig set dir /home/xxx\n\n# save data to dump.rdb\nsave\n```\n\n## hiredis (just a C client; not include server)\n\n``` shellp\ngit clone https://github.com/redis/hiredis.git\ncd hiredis\nmkdir build; cd build; cmake ..; make;\nsudo make install\n./hiredis-test\n\n## NOTE: sample are easier than hiredis-test\n```\n\n## Links\n1. [redis lock华为漫画](https://bbs.huaweicloud.com/blogs/209955)\n1. [Zookeeper 华为漫画](https://bbs.huaweicloud.com/blogs/209954)\n1. [redis实现分布式锁](https://blog.csdn.net/xlgen157387/article/details/79036337)\n1. [小米解决方案](https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/)\n1. [redis分布式锁](https://juejin.cn/post/6844903830442737671)\n1. [redislock C++ sample](https://github.com/yuhanfang/redislock)\n1. [Redis set command(note: NX)](https://redis.io/commands/set)\n1. [Redisson](https://github.com/redisson/redisson)\n","tags":["Redis","Database"],"categories":["Program","Database"]},{"title":"Tmux config","url":"/2020/12/07/Tmux/","content":"\n## tmux plugin\n\n1. [tpm](https://github.com/tmux-plugins/tpm)\n1. [tmux-plgins](https://github.com/orgs/tmux-plugins/repositories?q=&type=all&language=&sort=stargazers)\n1. [tmux-resurrect](https://github.com/tmux-plugins/tmux-resurrect)\n1. prefix + I install\n\n## clear-history\n\n1. Just type`<prefix> + :`in the relevant pane and then type `clear-history` and press enter.\n\n## windows layerout\n\n1. `<prefix> + M-1` 垂直对齐\n1. `<prefix> + M-2` 水平对齐\n1. `<prefix> + M-3`\n1. `<prefix> + M-4`\n1. `<prefix> + M-5`\n\n## resize window\n\n1. :resize-window -A\n\n## Tmux config\n\n```sh\n# use mouse to scroll history\nset -g mouse on        #For tmux version 2.1 and up\n# set -g mode-mouse on   #For tmux versions < 2.1\n\n# set history lenth\nset -g history-limit 15000\n\nset -g default-terminal \"xterm\"\n\n# change prefix key\nset -g prefix C-t\nunbind C-b\nbind C-t send-prefix\nset -g prefix2 C-j\nbind C-j send-prefix -2\n\n# more intuitive keybindings for splitting and create window\nbind \\\\ split-window -h -c \"#{pane_current_path}\"\nbind - split-window -v -c \"#{pane_current_path}\"\nbind c new-window -c \"#{pane_current_path}\"\n\n# swap window bind\nbind M-l swap-window -t + \\; next-window\nbind M-h swap-window -t - \\; previous-window\n\n# display\nset -g base-index 1\nset-window-option -g pane-base-index 1\nset -g renumber-windows on\n\n# set terminal title\nset -g set-titles on\n\n# redraw status line every 10 seconds\nset -g status-interval 10\n\n# right status: tmux show-options -g | grep status-right\nset -g status-right \"#{=21:host_short} \"\n\n# Remove delay when sending commands\n# (default is 500 milliseconds)\nset -sg escape-time 1\n\n# reference C-t ?\nbind-key -T prefix a select-window -t :=1\nbind-key -T prefix s select-window -t :=2\nbind-key -T prefix d select-window -t :=3\nbind-key -T prefix f select-window -t :=4\nbind-key -T prefix g select-window -t :=5\nbind-key -T prefix h select-window -t :=6\nbind-key -T prefix j select-window -t :=7\nbind-key -T prefix k select-window -t :=8\nbind-key -T prefix \\; select-window -t :=1 \\; select-window -t -1\n```\n\n## Reload config\n\n```sh\ntmux source-file ~/.tmux.conf\n```\n\n## Tmux Zsh CheatSheet\n\n[https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet](https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet)\n\n```sh\nta    : tmux attach -t\ntad   : tmux attach -d -t\nts    : tmux new-session -s\ntl    : tmux list-sessions\ntksv  : tmux kill-server\ntkss  : tmux kill-session -t\n```\n","tags":["Tmux"],"categories":["Tools","Tmux"]},{"title":"Shell Script","url":"/2020/11/28/Shell-script/","content":"\n## basic\n\n1. 判断 linux 命令是否存在\n\n```sh\nBUILD_SYSTEM=Ninja\nif ! [ -x \"$(command -v ninja)\" ]; then\n    BUILD_SYSTEM='Unix Makefiles'\nfi\n\nif ! command -v <the_command> &> /dev/null\nthen\n    echo \"<the_command> could not be found\"\n    exit\nfi\n```\n\n1. 分支，循环、 case， 函数、正则表达式\n1. shell 风格指南 [link](https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/)\n1. seq 产生顺序数 for i in `seq 1 10`;do echo jia; sleep 1; done\n1. cat\n\n```\ncat  >> a.txt <<EOF        追加\n    hello,world\nEOF\n```\n\n```\ncat  > a.txt <<EOF      覆盖\n    hello,world\nEOF\n```\n\n1. set -xe 显示运行的每一条命令，出错退出。 -x 显示 -e 退出\n1. echo -e \"jiaxiyang\\c\" 脚本输出不换行\n1. 16 进制转化为 10 进制 num=\"ABCD1234\" && echo $((16#${num}))\n1. 产生随机数 cat /proc/sys/kernel/random/uuid\n1. 获取本机 IP 地址： ifconfig | grep \"inet addr:\" | awk '{ print $2 }'| sed 's/addr://g'\n1. awk 按列过滤参数 ls -l test.sh | awk '{ print $5 }' 输出：454\n1. shell 小程序[link](https://www.jb51.net/article/54488.htm)\n1. shell 得到文件信息 `ll /var/log/messages | cut -d \" \" -f 5`\n1. shell 不用输入密码登录 expect [link](http://www.cnblogs.com/lixigang/articles/4849527.html) set timeout 3 ; spawn ssh jiaxiyang@10.10.0.17; expect \"\\*password:\"; send \"jiaxiyang\\r\";interact\n1. 读文件内容，记录到变量中 var=$(cat name.txt)\n1. 计时 start=$(date+%s) && sleep 2 && end=$(date+%s)&& echo $(($end - $start)) [link](http://blog.csdn.net/gengshenghong/article/details/7583580)\n1. sleep: sleep 1 睡眠 1 秒 sleep 1s 睡眠 1 秒 sleep 1m 睡眠 1 分 sleep 1h 睡眠 1 小时\n1. [ -f test ] && rm test 如果存在 test 文件 删除 test ，逻辑运算代替 if\n   对于包含至少一个其他函数的足够长的脚本，需要称为  main  的函数。main \"$@\"\n1. 比较二进制文件\n\n```\n#!/bin/bash\n\nprocess()\n{\n    file=$1\n    echo \"file  : $(realpath ${file})\"\n    echo \"date  : $(date -r ${file})\"\n    echo \"length: $(wc -c ${file} | awk '{print $1}')\"\n    echo \"md5sum: $(md5sum $(realpath ${file}) | awk '{print $1}')\"\n    xxd -l 96 ${file}\n    echo\n}\n\necho \"date now: $(date)\"\necho\nfor var in $@; do\n    process $var\ndone\n```\n\n1. function(in .bashrc)\n\n```\nfunction loop ()\n{\n    eval \"$@\";\n    while sleep 1; do\n        eval \"$@\";\n    done\n}\n```\n\n1. copy link libs\n\n```sh\nlibs() {\n    OUTPUT_DIR=$(date -u +\"%Y-%m-%d-%H:%M:%S\")\n    mkdir -p ${OUTPUT_DIR}/bin ${OUTPUT_DIR}/lib\n    BINS=\"$@\"\n    cp ${BINS} ${OUTPUT_DIR}/bin/\n    \"$(ldd ${BINS} | grep \"=> /\" | awk '{print $3}' | xargs -I '{}' cp -v '{}' ${OUTPUT_DIR}/lib)\"\n}\n```\n\n1. 创建固定个数 panel，每个 panel 执行不同命令\n\n```sh\n#!/bin/bash\n\nPANEL_NUM=6\nwhile [ $(tmux list-panes | wc -l) -lt ${PANEL_NUM} ]; do\n\ttmux split-window \\; #select-pane -L\ndone\n\n# even-horizontal even-vertical main-horizontal main-vertical tiled\n# tmux select-layout even-horizontal\ntmux select-layout tiled\n\nCURRENT_PANEL=$(tmux display -pt \"${TMUX_PANE:?}\" '#{pane_index}')\nfor i in $(seq 1 ${PANEL_NUM}); do\n\techo ${i}\n\tif [ ${i} -ne ${CURRENT_PANEL} ]; then\n\t\ttmux send-keys -t .${i} \"echo ${i}; ls -al\" c-m\n\tfi\ndone\n\n```\n\n1. 删除和添加版权信息\n\n```sh\n#!/bin/bash\n\n## remove license\n# for i in $(/usr/bin/fdfind -e h -e cpp -e hpp -e cc); do\nfor i in $(find . -regex '.*\\.\\(cpp\\|cc\\|cxx\\|hpp\\|h\\)'); do\n\tline=$(cat $i | grep -n \"#i[fn]\\|#pragma\" | awk -F ':' '{print $1}' | awk 'NR==1')\n\tline=$((${line} - 1))\n\tif ((${line} > 0)); then\n\t\tsed -i \"1, ${line}d\" $i\n\tfi\ndone\n\n## add license\ncat >pgcopyright.txt <<EOF\n/**\n * @copyright PhiGent.ai @ 2022\n */\n\nEOF\n\nfor i in $(find . -regex '.*\\.\\(cpp\\|cc\\|cxx\\|hpp\\|h\\)'); do\n\tcat pgcopyright.txt $i >$i.new && mv $i.new $i\ndone\n\nrm pgcopyright.txt\n```\n\n1. push to jfrog\n\n```sh\n#!/bin/bash\n\nJFROG_USER=xiyang.jia\nJFROG_PASSWD=\n\npush_to_jfrog() {\n        FILE=$1\n        JFROG_PATH=http://artifacts.phigent.io/artifactory/$2\n        MD5=$(md5sum $FILE | awk '{print $1}')\n        curl -u\"${JFROG_USER}:${JFROG_PASSWD}\" -T $FILE -H \"X-Checksum-MD5:${MD5}\" -L \"${JFROG_PATH}\"\n}\n\npush_dir_to_jfrog(){\n        for file in $(find $1 -type f); do\n                push_to_jfrog ${file} $2/${file}\n        done\n}\n\nif [ -d $1 ]; then\n        push_dir_to_jfrog $1 $2\nelse\n        push_to_jfrog $1 $2\nfi\n```\n","tags":["Shell"],"categories":["Program","Shell"]},{"title":"Python-grammar","url":"/2020/11/16/Python-grammar/","content":"\n## links\n\n1. [python tutorial](https://docs.python.org/3/tutorial/)\n\n## [data structure](https://docs.python.org/3/tutorial/datastructures.html)\n\n1. list[-1] 最后一个元素，负号表示倒着索引\n1. squares[-3:] slice: 创建新的索引，包含最后三个 value\n1. slice 是浅拷贝\n1. list1 + list2 表示 concat\n1. letters[2:5] = ['C', 'D', 'E'] 批量赋值\n1. letters[2:5] = [] remove 第 3 个到第 5 个元素\n\n## 虚拟环境\n\n```python\npython3 -m venv myenv\nsource myenv/bin/activate\npip install -r requirements.txt\n```\n\n## Debug\n\n1. `python -m trace --trackcalls pyscript.py`\n1. `python -m trace --trace pyscript.py`\n\n## pip\n\n1. set source\n\n```\npip install pip -U -i https://pypi.tuna.tsinghua.edu.cn/simple\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\n## package management\n\n1. [基于 pyproject.toml 的包管理](https://zhuanlan.zhihu.com/p/582651418)\n1. [poetry](https://github.com/python-poetry/poetry)\n1. [pixi](https://github.com/prefix-dev/pixi)\n\n## basic\n\n1. `unset all_proxy` 不能使用代理，可能出现 install 错误 [link](https://blog.csdn.net/whatday/article/details/109287343)\n1. [install python from deadsnakes](https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa)\n1. [build python from source](https://github.com/deadsnakes/docs/blob/main/Building-Deadsnakes-Packages-from-Git.rst) 编译之后需要前一级目录 `sudo dpkg -i *.deb`\n1. `pip freeze | grep pytorch`: 查看库版本\n1. python3 -c \"import torch; print(torch.**version**)\"\n1. `print(\"Numpy version:\", numpy.__version__)`\n1. [useful-snippets](https://elpy.readthedocs.io/en/latest/ide.html#other-useful-snippets)\n1. 默认引用语义\n1. `import copy; x = copy.deepcopy(y)`\n1. print(\"x: \", x, type(x), x.shape) [link](https://blog.csdn.net/sinat_28576553/article/details/81154912)\n1. print('{:.2f} ms'.format(xxx))\n1. pytorch tensor to binary file: `tensor.cpu().numpy().astype(np.float32).tofile(\"test.bin\")`; c++ read binary file\n1. print('type : {}'.format(type(xxx)))\n1. print('size : {}'.format(len(xxx)))\n\n```\nstatic std::vector<float> read_from_bin_file(std::string file) {\n  auto result_size = std::filesystem::file_size(file);\n  std::vector<float> result(result_size / 4);\n  CHECK(std::ifstream(file).read((char*)&result[0], result_size).good())\n      << \"failed to read baseline from \" << file;\n  return result;\n}\n\ntemplate <typename T>\nvoid mywritefile(T* src, int size1, std::string filename) {\n  ofstream Tout;\n  Tout.open(filename, ios_base::out | ios_base::binary);\n  if (!Tout) {\n    cout << \"Can't open the file! \" << filename << \"\\n\";\n    return;\n  }\n  Tout.write((char*)src, size1 * sizeof(T));\n  // CHECK(std::ofstream(filename).write((char*)data.data, size).good()) <<\n}\n\ntemplate void mywritefile(int8_t* src, int size1, std::string filename);\n\n```\n\n## profiling\n\n1. [cprofile](https://zhuanlan.zhihu.com/p/24495603)\n1. [viztracer](https://github.com/gaogaotiantian/viztracer)\n1. [vprof](https://github.com/nvdv/vprof)\n1. [line_profiler](https://github.com/pyutils/line_profiler)\n1. [memory_profiler](https://github.com/pythonprofilers/memory_profiler/tree/master)\n   `gprof2dot -f pstats mkm_run.prof | dot -Tpng -o mkm_run.png`\n1. profile 库\n\n```python\nimport profile\n\ndef test():\n    fps = profile.fps()\n    while True:\n        xxxxxxxxxxxxxxxxxxx\n        logging.info('fps:{}'.format(fps.compute()))\n```\n\n## [Logging](https://zhuanlan.zhihu.com/p/360306588)\n\n1. 基本配置：\n\n```\nimport logging\n\n#默认的warning级别，只输出warning以上的\n#使用basicConfig()来指定日志级别和相关信息\n\nlogging.basicConfig(level=logging.DEBUG #设置日志输出格式\n                    ,filename=\"demo.log\" #log日志输出的文件位置和文件名\n                    ,filemode=\"w\" #文件的写入格式，w为重新写入文件，默认是追加\n                    ,format=\"%(asctime)s - %(name)s - %(levelname)-9s - %(filename)-8s : %(lineno)s line - %(message)s\" #日志输出的格式\n                    # -8表示占位符，让输出左对齐，输出长度都为8位\n                    ,datefmt=\"%Y-%m-%d %H:%M:%S\" #时间输出的格式\n                    )\n\nlogging.debug(\"This is  DEBUG !!\")\nlogging.info(\"This is  INFO !!\")\nlogging.warning(\"This is  WARNING !!\")\nlogging.error(\"This is  ERROR !!\")\nlogging.critical(\"This is  CRITICAL !!\")\n\nlogging.info(\"timestamp {}, {}, {} \".format(i, bufs[i].timestamp.tv_sec, bufs[i].timestamp.tv_usec))\n```\n\n## [Debug 方法](https://blog.csdn.net/qq_38542085/article/details/78562458)\n\n1. elpy-pdb-debug-buffer\n1. logging\n1. pdb\n1. print\n\n## 多线程\n\n1. [多线程返回值](https://blog.csdn.net/qq_20663229/article/details/94484526)\n\n```python\nimport threading as th\n\ndef print_time(arg):\n    pname = mp.current_process().name\n    pid = os.getpid()\n    tname = th.current_thread().getName()\n    LOGW('print time  [{}] {} : {} : {}'.format(pid, pname, tname, arg))\n\ndef dequeue_multibuffer1():\n    threads_test = []\n    threads_test.append(th.Thread(name=\"thread 0\", target=print_time, args=(1, ))) # 线程的args是个元组，只有一个元素要加逗号\n    threads_test.append(th.Thread(name=\"thread 1\", target=print_time, args=(2, )))\n    threads_test[0].start()\n    threads_test[1].start()\n    threads_test[0].join()\n    threads_test[1].join()\n    return 0\n\n```\n\n```python\n\n# 功能， 每个线程通过v4l2获取图片，多个线程拼接并同步，然后供其他模块使用\ndef dequeue_buffer(fd, buf, mems, shape, que):\n    while True:\n        if que.empty():\n            fcntl.ioctl(fd, v4l2.VIDIOC_DQBUF, buf)\n            frame = cv.cvtColor(mems[buf.index].reshape(shape), cv.COLOR_YUV2RGB_YUYV)\n            fcntl.ioctl(fd, v4l2.VIDIOC_QBUF, buf)\n            que.put_nowait((frame, buf.timestamp))\n\ndef dequeue_multibuffer(fds, bufs, mems_list, shape, que):\n    queues = []\n    num = len(fd2)\n    for i in range(num):\n         queues.append(queue.Queue(maxsize=10))\n\n    threads_test = []\n    for i in range(num):\n        threads_test.append(th.Thread(name=str(i), target=dequeue_buffer, args=(fds[i], bufs[i], mems_list[i], shape, queues[i])))\n    for i in range(num):\n        threads_test[i].start()\n    while True:\n        datas = []\n        for i in range(num):\n            frame, timestamp = queues[i].get()\n            logging.info(\"timestamp {}, {}, {} \".format(i, timestamp.tv_sec, timestamp.tv_usec))\n            mems = mems_list[i]\n            datas.append(frame)\n        if len(datas):\n            que.put(datas)\n\ndef main()\n    frame_queue = queue.Queue(maxsize=10)\n    get_frame_thread = th.Thread(name=\"dequeue_multibuffer\", target=dequeue_multibuffer, args=([vd_r, vd_l], [buf_r, buf_l], [mems_r, mems_l], (h, w, -1), frame_queue))\n    get_frame_thread.start()\n    while True:\n         frames = frame_queue.get()\n         do.....\n\n```\n\n## [numpy](https://numpy.org/doc/stable/index.html)\n\n1. `np.testing.assert_allclose(out_np, out_tvm.numpy(), rtol=1e-3)` check result\n1. float_array = double_array.astype(np.float32)\n1. reshape (-1 自适应)\n\n```python\nx = x.reshape(2, -1)\nx = x.reshape(1,-1) # 展开为1行\n```\n\n1. nchw -> nhwc\n\n```python\nimport numpy as np\nimport sys\n\ninput_file = sys.argv[1]\noutput_file = sys.argv[2]\nN, C, H, W = sys.argv[3:7]\na = np.fromfile(sys.argv[1], dtype=np.float32)\na = a.reshape((int(N), int(C), int(H), int(W)))\na = a.transpose(0, 2, 3, 1)\na.tofile(output_file)\n```\n\n1. nhwc -> nchw\n\n```python\nimport numpy as np\nimport sys\n\ninput_file = sys.argv[1]\noutput_file = sys.argv[2]\nN, H, W, C = sys.argv[3:7]\na = np.fromfile(sys.argv[1], dtype=np.float32)\na = a.reshape((int(N), int(H), int(W), int(C)))\na = a.transpose(0, 3, 1, 2)\na.tofile(output_file)\n```\n\n1. 截取数据\n\n```python\nimport numpy as np\na = np.fromfile(\"inputs/total_flow_predictions.bin\", dtype=np.float32)\nprint(len(a))\na = np.resize(a, [len(a)//7])\nprint(len(a))\nb = np.fromfile(\"output/disparity.bin\", dtype=np.float32)\nprint(len(b))\nb = np.resize(b, [len(b)//2])\nprint(len(b))\ndiff1 = a - b\ndiff =  np.abs(diff1)\nprint(\"max diff is {}\".format(diff.max()))\nprint(\"mean diff is {}\".format(diff.mean()))\n```\n\n1. 误差\n\n```python\nimport numpy as np\nimport sys\n\na = np.fromfile(sys.argv[1], dtype=np.float32)\nprint(\"file1: {}, len: {}\".format(sys.argv[1], len(a)))\nb = np.fromfile(sys.argv[2], dtype=np.float32)\nprint(\"file2: {}, len: {}\".format(sys.argv[2], len(b)))\ndiff1 = a - b\ndiff =  np.abs(diff1)\nprint(\"max diff is {}\".format(diff.max()))\nprint(\"mean diff is {}\".format(diff.mean()))\n```\n"},{"title":"Eclipse Cpp","url":"/2020/10/06/Eclipse-Cpp-IDE-on-Windows10/","content":"\n## install Eclipse IDE for C/C++ Developers\n\n1. [Officail Download](https://www.eclipse.org/downloads/packages/release/kepler/sr2/eclipse-ide-cc-developers)\n\n## install compiler MinGW\n\n1. [Official Install](http://mingw.org/wiki/InstallationHOWTOforMinGW)\n1. [Lose Packages](https://blog.csdn.net/done1182818968/article/details/105385382)\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"Emacs on Windows10","url":"/2020/09/30/Emacs-on-Windows10/","content":"\n## Install msys2 on windindows\n1. [Tsing hua source](https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/x86_64/)\n1. [Official web](https://www.msys2.org/)\n\n## Config msys2\n1. Theme: dracula\n1. Font: Consolas 14\n1. Transparency: Medium\n1. Right mouse: paste\n1. Terminal Type: xterm-256color\n1. Cursor: bold, not blinking\n\n## Install git vim oh-my-zsh emacs\n1. [Tutorial](https://blog.csdn.net/u013938484/article/details/83539008)\n1. Note: Change package source. No vim at first, you can edit the file on windows\n1. Emacs install: `pacman -S mingw-w64-x86_64-emacs`\n1. Libs install: `pacman -S mingw-w64-x86_64-libpng && pacman -S mingw-w64-x86_64-libjpeg-turbo`\n1. Config .bashrc and .zshrc\n\n## Build emacs plugins in Ubuntu on VMvare\n1. [100ms emacs](https://github.com/jiaxiyang/100ms_dot_emacs)\n1. build and copy the tar package to msys2\n1. install package on msys2\n","tags":["Emacs"],"categories":["Tools","Emacs"]},{"title":"git","url":"/2020/09/17/git/","content":"\n## workflow\n\n1. [GitLab Flow 介绍](https://docs.gitlab.cn/jh/topics/gitlab_flow.html#gitlab-flow-%E4%BB%8B%E7%BB%8D)\n1. [GitLab Flow 的 11 条规则](http://dockone.io/article/2350)\n1. dev 分支开发新功能\n1. main or master branch 合入新功能\n1. tag 来确定 release\n\n## Basic\n\n1. git fetch --prune 会自动创建本地分支\n1. 先合并 commit, 再 rebase， 就不会出现 merge 多次现象,\n1. `git log --format='%aN' | sort -u | while read name; do echo -en \"作者： $name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"添加行数: %s, 删除的行数: %s, 代码总行数: %s\\n\", add, subs, loc }' -; done` 统计仓库每个成员代码量\n1. `GIT_TRACE=1 GIT_CURL_VERBOSE=1 git clone ` 定位问题\n1. `git commit --amend --date=now --no-edit` 修改 commit 时间 [link](https://stackoverflow.com/a/5017265)\n1. `--no-pager` 直接显示，不用按 q 退出 git --no-pager log -n 20\n1. magit `$` 查看具体命令\n1. `git add --update` 添加所有修改的文件\n1. `git describe --always --dirty --match 'NOT A TAG'`当前信息 无 tag\n   1 `git describe --dirty --tags`: 显示当前 commit 信息；例如 v1.0.1-100-gad0ddd0-dirty; v1.0.1 是最近 tag, 100 是第多少次提交；gxxx 是 commit 号， dirty 是有改动\n1. `tldr git tag`: show how to use git tag\n1. `origin`为`远程`仓库名，不是分支。 .git/config 中有远程仓库 origin 对应的 url 和 fetch\n1. upstream 上游仓库: [Git 的 origin 和 upstream，如何用？](https://blog.csdn.net/xo3ylAF9kGs/article/details/114810781)\n   ![upstream](https://img-blog.csdnimg.cn/img_convert/3753944fa6c4d586d337464233e75a61.png)\n1. `git tag v0.0.1 && git push orgin v0.0.1` 创建和 push tag\n\n## git 修改 commit\n\n1. git rebase --interactive HEAD~2\n1. 修改： `c` => `w` => `C-c C-c`\n1. 合并： magit: rebase `r` =>`i` => `C-c C-c` => `f .. f` => `C-c C-c`\n1. `ce` Extend 当前 Staged 的文件合并到上一次提交中 git commit –amend –no-edit\n1. `ca` Amend 只修改上次提交的日志 git commit –amend\n\n## commit 规范\n\n1. [约定式提交](https://www.conventionalcommits.org/zh-hans/v1.0.0/)\n1. [Commit Message Guidelines](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines)\n1. [手册](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#)\n1. [Angular 约定](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines)\n1. [guide](https://github.com/feflow/git-commit-style-guide)\n\n## add git info in C++ exe\n\n1. [cmake](http://xit0.org/2013/04/cmake-use-git-branch-and-commit-details-in-project/)\n1. [without compiling](https://stackoverflow.com/questions/51727566/how-to-make-git-commit-hash-available-in-c-code-without-needless-recompiling)\n\n## ERROR\n\n1. `git config --global http.postBuffer 5242880000` [git clone https 失败](https://www.cnblogs.com/mmzs/p/12039888.html)\n\n## [git 权限问题](https://www.cnblogs.com/zqb-all/p/10631505.html)\n\n1. mount 问题解决`chmod o+w -R .` `find . -type f | xargs chmod o+w` `chmod o+w $(find . -type f)` 给其他用户加写权限， 不会有 git 历史，umask 022\n1. [不跟踪权限](https://learnku.com/laravel/t/5340/linux-solution-to-modify-the-file-permissions-caused-by-the-git-record-file-changes)\n\n## 原理\n\n1. Git 是一个`内容寻址文件系统`，Git 的核心部分是一个简单的键值对数据库（key-value data store）。你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。\n1. .git 下四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。 它们都是 Git 的核心组成部分。\n   - `objects` 目录存储所有数据内容；\n   - `refs` 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；\n   - `HEAD` 文件指向目前被检出的分支；\n   - `index` 文件保存暂存区信息。\n1. .git 其他文件\n\n   - `description` 文件仅供 GitWeb 程序使用，我们无需关心。\n   - `config` 文件包含项目特有的配置选项。\n   - `info` 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。\n   - `hooks` 目录包含客户端或服务端的钩子脚本\n\n1. `git hash-object` 会接受你传给它的东西，而它只会返回可以存储在 Git 仓库中的唯一键。 -w 选项会指示该命令不要只返回键，还要将该对象写入数据库中。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容， 以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。\n\n```sh\n $ echo 'test content' | git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4\n $ find .git/objects -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n\n$ echo 'version 1' > test.txt\n$ git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30\n\n$ echo 'version 2' > test.txt\n$ git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n```\n\n1. 通过 `cat-file` 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 cat-file 指定 -p 选项可指示该命令自动判断内容的类型，\n\n```sh\n$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\ntest content\n```\n\n1. 利用 `git cat-file -t` 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：\n\n```sh\n$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob\n```\n\n1. 上述类型的对象我们称之为 `数据对象（blob object）`\n\n1. Git 另一种对象类型是`树对象（tree object）`，它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：\n\n```sh\n$ git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\n```\n\nmaster^{tree} 语法表示 master 分支上最新的提交所指向的树对象。 请注意，lib 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：\n\n```sh\n$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\n100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb\n```\n\n1. 可以通过底层命令 `git update-index` 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。\n\n```sh\n$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt\n```\n\n1. 可以通过 `git write-tree` 命令将暂存区内容写入一个树对象。 此处无需指定 -w 选项——如果某个树对象此前并不存在的话，当调用此命令时， 它会根据当前暂存区状态自动创建一个新的树对象：\n\n```sh\n$ git write-tree\nd8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt\n$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\ntree\n\n$ echo 'new file' > new.txt\n$ git update-index --add --cacheinfo 100644 \\\n  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n$ git update-index --add new.txt\n\n$ git write-tree\n0155eb4229851634a0f03eb265b69f5a2d56f341\n$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\n```\n\n1. 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 `git read-tree` 命令，可以把树对象读入暂存区。 本例中，可以通过对该命令指定 --prefix 选项，将一个已有的树对象作为子树读入暂存区：\n\n```sh\n$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git write-tree\n3c4e9cd789d88d8d89c1073707c3585e41b0e614\n$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\n040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\n```\n\n1. 那么现在就有了三个树对象，分别代表我们想要跟踪的不同项目快照。 然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是`提交对象（commit object）`能为你保存的基本信息。\n1. 可以通过调用 `commit-tree` 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：\n\n```sh\n$ echo 'first commit' | git commit-tree d8329f\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d\n```\n\n由于创建时间和作者数据不同，你现在会得到一个不同的散列值。\n\n```sh\n$ git cat-file -p fdf4fc3\ntree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\nauthor Scott Chacon <schacon@gmail.com> 1243040974 -0700\ncommitter Scott Chacon <schacon@gmail.com> 1243040974 -0700\n\nfirst commit\n```\n\n提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照； 然后是可能存在的父提交（前面描述的提交对象并不存在任何父提交）； 之后是作者/提交者信息（依据你的 user.name 和 user.email 配置来设定，外加一个时间戳）； 留空一行，最后是提交注释。\n\n1. 每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——`数据对象、树对象、提交对象`——最初均以单独文件的形式保存在 .git/objects 目录下。\n\n1. 如果你对仓库中从一个提交（比如 1a410e）开始往前的历史感兴趣，那么可以运行 git log 1a410e 这样的命令来显示历史，不过你需要记得 1a410e 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。\n   在 Git 中，这种简单的名字被称为`引用（references，或简写为 refs）`\n\n1. 若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：\n\n```sh\n$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master\n```\n\n现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：\n\n```sh\n$ git log --pretty=oneline master\n1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\ncac0cab538b970a37ea1e769cbbde608743bc96d second commit\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\n```\n\n我们不提倡直接编辑引用文件。 如果想更新某个引用，Git 提供了一个更加安全的命令 `update-ref` 来完成此事：\n\n```sh\n$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9\n```\n\n1. 这基本就是 Git `分支的本质：一个指向某一系列提交之首的指针或引用`。 若想在第二个提交上创建一个分支，可以这么做：\n\n```sh\n$ git update-ref refs/heads/test cac0ca\n```\n\n1. 至此，我们的 Git 数据库从概念上看起来像这样：\n   ![包含分支引用的 Git 目录对象](https://git-scm.com/book/en/v2/images/data-model-4.png)\n   当运行类似于 git branch <branch> 这样的命令时，Git 实际上会运行 update-ref 命令， 取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。\n\n1. 当你执行 git branch <branch> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。\n1. `HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支`。 所谓符号引用，表示它是一个指向其他引用的指针。\n\n1. 当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。\n   你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：git symbolic-ref。 可以借助此命令来查看 HEAD 引用对应的值：\n\n```sh\n$ git symbolic-ref HEAD\nrefs/heads/master\n```\n\n同样可以设置 HEAD 引用的值：\n\n```sh\n$ git symbolic-ref HEAD refs/heads/test\n$ cat .git/HEAD\nref: refs/heads/test\n```\n\n1. `标签引用`\n   前面我们刚讨论过 Git 的`三种主要的对象类型（数据对象、树对象 和 提交对象 ）`，然而实际上还有第四种。 `标签对象（tag object）` 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 `它像是一个永不移动的分支引用——永远指向同一个提交对象`，只不过给这个提交对象加上一个更友好的名字罢了。\n\n## links\n\n1. [git 游戏](https://learngitbranching.js.org/?locale=zh_CN)\n1. [git 可视化](https://zhuanlan.zhihu.com/p/190303151)\n1. [5 git workflow](https://www.cnblogs.com/xueweihan/p/13524162.html)\n1. [一文弄懂 Gitflow、Github flow、Gitlab flow 的工作流](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html?bsh_bid=2219775734)\n1. [gitflow github_flow gitlab_flow](https://blog.51cto.com/nanjke/3030113)\n1. [A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)\n1. [how-does-git-work](https://github.com/ByteByteGoHq/system-design-101#how-does-git-work)\n","tags":["git"],"categories":["Tools","git"]},{"title":"How to use org mode","url":"/2020/09/05/How-to-use-org-mode/","content":"\n## Shortkeys\n\n1. next/previous heading `C-c C-n/p`\n1. next/previous heading, same level `C-c C-f/b`\n1. `org-agenda-list` show agenda list\n1. `org-open-at-point` `C-c C-o` open links\n\n## capture -> refile -> archiving\n\n1. C-c c capture a new item (C-u C-u = goto last)\n1. C-c C-w refile subtree (C-u C-u = goto last)\n1. C-c C-x C-a archive subtree using the default command\n1. C-c C-x C-s move subtree to archive file\n1. C-c C-x a/A toggle ARCHIVE tag / to ARCHIVE sibling\n\n## code\n\n1. `<src` to insert src block\n2. `(org-babel-do-load-languages 'org-babel-load-languages '((shell . t)))` enable sh\n3. `(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))` enable c++\n\n```c++\n#+begin_src cpp\n    #include<iostream>\n    int main(){\n        std::cout << \"hello world!\" << std::endl;\n        return 0;\n    }\n#+end_src\n\n#+RESULTS:\n: hello world!\n```\n\n## Table\n\n1. `|------+-----------|` 是 row 0\n1. `org-table-export` test.csv 导出 csv\n1. 公式\n   - `:=` 只对当前单元格起作用\n   - `=` 对一行或一列起作用\n   - `@` 指定行\n   - `$` 指定列\n   - `C-c '` 编辑公式\n   - `C-u C-c *` 整个表格求公式\n   - show line, column, formula reference `C-c ?`\n   - toggle table coordinate grid `C-c }`\n1. `C-c -` insert hline below (C-u : above) current row\n1. `C-c RET` insert hline and move to line below it\n1. convert region to table `C-c |`\n1. move the current column left `M-LEFT/RIGHT`\n1. move the current row up/down `M-UP/DOWN`\n1. sum numbers in current column/rectangle `C-c +`\n1. re-align the table without moving the cursor `C-c C-c`\n1. re-align the table, move to next field `TAB`\n1. move to previous field `S-TAB`\n1. re-align the table, move to next row `RET`\n\n## Tags\n\n1. set tags for current heading `C-c C-q`\n2. create sparse tree with matching tags `C-c \\`\n3. `#+FILETAGS: :work` all the item in file has work tag\n4. globally (agenda) match tags at cursor `C-c C-o`\n\n## Priority\n\n1. raise/lower priority of current item `S-UP/DOWN`\n1. select next/previous state `S-LEFT/RIGHT`\n1. `C-c , [ABC]` set the priority of the current item\n1. `C-c , SPC` remove priority cookie from current item\n\n## [checkbox](https://orgmode.org/manual/Checkboxes.html)\n\n1. `- [ ]`\n1. `C-c C-c` org-toggle-checkbox\n1. .....[/] show [1/5]\n1. .....[%] show [20%]\n\n## agenda\n\n1. `calfw-org-mode` M-c\n1. `tab` open on other window\n1. start/stop/cancel the `clock` on current item `I / O / X`\n1. view mode dispatcher `v`\n1. add/move current file to front of agenda `C-c [`\n1. remove current file from your agenda `C-c ]`\n1. cycle through agenda file list `C-’`\n1. display next/previous day,week,... `f / b`\n1. goto today / some date (prompt) `. / j`\n1. `d` org-agenda-day-view\n1. `w` org-agenda-week-view\n1. toggle entry text / clock report `E / R`\n\n## clock\n\n1. start/stop/cancel the `clock` on current item `I / O / X`\n1. start clock on current item `C-c C-x C-i`\n1. stop/cancel clock on current item `C-c C-x C-o/x`\n\n### [Calfw-org-mode](https://github.com/kiwanami/emacs-calfw)\n\n## Timestamp\n\n1. prompt for date and insert timestamp `C-c .`\n1. insert DEADLINE timestamp `C-c C-d`\n1. insert SCHEDULED timestamp `C-c C-s`. `.` goto today\n1. stampe: `+1 20:00+1` +1day and 20:00-21:00\n1. change timestamp at cursor ±1 day `S-RIGHT/LEFT`\n1. change year/month/day at cursor by ±1 `S-UP/DOWN`\n\n# [startup](https://orgmode.org/manual/Initial-visibility.html)\n\n```\n#+STARTUP: overview\n#+STARTUP: content\n#+STARTUP: showall\n#+STARTUP: show2levels\n#+STARTUP: show3levels\n#+STARTUP: show4levels\n#+STARTUP: show5levels\n#+STARTUP: showeverything\n```\n\n# Configs\n\n```\n(global-set-key (kbd \"<f9>\") 'org-clock-jump-to-current-clock)\n(global-set-key (kbd \"<f12>\") 'org-agenda-list)\n(global-set-key (kbd \"C-c l\") 'org-store-link)\n(global-set-key (kbd \"C-c a\") 'org-agenda)\n(global-set-key (kbd \"C-c c\") 'org-capture)\n\n(setq org-clock-out-remove-zero-time-clocks t)\n(setq org-startup-folded 'content\n      org-agenda-span 'day\n      org-agenda-window-setup 'current-window\n      org-agenda-start-on-weekday nil)\n(setq org-agenda-inhibit-startup t) ;; ~50x speedup\n;;(setq org-agenda-use-tag-inheritance nil) ;; 3-4x speedup\n(setq org-tags-column 80)\n(set-time-zone-rule \"Asia/Shanghai\") ;; show china time zone\n(add-hook 'org-agenda-mode-hook\n            (lambda () (add-hook 'window-configuration-change-hook\n                                 'org-agenda-align-tags nil t)))\n\n(setq org-directory \"~/org\")\n(setq org-default-notes-file (concat org-directory \"/notes.org\"))\n(setq org-agenda-files '(\"~/org/gtd.org\"\n\t\t\t \"~/org/daily.org\"\n\t\t\t \"~/org/weekly.org\"\n\t\t\t \"~/org/ideas.org\"))\n\n\n(setq org-highest-priority ?A)\n(setq org-lowest-priority  ?D)\n(setq org-default-priority ?D)\n(setq org-priority-faces\n      '((?A . (:background \"red\" :foreground \"white\" :weight bold))\n        (?B . (:background \"DarkOrange\" :foreground \"white\" :weight bold))\n        (?C . (:background \"yellow\" :foreground \"DarkGreen\" :weight bold))\n        (?D . (:background \"DodgerBlue\" :foreground \"black\" :weight bold))\n        ))\n(setq org-todo-keywords\n      '((sequence \"TODO(t)\" \"|\" \"DONE(d)\" \"CANCELED(c@/!)\")))\n        ;; (sequence \"|\" \"CANCELED(c)\")))\n(setq org-todo-keyword-faces '(\n                               ;; (\"TODO\" . org-warning)\n                               ;; (\"DONE\" . \"green\")\n                               (\"CANCELED\" . \"grey\")\n                               ))\n(setq org-agenda-prefix-format\n      (quote\n       ((agenda . \" %-10:c%?-12t% s\"))))\n(defun my:open-org-calendar ()\n  \"Open an org schedule calendar in the new buffer.\"\n  (interactive)\n  (save-excursion\n    (let* ((source1 (cfw:org-create-source))\n           (curr-keymap (if cfw:org-overwrite-default-keybinding cfw:org-custom-map cfw:org-schedule-map))\n           (cp (cfw:create-calendar-component-buffer\n                :view 'week\n                :contents-sources (list source1)\n                :custom-map curr-keymap\n                :sorter 'cfw:org-schedule-sorter)))\n      (switch-to-buffer (cfw:cp-get-buffer cp))\n      (when (not org-todo-keywords-for-agenda)\n        (message \"Warn : open org-agenda buffer first.\")))))\n\n(defun calfw-org-mode()\n  \"Open calfw org\"\n  (interactive)\n  (load-file \"~/.emacs.d/straight/build/calfw-org/calfw-org.el\")\n  (my:open-org-calendar))\n\n\n(defun get-pic-from-url (url filename)\n  (shell-command (concat \"wget -O \" filename \" \" url)))\n(defun org-pomodoro-get-pictures ()\n  \"Get pomodoro notification pictures\"\n  (interactive)\n  ;; (get-pic-from-url \"https://pic3.zhimg.com/e76fc9f4120b9bd6ca2a7ae03a447f19_1440w.jpg?source=172ae18b\" \"~/begin_short_break.jpg\")\n  (get-pic-from-url\n  \"https://previews.123rf.com/images/vaselena/vaselena1507/vaselena150700001/42287443-white-alarm-clock-with-red-clock-face-with-inscription-coffee-time-without-figures-on-white-backgrou.jpg\"\n  \"~/coffe_time.jpg\")\n  (get-pic-from-url\n  \"https://previews.123rf.com/images/vaselena/vaselena1510/vaselena151000045/47728782-white-alarm-clock-with-red-clock-face-with-inscription-work-time-without-figures-on-white-background.jpg\"\n  \"~/work_time.jpg\"))\n\n(add-hook 'org-pomodoro-finished-hook\n          (lambda ()\n            (w32-shell-execute \"open\" \"~/coffe_time.jpg\")))\n(add-hook 'org-pomodoro-break-finished-hook\n          (lambda ()\n            (w32-shell-execute \"open\" \"~/work_time.jpg\")))\n(add-hook 'org-pomodoro-long-break-finished-hook\n          (lambda ()\n            (w32-shell-execute \"open\" \"~/work_time.jpg\")))\n\n```\n\n## pdf\n\n1. [link](https://gist.github.com/melvincabatuan/350f86611bc012a5c1c6)\n2. `sudo yum -y --skip-broken install texlive-\\*`\n3. install texlive-full [link](https://baohaojun.github.io/blog/2016/12/13/0-How-to-export-Chinese-with-Org-mode-Latex-backend.html)\n\n## Links\n\n1. [cheatsheat](https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf)\n1. [Org Mode](https://orgmode.org/)\n1. [org card](https://orgmode.org/worg/orgcard.html)\n1. [Org Guide](https://orgmode.org/orgguide.pdf)\n1. [Org Mode Chinese Tutorial](https://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html)\n","tags":["Emacs"],"categories":["Emacs"]},{"title":"Bjarny Stroustrup cpp","url":"/2020/08/18/Bjarny-Stroustrup-Cpp/","content":"\n## What is C++20?\n\n1. The best approximation of C++'s ideals so far.\n1. As big an improvement over C++11 as C++11 was over C++98: A major \"release\"\n1. Lots of useful features\n   - Simpler, more expressive, faster code that compiles faster\n   - Modeles\n   - Concepts\n   - Coroutines\n   - Ranges\n   - Dates\n   - Span\n   - Better compile-time programing support\n   - Many \"minor features\"\n1. C++23 and C++26 is better than C++20, not the major \"release\".\n1. Diretly learn C++20. It's the outside layer of the onion.\n1. C++23:\n   - \"Completes C++20\"\n   - Plus: standard modules, library support for coroutines, executors & networking\n   - Maybe: static reflection, pattern matching\n\n## Keys C++ \"Rules of Thumb\"\n\n1. `A static type system` with equal support for build-in and user-defined types\n   - A type: specifies the set of operations that can be applied to an object and specifies how an object is laid out in memory\n   - A static type system: the base of all\n   - static mean compile time will determine all the type(not the run-time).\n   - compile-time error detection\n   - performance\n   - flexibility through compile-time resolution(overloading, generic programming, metaprogramming...)\n1. `Value and reference semantics`\n   - value types: Inegers, characters, strings, containers,...\n   - Pointers/references: T\\*, T&, unique_ptr<T>, Forward_iterator\n1. `Direct use` of machine and operating system resources\n   - bitset and span(modern c++)\n   - the onion principle: the more layers you peel off, the more control, the more error.\n1. Systematic and general `resource management`(RAII)\n   - manage heap, file...\n   - every resource must have an owner: responsible for its cleanup.\n   - control the complete object life cycle: creation, copy, move, destruction\n1. Support `composition` of software from separately developed parts.\n   - modules\n   - all major features support composition: moduls, classes, concepts, templates, functions, aliases\n1. Support for `object-oriented programming`\n1. Support for `generic programming`\n   - concepts\n1. Support `compile-time programming`\n   - Move computation from run-time to compile-time(performace, do once)\n   - It's everywhere: overloading and virtual functions, templates, variadic templates, constexp functions...\n1. `Concurency` through libraries supported by intrinsics\n1. `Libraries`\n   - A user shouldn't have to care whether a feature is implemented in the language or in a library\n\n## Philosophy (CppCoreGuidelines)\n\n1. Express ideas directly in code\n1. Write in ISO Stardard C++\n1. Express intent\n1. Ideally, a program should be statically type safe.\n1. Prefer compile-time checking to run-time checking.\n1. What cannot be checked at compile time should be checkable at run time\n1. Catch run-time errors early.\n1. Don't leak any resources.\n1. Don't waste time or space.\n1. Prefer immutable data to mutable data\n1. Encapsulate messy constructs, rather than spreading through the code.\n1. Use supporting tools as appropriate\n1. Use support libraries as appropriate\n\n## Lower levels of abstaction\n\n1. Samples:\n   - Sizes\n   - Raw pointers\n   - Allocation and deallocation\n   - Loop-control variables\n   - Casts\n   - Macros\n1. Except as implementation details and asides\n1. Don't go to lower level if you have to.\n\n## What really matters?\n\n1. People\n1. A programming language is a tool, not an end goal: peopeo want great systems, not programming languages.\n1. Software developers want great tools: not just programming language features.\n\n## Abstraction\n\n1. Often, the software is more complicated than the hardware.\n1. abstraction in code:\n   - resource mangement: vector\n   - generic programing: concepts: compile-time predicates.\n\n## The onion principle\n\n1. Mangagement of complexity: make simple thing simple.\n1. Layers of abstraction: the more layers you peel off, the more you cry.\n\n## An engineering approach\n\n1. Design c++ is not pure math.\n1. Principled and pragmatic design\n1. Progress gradually guided by feedback\n1. There are always many tradeoffs: choosing is hard\n1. Design decisions have consequences\n\n## C++ in two lines\n\n1. Direct map to hardware\n   - of instructions and fundamental data types\n   - initially from C\n   - Future: use novel hardware better(caches, multicores, GPUs, FPGAs, SIMD, ...)\n1. Zero-overhead abstraction\n   - classes, inheritance, generic programming, ...\n   - initially from Simula(where it wasn't zero-overhead)\n   - Future: Type- and resouce-safety, concepts, modules, concurrency, ...\n\n## C++'s role\n\n1. A language for\n   - writing elegant and efficiaent programs\n   - for definning and using light-weight abstractions\n   - a language for resource-constrained applications\n   - building software infrastructure\n1. Offers\n   - a direct map to hardware\n   - Zero-overhead abstraction\n1. No language is perfect\n   - for everthing\n   - for everyone\n\n## C++ is tunable\n\n1. Make simple things simple\n   - Don't make complicated tasks impossible\n   - Don't make complicated tasks unreasonable hard to do\n   - The onion principle\n1. Don't drop to lower levels of abstraction\n   - Unless you really, really need to\n   - Hide messy code behind clean interfaces\n1. Alwasy measure\n\n## Write better code\n\n1. Cleaner\n2. Simpler\n3. More readable\n4. More maintainable\n5. Faster\n6. Less clever\n7. More general\n8. More usable and re-usable\n9. Type safe\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"Effective modern cpp","url":"/2020/08/14/Effective-modern-cpp/","content":"\n\n## 绪论\n1. `右值`对应的是函数返回的临时对象，`左值`是可指涉的对象，可通过名字，指针等来标识。\n1. 判断左值右值方法： 判断是否能取得地址。如果能取得地址则是左值，不能则为右值。例如`Widget(Widget&& rhs);`其中rhs为左值，因为函数体内对rhs取地址没有问题。相当于rhs被右值初始化，接受了右值。\n1. 函数中，`实参`是用来初始化`形参`的。\n1. 形参都是左值，而作为其初始化依据的实参，既能是右值，也可能是左值。例：`Widget(Widget& rhs);`rhs是左值，传入的实参也是左值。`Widget(Widget&& rhs);`rhs是左值，传入的实参是右值。\n1. `声明`的作用是引入名字和类型，而不给出细节。如存储位置或具体实现。`定义`则会给存储位置和具体实现的细节。定义同时也可以当声明用。\n1. `函数的签名`：只包含形参类别和返回值类别，不包含函数名字和形参名字。例如：`bool(const Widget&)`\n\n## 第一章 类型推到\n1. C++98仅有一套类型推导规则，用于函数模板。C++11对其进行改进，并增加了两套，一套用于auto，一套用于decltype。C++14又扩展了使用语义。\n\n### 条款1： 理解模板类别推导\n1.\n\n\n## 第三章 转向现代C++\n### 在创建对象时注意区分()和{}\n1. 对象初始化的方式包括使用小括号，使用等号，或是使用大括号：`int x(0); int y = 0; int z{0};` 等号加大括号等效于大括号`int z = {0};`\n1. 大括号初始化又称为`统一初始化`。\n1. 大括号可以用来对容器进行初始化，例如: `vector<int> v{1, 2, 3, 4};`\n1. 类的成员变量在类的定义时可以用`{}`或者`=`进行初始化，不能使用`()`\n1. 不可复制对象(例如：std::atomic)可以使用`{}`或者`()`进行初始化，不能使用`=`\n1. 大括号初始化`禁止内建类型进行隐式窄化类型转化`。如：`double x, y; ... ; int sum{x+y};`编译出错，double无法用int表示。\n1. C++规定，任何能够解析为声明的都要解析为声明。大括号初始化免疫。`Widget w1();`此处被解析为函数声明，而不是初始化w1调用构造函数。`Widget w2{};`调用无形参的构造函数来构造w2。\n1. 大括号初始化时如果形参出现std::initializer_list会优先调用，此时可以小括号。\n1. 模板内容进行创建时，应该使用小括号还是大括号是一个棘手问题。\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"Network","url":"/2020/08/11/Network/","tags":["Network"],"categories":["Computer","Network"]},{"title":"OS","url":"/2020/08/11/OS/","content":"\n## page faults\n\n1.\n\n## C++ 变量内存分配区域\n\n1. 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n2. 堆区（heap）就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的。一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链。堆可以动态地扩展和收缩。\n3. 自由存储区(也在堆区？) 就是那些由 new 分配的内存块，一般一个 new 就要对应一个 delete。\n4. 全局区/静态区（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域 data 段， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域 bss 段。程序结束后有系统释放\n5. 常量存储区 存放的是常量，不允许修改。常量字符串就是放在这里的。常量字符串不能修改, 否则程序会在运行期崩溃（当然，你要通过非正当手段也可以修改，而且方法很多）.程序结束后由系统释放\n\n### [C++ 自由存储区和堆区](https://blog.csdn.net/Q_1849805767/article/details/107376682)\n\n1. 堆是操作系统维护的一块内存，而自由存储是 C++中通过 new 与 delete 动态分配和释放对象的抽象概念。堆与自由存储区并不等价\n1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。\n1. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。\n1. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。\n\n## linux 虚拟内存空间分区\n\n1. `cat /proc/pid/maps 或 pmap pid` 看进程映射区域\n1. 64 位系统虚拟内存 ![linux 64 memory](https://fanlv.wiki/2021/07/25/linux-mem/Linux-Memory-X86-64.jpg)\n1. ELF 在装载时按照 Segment 划分。一个 Segment 包含一个或多个属性类型的 Section。实际上 Segment 的概念是从装载的角度重新定划分了 ELF 的各个段。[link](https://maodanp.github.io/2019/06/02/linux-virtual-space/)， 映射的时候，这里面的 segment 会对应一个 VMA。Linux 将进程虚拟地址空间中的一个段叫做虚拟内存区域（VMA）。![示意图](https://maodanp.github.io/pic/2019/2019-06-02-linux-virtual-space-02.png)\n1. ELF 可执行文件中有两个概念，分别是段(segment)和节(section)。通过 `readelf -S name.elf` 可以查看 ELF 可执行文件的节头表，这里面有所有节的信息。使用命令 `readelf -l name.elf` 来查看 ELF 的段。而系统正是按照“segment”而不是“section”来映射可执行文件的。\n1. readelf -a test 先显示 section 信息， 然后显示 segment(Program Headers)信息，接着显示 Section to Segment mapping 信息\n1. 从装载的角度看，我们只关心\"LOAD\"型的 segment，因为只有它是需要被映射的，其他诸如“NOTE”,\"GNU_STACK\"都是在装载时起辅助作用的。[link](https://blog.csdn.net/weixin_44395686/article/details/104761488)\n1. 总体而言，Segment 和 Section 是从不同角度来划分同一个 ELF 文件。从 Section 角度来看 ELF 文件就是链接视图（Linking View），从 Segment 角度来看 ELF 文件则是执行视图（Execution View）。\n\n### 进程虚拟存储器\n\n1. 只读区(.init, .text, .rodata)\n2. 已初始化的数据(.data 段)\n3. 未初始化的数据(.bss 段)\n4. 堆\n5. 映射区(mmap, 共享库等)\n6. 栈\n\n### 内核虚拟存储器\n\n1. 内核代码和数据\n2. 物理存储器\n3. 与进程相关的数据结构(每个进程不同)\n\n## ELF\n\n1. [变量根据情况分配在.bss 段上](https://stackoverflow.com/a/16557699)\n   - int bigvar_in_bss[16300];\n   - int bigvar_in_bss[16300] = {0};\n   - int bigvar_in_data[16300] = {1};\n   - int var_in_data[5] = {1, 2, 3, 4, 5};\n1. `file -A` 查看各 section 大小\n1. `nm test` 查看变量是否在 bss 段上\n1. `readelf -s test 或 nm -S test` 查看变量大小, 在其他模块定义的符号 size 为 0\n1. `nm -S --size-sort test` 按 size 排序\n1. 初始化为 0 的在 bss 段上？[link](https://stackoverflow.com/a/16557776)\n\n## others\n\n### [同步异步，阻塞非阻塞区别](https://www.cnblogs.com/mhq-martin/p/9035640.html)\n\n1. `不同的的概念，同步与异步区别是什么时候拿到最终结果，阻塞和非阻塞区别进程线程是是否等待结果， 同步可以是阻塞的， 也可以是非阻塞的(一次非阻塞拿不全结果， 轮询try_lock或read noblock)，异步可以是阻塞的，也可以是非阻塞的，阻塞是同步的，但非阻塞不一定异步的. 比如非阻塞系统调用read，返回的是字节数，不是最终结果。`\n1. 组合：\n\n   - 同步阻塞：同步接口里使用阻塞方式拿到最终结果\n   - 同步非阻塞：同步接口里通过非阻塞方式轮询拿到最终结果\n   - 异步阻塞：异步接口里通过阻塞方式拿到最终结果\n   - 异步非阻塞：异步接口里通过非阻塞方式拿到最终结果\n\n1. 同步与异步是更高层次上的概念\n1. 同步与异步区别是什么时候拿到最终结果。如果是在调用函数就拿到最终结果，则是同步的，\n1. 同步异步区别是在调用一个功能时，没得到`结果`之前，是否继续后续操作（有问题，非阻塞也是没拿到结果，也往后继续进行， 但是非阻塞不一定是异步的）\n1. 阻塞非阻塞区别是`线程/程序`在等待调用结果时，是否一直等待（挂起当前线程）\n1. 阻塞和非阻塞关注的是程序在`等待调用结果`（消息，返回值）时的`状态`.\n1. 进程线程锁是用来同步的，lock()函数是阻塞式，不拿到锁不返回，线程被阻塞。try_lock()是非阻塞式的，如果拿不到锁也返回。\n1. 异步是目的，而多线程是实现这个目的的方法\n1. [非阻塞 I/O 和异步 I/O](https://www.zhihu.com/question/19732473/answer/241673170)\n   非阻塞 I/O 系统调用( nonblocking system call )的另一个替代品是 异步 I/O 系统调用 （asychronous system call）。 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。\n   此处， 非阻塞 I/O 系统调用( nonblocking system call ) 和 异步 I/O 系统调用 （asychronous system call）的区别是：\n   - 一个非阻塞 I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。\n   - 而异步 I/O 系统调用 read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。\n     上面提到的 非阻塞 I/O 系统调用( nonblocking system call ) 和 异步 I/O 系统调用 都是非阻塞式的行为（non-blocking behavior）。 他们的差异仅仅是返回结果的方式和内容不同。\n1. 我们所说的 “阻塞”是指进程在发起了一个系统调用（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源。\n\n1. 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。\n1. 在 IO 系统调用层面（ IO system call ）层面， 非阻塞 IO 系统调用 和 异步 IO 系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）\n\n1. 举例：从磁盘读 50000 字节到内存\n\n- 同步：调用 api，api 内不拿到结果或出错不返回。\n- 异步：调用 api, 直接返回，结果通过 callback 等方式通知。结果是完整的。\n- 阻塞：线程系统调用 read(), 不读 50000 字节不返回，线程挂起，内核态在执行。\n- 非阻塞：线程系统调用 read(NO_BLOCK), 达到某个条件，如出现'\\n'直接返回，结果不完整，线程要多次调用来得到结果。\n\n### [Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测](http://arthurchiao.art/blog/intro-to-io-uring-zh/)\n\n## CFS\n\n1. [Linux CFS 调度器：原理、设计与内核实现](http://arthurchiao.art/blog/linux-cfs-design-and-implementation-zh/)\n\n## linux src\n\n1. [apt-get source linux-source](https://askubuntu.com/a/159842)\n","tags":["OS"],"categories":["Computer","OS"]},{"title":"Cargo","url":"/2020/08/05/Cargo/","content":"\n## Build Scripts\n1. 有些库依赖第三方语言的库，例如需要C库，并且需要从源码编译，cargo目标并不是取代那些优化很好的第三方编译工具，所以cargo通过build脚本来集成其他工具。\n1. 在crate包的根路径下创建一个名为`build.sh`的脚本，Cargo会在编译crate包之前先编译`build.sh`脚本然后执行该脚本。\n1. 如果`build.sh`依赖的文件有任何改变，会被重新编译。\n1. build脚本的输入是通过环境变量传递的。\n1. 环境变量中的当前路径就是`build.sh`源码所在路径。\n1. build脚本会将输出放入到`OUT_DIR`中的各个路径中。所以build脚本不应该改变这些输出路径中的文件。\n1. Cargo会解析那些以`cargo:`开头的行，其他行被忽略。\n1. build脚本的输出默认被隐藏，可以使用`-vv`(very verbose)来查看输出。如果依赖的文件没有被改变，什么都不会输出，因为不会重新执行编译脚本。\n1. build脚本的编译输出都会存在类似于`target/debug/build/<pkg>/output`文件中。\n1. ...\n1. `build.sh`中依赖的crates需要在Cargo.toml中的`[build-dependencies]`中指定依赖，`build.sh`可用的依赖见[crates.io build-dependencies crates](https://crates.io/keywords/build-dependencies)\n","tags":["Rust","Cargo"],"categories":["Program","Rust"]},{"title":"Software design","url":"/2020/08/03/Software-design/","content":"\n## [roadmap](https://github.com/stemmlerjs/software-design-and-architecture-roadmap)\n\n1. [system-design-101](https://github.com/ByteByteGoHq/system-design-101)\n1. [project-based-learning like build-your-own-x](https://github.com/practical-tutorials/project-based-learning#cc)\n1. [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)\n1. [build-your-own-x](https://github.com/codecrafters-io/build-your-own-x) 实现 os, git, c++编译器等 sample\n1. [system-design-primer(200K star)](https://github.com/donnemartin/system-design-primer)\n1. [awesome-design-patterns](https://github.com/DovAmir/awesome-design-patterns)\n<!-- more -->\n\n1. Summary\n   ![Summary](https://user-images.githubusercontent.com/6892666/65833569-bb34fc00-e29f-11e9-8516-79cbd9f8f07b.png)\n1. [programming-principles](https://github.com/webpro/programming-principles)\n1. Map\n   ![map](https://user-images.githubusercontent.com/6892666/65896069-834eb700-e37a-11e9-95be-7ae2300d5d50.png)\n1. [分析模板](https://github.com/joelparkerhenderson/architecture-decision-record)\n1. [github](https://github.com/search?q=software+architecture)\n1. [SoftwareArchitect](https://github.com/justinamiller/SoftwareArchitect)\n   ![roadmap2](https://github.com/justinamiller/SoftwareArchitect/raw/master/src/archRoadmap.jpg)\n\n## good design\n\n1. `高内聚，低耦合`\n1. (代理模式？) opencv 接口使用代理类 _InputArray，This is the proxy class for passing read-only input arrays into OpenCV functions. \\_InputArray is a class that can be constructed from Mat, Mat_<T>, Matx<T, m, n>, std::vector<T>, std::vector<std::vector<T> >, std::vector<Mat>, std::vector<Mat\\_<T> >, UMat, std::vector<UMat> or double. It can also be constructed from a matrix expression.\n   [link](https://docs.opencv.org/4.6.0/d4/d32/classcv_1_1__InputArray.html)\n\n## 架构风格、架构模式、设计模式 [link](https://cloud.tencent.com/developer/article/1627409)\n\n1. 架构风格是在最高抽象层次上的应用程序设计；\n1. 架构模式是实现架构风格的一种方式；\n1. 设计模式是解决局部问题的一种方法。\n1. [10 种常见的软件架构风格？](https://www.cnblogs.com/IcanFixIt/p/7518146.html)\n\n## Architecture Style\n\n### 分层 Layered Architecture\n\n### 管道和过滤器\n\n### Client/Server\n\n### 事件驱动 Message Bus\n\n1. ![Architectural diagrams for the various IoT protocols.](https://marvel-b1-cdn.bc0a.com/f00000000264121/www.rti.com/hs-fs/hubfs/Assets%202017/communicationsevolution.jpg?width=720&height=405&name=communicationsevolution.jpg)\n\n### 发布订阅风格\n\n- 事件总线是对发布-订阅模式的一种实现。 [事件总线（发布订阅模式）](https://juejin.cn/post/6949929918138417165)\n\n### p2p\n\n1. RPC? 为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。\n\n### Service-Oriented Architecture (SOA)\n\n## Architecture Pattern\n\n## [programming-principles](https://github.com/webpro/programming-principles)\n\n1. `Don't Make Me Think`\n1. `开闭原则` 软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的\n1. `单一职责原则` 一个类只做一件事\n1. `里氏替换原则` 子类应该可以完全替代父类，也就是说在使用继承时，只扩展新功能，不要破坏父类原有的功能。\n1. `依赖倒置原则` 细节应该依赖与抽象，抽象不应该依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。\n1. `迪米特法则/最少知道原则` 一个类不应该知道自己操作类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。\n1. `接口隔离原则` 客户端不应该依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将该接口拆分，让实现类只依赖自己需要的接口。\n\n1. 稳定抽象原则\n1. [vitis ai library 为例](https://excalidraw.com/#json=5093806722514944,Fbhi7FIo_fywgxy1glxm3w)\n1. `控制翻转`\n1. `依赖注入`\n\n## Design Pattern\n\n### [工厂模式](https://blog.csdn.net/qq_52670477/article/details/126629335)\n\n1. [C++ 基于模板的自动注册工厂模式](https://zhuanlan.zhihu.com/p/268462046)\n1. [示意图](https://excalidraw.com/#json=XTOYCW9APeNtW9s_GEcAP,fKiAKGMSFLUlct6H4HAQ6Q)\n1. 简单工厂模式： 不符合开闭原则\n1. 工厂方法模式\n1. 抽象工厂模式\n1. 从代码的实现复杂度来看，简单工厂模式最简单，工厂方法模式次之，抽象工厂模式最复杂。如果将简单工厂模式的代码修改得符合“开闭原则”，就变成了工厂方法模式；如果修改工厂方法模式的代码，使得一个工厂支持多个产品的生产，那就成了抽象工厂模式。\n1. 原来由用户直接对对象进行管理，变成由工厂(ioc 容器)对对象进行管理，然后注入到应用程序中。实现了应用和用户与对象具体实现的松耦合。\n1. [稳定抽象原则](https://excalidraw.com/#json=5093806722514944,Fbhi7FIo_fywgxy1glxm3w): 依赖关系指向更稳定的方向，工厂接口比较稳定，应用和对象具体实现都依赖工厂接口。\n\n### 单例模式\n\n1. 注意单例模式静态链接问题，如果链接两次，可能会有两个单例，有多份静态程序。如注册机制未加 PRIVATE 限制，导致静态库被链接两次， 可以用 gdb 调试，注册函数加断点, 看看调用堆栈。\n1. 类比： 政府是单例模式的一个很好的示例。 一个国家只有一个官方政府。 不管组成政府的每个人的身份是什么， ​ “某政府” 这一称谓总是鉴别那些掌权者的全局访问节点。\n\n### 消费者模式\n\n1. 类比： 如果你订阅了一份杂志或报纸， 那就不需要再去报摊查询新出版的刊物了。 出版社 （即应用中的 “发布者”） 会在刊物出版后 （甚至提前） 直接将最新一期寄送至你的邮箱中。出版社负责维护订阅者列表， 了解订阅者对哪些刊物感兴趣。 当订阅者希望出版社停止寄送新一期的杂志时， 他们可随时从该列表中退出。\n\n### 订阅发布模式\n\n1. 消息中间件经常使用， 例如 ZeroMQ(libzmq)\n1. MQ(message queue)\n\n### 订阅发布模式和观察者模式\n\n1. [link1](https://segmentfault.com/a/1190000020169229)\n1. [观察者模式 vs 发布订阅模式](https://zhuanlan.zhihu.com/p/51357583)\n1. [fastdds](https://blog.csdn.net/briblue/article/details/124081170)\n\n### 生产者消费者模式\n\n### 代理模式\n\n1. 现实类比： 信用卡代理现金\n1. opencv\n1. 消息中间件\n1. ![接口图](https://www.runoob.com/wp-content/uploads/2014/08/20211025-proxy.svg)\n\n### [组合模式](https://refactoringguru.cn/design-patterns/composite)\n\n1. 画图，可以有 subgraph\n1. tree 也是一种组合？\n1. 组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n1. 类成员变量中有该类数组\n\n## Software Design\n\n1. ![MVC、RPC、SOA和微服务架构区别](/images/software-diagram/architechture.png)\n\n## Reflection\n\n1. 反射字面意思：由类型名映射到类型对象？\n1. 反射技术以其明确分离描述系统自身结构、行为的信息与系统所处理的信息，建立可动态操纵的因果关联以动态调整系统行为的良好特征，已经从理论和技术研究走向实用化，使得动态获取和调整系统行为具备了坚实的基础。当需要编写扩展性较强的代码、处理在程序设计时并不确定的对象时，反射机制会展示其威力，反射技术以其明确分离描述系统自身结构、行为的信息与系统所处理的信息，建立可动态操纵的因果关联以动态调整系统行为的良好特征，已经从理论和技术研究走向实用化，使得动态获取和调整系统行为具备了坚实的基础。当需要编写扩展性较强的代码、处理在程序设计时并不确定的对象时，反射机制会展示其威力，这样的场合主要有：\n   - 序列化（Serialization）和数据绑定（Data Binding）\n   - 远程方法调用（Remote Method Invocation RMI）\n   - 对象/关系数据映射（O/R Mapping）。\n1. 由于 c++中的类结构可读性差，难以调试，协议升级困难等缺点，导致 xml 与 json 等自注释文本协议普及。但`文本协议`（文件里方便阅读理解）与`内存模型`（内存上）存在差异，需要有序列化与反序列化对象的操作。序列化：将类对象转化为文本，反序列化：将文本转化为类对象。开发者需要写大量重复代码去进行序列化与反序列化操作。Java 为解决这个问题添加了反射机制:将类型信息编译到 class 文件中，并利用这些信息提供统一的序列化与反序列化功能。\n1. 反射基本功能之一：如何通过类的名称来生成新的对象？例：`ClassXX object = new \"ClassXX\"`, C++使用：`ClassXX object = new ClassXX(x)` 工厂函数是通过在工厂函数里指定 tpye 来生成，不是通过类名。`ClassXX object = ClassXX::create(x)`\n1. 实现方法：\n   - 每一个类都创建一个产生对象的函数\n   - 设计一个总的工厂类，类中使用 map 保存(类名，函数)。通过共产类创建对象。因为全局只需要一个工厂类的对象，因此使用单例模式设计工厂类。\n1. 编程语言的反射机制所能实现的功能还有通过类名称字符串获取类中属性和方法，修改属性和方法的`访问权限`等，系统运行起来之后可修改类属性方法权限，厉害。\n\n### Reference\n\n1. [concept](https://zhuanlan.zhihu.com/p/70044481)\n1. [sample](https://blog.csdn.net/K346K346/article/details/51698184)\n\n## [Dependency Injection (DI)依赖注入 Inversion of Contol (IOC)控制反转](https://blog.csdn.net/weixin_43862847/article/details/122341510)\n\n1. [fruit DI 框架](https://github.com/google/fruit)\n1. [boost di](https://github.com/boost-ext/di)\n1. [c++相关依赖注入框架](https://stackoverflow.com/q/56091707)\n1. 解决依赖类之间的紧耦合问题，假设 a 依赖 b（b 的实例可能是 a 的成员变量），实现了 b 类实例的创建与 a 无关。\n1. 通常由调用者创建被调用者的实例（调用者依赖被调用者，调用者会在自己函数体内创建被调用者），当创建被调用者不再由调用者来完成，而是通过容器来创建被调用者实例，然后注入调用者。因此被成为依赖注入。\n1. a 依赖 b，但 a 不控制 b 的创建和销毁，仅使用 b，那么 b 的控制权交给 a 之外处理，这叫`控制反转`，而 a 要依赖 b，必然要使用 b 的 instance，那么通过 a 的接口把 b 传入，或通过 a 的构造把 b 传入，或通过设置 a 的属性把 b 传入，这个过程叫做`依赖注入`。\n1. 随着 DI 的频繁使用，要实现 IOC(相当于工厂模式中总的工厂)，会有很多重复代码，有人将实现 IOC 的代码打包成组件或框架，来避免人么重复造轮子。所以实现 IOC 组件或框架，我们可以叫它`IOC Container`。\n1. DI 是 IOC 实现方法之一。\n1. 构造方法注入： a 构造函数中将 b 作为参数传递。\n1. 工厂模式注入： 将 b 的工厂传递给 a。\n1. `类型擦除`指将原有类型消除或者隐藏，因为很多时候我们并不关心具体类型是什么，我们只需要去使用就可以了，提高提高代码的简洁性。是不是很耳熟，对，抽象继承的多态其实就是比较传统、常见及简单的类型擦除。我们使用的只是抽象接口，而不关心具体实现类的类型。类型擦除常用做法是`多态、模板、通用类型（C++17 std::any|std::variant）、闭包`\n1. [对 IOC 和 DI 的通俗理解](https://blog.csdn.net/fuzhongmin05/article/details/55802816) good\n1. 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n## Links\n\n1. [微服务架构设计模式](https://item.jd.com/12595796.html) [book pdf](https://blog.csdn.net/flyzer0/article/details/108574150)\n1. [Microsoft Application Architecture Guide, 2nd Edition](<https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff650706(v=pandp.10)>)\n1. [系统架构——MVC、RPC、SOA 和微服务架构](https://www.cnblogs.com/shoshana-kong/p/14943755.html)\n1. [MVC、 RPC、SOA 和 微服务架构异同](https://www.jianshu.com/p/48839b7d0050)\n1. [程序设计语言分类](https://zh.wikipedia.org/wiki/Template:%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80)\n1. [计算机科学](https://zh.wikipedia.org/wiki/Template:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\n1. [10 architectures](https://www.cnblogs.com/IcanFixIt/p/7518146.html)\n1. [CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md)\n1. [Ruanyifeng](http://ruanyifeng.com/blog/2016/09/software-architecture.html)\n1. [Software architecture patterns](https://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf)\n1. [Software-Engineering-at-Google 中文版本](https://github.com/qiangmzsx/Software-Engineering-at-Google)\n1. [java-design-patterns stars hight](https://github.com/iluwatar/java-design-patterns)\n","tags":["Design"],"categories":["Program","Design"]},{"title":"Cpp to c interface","url":"/2020/07/27/Cpp-to-c-interface/","content":"\n## base\n\n1. 如果给 c++程序 dlopen 用，只需要 create 和 release 接口，c++程序可以拿到 C++头文件定义，可以将 create 指针强转成类对象，用完之后调用 free。\n1. shared_ptr 两种解决方法(堆上手动管理智能指针，栈由系统自动管理)\n   - struct 存 graph\n   - 创建 shared_ptr 的指针，指针不释放 (已经创建栈上的 shared_ptr,没法调用 new)\n   - [自建 sample](https://github.com/jiaxiyang/cpp_sandbox/tree/master/cpp2c)\n\n### [extern \"C\" 作用](https://www.cnblogs.com/xiangtingshen/p/10980055.html)\n\n1. extern \"C\"的主要作用就是为了能够正确实现 C++代码调用其他 C 语言代码。加上 extern \"C\"后，会指示编译器这部分代码按 C 语言（而不是 C++）的方式进行编译。由于 C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。\n1. `extern \"C\" {}` 作用是阻止 C++ name mangling, 生成 C 格式符号表\n\n## method.hpp\n\n```c++\n#pragma once\n\nnamespace jia {\nClass Method {\n public:\n    static std::unique_ptr<Method> create(std::string name);\n\n    virtual const std::string get_name() const = 0;\n}\n}\n```\n\n## method_imp.hpp\n\n```c++\n#pragma once\n#include \"method.hpp\"\n\nnamespace jia {\nClass MethodImp : public Method {\n public:\n    MethodImp(std::string name);\n    const std::string get_name() const override;\n\n private:\n    int name_;\n    int value_;\n    friend class c_api;  // the purpose is to get the private member which can not get from the public interface\n}\n}\n\n```\n\n## method.cpp\n\n```c++\n#include \"method.hpp\"\n#include \"method_imp.hpp\"\n\nnamespace jia {\n\nstd::unique_ptr<Method> Method::create(std::string name) {\n    return std::unique_ptr<Method>{static_cast<Method*>(new Method{name})};\n}\n\n}\n\n```\n\n## method_imp.cpp\n\n```c++\n#include \"method_imp.hpp\"\n#include \"c.h\"\n\nnamespace jia {\n\nMethodImp::MethodImp(std::string name)\n    : name_{name},\n      value_{1}{};\n\nconst std::string MethodImp::get_name() const {\n    return name_;\n}\n\n}  // namespace jia\n\n/* C API implementations */\n#include \"c.h\"\n\nnamespace jia {\n\nclass c_api {\n public:\n    static int get_value(c_method_t method) {\n        auto self = static_cast<jia::Method*>(method);\n        return self->value_;  // to get value_; c_api need to be friend class of MethodImp\n    }\n}\n\nextern \"C\" c_method_t c_create(const char* name) {\n    auto m = jia::Method::create(std::string(name));\n    return static_cast<c_method_t>(m.realse());  // release will move unique_ptr ownership\n}\n\nextern \"C\" int c_destroyed(c_method_t method) {\n    auto m = static_cast<jia::Method*>(method);\n    delete m;\n    return 0;\n}\n\nextern \"C\" const char* c_get_name(c_method_t method) {\n    auto self = static_cast<jia::Method*>(method);\n    return self->get_name().cstr();\n}\n\nextern \"C\" int c_get_value(c_method_t method) {\n    return jia::c_api::get_value(method);\n}\n\n}\n\n```\n\n## c.h\n\n```c++\n#pragma once\n\n#ifdef __cplusplus  // c++ will use and c not use\nextern \"C\" {\n#endif\n\ntypedef void* c_method_t;\n\nc_method_t c_create(const char* name);  // create an instance\n\nint c_destroyed(c_method_t);            // destroy the instance\n\nconst char* c_get_name(c_method_t method);\n\nint c_get_value(c_method_t method);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n## test.c\n\n```c++\n#include \"c.h\"\n\nint main() {\n    c_method_t m = c_create(\"c_test\");\n    printf(\"name:  %s\", m->c_get_name());\n    printf(\"value: %d\", m->get_value());\n    c_destroyed(m);\n}\n```\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"Memory concept and issues","url":"/2020/07/26/Memory-concept-and-issues/","content":"\n## base\n\n1. [/proc/meminfo](https://github.com/freelancer-leon/notes/blob/master/kernel/mm/meminfo.md)\n1. RES=CODE+DATA 进程使用的、未被换出的物理内存大小\n1. 内存主要关注物理内存, 虚拟内存表示程序文件及链接库大小，并不是所有的都加载到内存\n1. used mem = total - free - buffers - cache （man free 可以看计算公式),\n1. 主要看 `avaliable` < free + buff/cache ` top | grep avail` or `free -s 1(100)` 间隔长好看趋势\n1. 纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到 free 中去，因此在 linux 上 free 内存会越来越少。\n1. %MEM -- Memory Usage (RES) A task's currently used share of available physical memory. 当前使用的物理内存 / 总的物理内存\n1. 进程内存不增长， 系统整体内存一直增长可能是 log 文件写到/tmp 目录下\n\n## 内存墙\n\n1. [英伟达、高通、特斯拉、Mobileye 芯片真实算力大比拼](https://mp.weixin.qq.com/s/P6rlEFZGZ6jZqhldmH5UKg)\n   - 芯片和内存分开， 芯片有最高支持的内存类型。开发板上 ddr 类型才是确认的。所以开发板和实际用的产品可能性能不一样。\n1. [汽车领域拥抱 Transformer 需要多少算力？1200TOPS 都不够](https://mp.weixin.qq.com/s/tSTRBtdNG55COBlUWyCDIg)\n1. 内存墙是指随着计算能力的持续增长，内存的访问速度相对于处理器的速度提升相对滞后，导致处理器频繁地等待数据。这个不平衡造成的性能瓶颈常常被称为“内存墙”。\n1. `处理器速度的增长`：在过去的几十年里，处理器的速度增长迅速，遵循摩尔定律（每 18-24 个月，晶体管的数量翻倍）。这导致了处理器每秒可以执行的指令数大幅增加。\n1. `内存速度的增长相对较慢`：尽管 DRAM 技术也在不断进步，但与处理器的增速相比，其访问速度和带宽的增长较为缓慢。\n1. `访问延迟`：当处理器需要从主内存中读取数据时，它经常需要等待几个周期才能获取数据。由于处理器的速度比内存快得多，这种等待成为了一个瓶颈，限制了性能。\n1. `缓存的引入`：为了缓解这个问题，现代计算机系统引入了缓存（L1、L2、L3 等）来存储频繁访问的数据。这些缓存比主内存快得多，但容量较小。当缓存未命中时，处理器必须从主内存中获取数据，这会引入延迟。\n1. `带宽与延迟`：除了访问延迟外，带宽也是一个问题。`即使内存的延迟得到改善，处理器仍然可能会被大量的并发内存访问操作所限制，导致带宽成为瓶颈`\n1. `解决方案`：有许多方法被提出来试图克服内存墙的问题，包括更智能的缓存策略、预取策略、多线程、多核处理器设计等。此外，新的内存技术，如 HBM (High Bandwidth Memory) 和 3D 堆叠内存，也被引入来提供更高的带宽。\n   总的来说，内存墙描述了一个关键的挑战：随着处理器速度的增长，如何确保它们能够及时地获取所需的数据。这是计算机架构领域的一个核心问题，研究者持续致力于开发新的技术和策略来解决这个问题。\n\n## 内存类型\n\n1. HBM (High Bandwidth Memory) 是一种高性能、高带宽的堆叠式 DRAM（动态随机存取存储器）技术。HBM 是由 AMD 和 Hynix 合作开发，旨在解决高性能计算应用中带宽和功耗的瓶颈问题。\n   - 将多个 DRAM 以一种堆叠的方式嵌入到统一处理器封装内部，可降低访问延迟。从而允许处理器和 DRAM 间建立更多更快的连接。\n1. LPDDR4 是 \"Low Power Double Data Rate 4\" 的缩写，它是一种移动 DRAM（Dynamic Random-Access Memory）标准。这种类型的内存主要用于移动设备（如智能手机、平板电脑和某些高端笔记本电脑）中，因为它设计为在较低电压下运行，从而减少功耗和延长电池寿命。\n1. LPDDR4x 是 LPDDR4 的一个增强版本，它主要优化了功耗，适用于电池供电的移动设备，如智能手机和平板电脑。LPDDR4x 为 \"Low Power Double Data Rate 4x\" 的缩写。\n\n## 内存概念\n\n1. page 是磁盘和内存交换数据基本单位， cache line 是内存和缓存交换数据基本单位。\n1. <<计算机体系结构>> 第 2 章存储器层次机构设计\n1. 栈和堆都是代码在运行时可供使用的内存。\n1. 栈中的所有数据都必须占用已知且固定大小。\n1. 栈的读写比堆要快。\n1. 当代码调用一个函数时，传递给函数的值和数据的局部变量被压入栈中，当函数结束时，这些值被移除栈。\n1. Rust 所有权的存在是为了管理堆数据。\n1. 数据在堆上才需要释放\n1. 数据在堆上赋值时无指出是浅拷贝(C++)或移动(Rust，原来的变量不在有效)，而不是深拷贝。\n1. Rust 数据在栈上，赋值是都是拷贝，原来的变量依旧有效。在堆上，赋值都是移动，原来变量无效。\n1. Rust String 由三部分组成，ptr，len，capacity，这一组数据在栈上，ptr 是指向在堆上数据的指针。（数据结构的固定长度数据在栈上，可变数据在堆上）\n\n## 内存(堆栈)错误类型\n\n1. 引用空指针\n1. 使用未初始化的内存\n1. 释放后使用，也就是使用悬垂指针\n1. 缓冲区溢出，比如数组越界\n1. 非法释放已经释放过的或者未分配的指针\n\n## 内存管理方式\n\n1. 垃圾回收机制，在程序运行时不断的寻找不再使用的内存\n1. 程序员亲自分配内存和释放内存\n1. Rust 通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查，拥有数据所有者在离开作用域后自动清除其数据\n\n## [内存信息](https://www.cnblogs.com/wardensky/p/4274180.html)\n\n1. `dmidecode|grep Speed`\n1. [windows aida64](https://www.aida64.com/downloads/YWY1MWUxM2E=)\n\n   - 工具 -> 内存缓存测试 -> 有内存类型\n   - 最下面有性能测试\n   - [破解](https://www.extremexbb.com/aida64-keys/) 使用: 6.85.6300 版本\n\n1. `DDR4-2666`\n   - `I/O 时钟频率`： 1333 MHz\n   - `数据传输速率`： 2666 MT/s， 即每秒 2666 MT/s（Mega Transfers per second）\n   - 位宽决定带宽；如果位宽为 64， 带宽为： 2666 \\* 8 = 21GB/s\n1. 内存带宽和位宽都是评估和描述内存性能的关键指标。它们涉及到数据在内存与其他组件（如 CPU）之间传输的速率以及每次传输的数据量。以下是这两个术语的解释：\n1. `内存带宽 (Memory Bandwidth)`：\n\n   - 定义：内存带宽描述了数据可以在特定时间内从内存传输到 CPU 或其他设备的最大速度。它是衡量内存性能的关键参数。\n   - 单位：常用的单位是 GB/s（吉字节每秒）。\n   - 计算方法：内存带宽 = 内存时钟频率 x 数据传输次数 x 位宽; 其中，数据传输次数通常基于内存类型，例如，DDR（Double Data Rate）内存每个时钟周期有两次数据传输。\n\n1. `位宽 (Memory Bus Width)`：\n   - 定义：位宽描述了内存总线一次能够传输的数据量。它决定了每次数据传输的宽度。\n   - 单位：位（bit）。常见的位宽有 8-bit, 16-bit, 32-bit, 64-bit, 128-bit 等。\n   - 例如，一个 64-bit 宽的内存总线意味着它可以一次性传输 64 位（8 字节）的数据。\n1. `sample`：假设我们有一个 DDR3 内存，其时钟频率为 1600 MHz，位宽为 64-bit。那么内存带宽的计算方法为：内存带宽 = 1600 MHz x 2 x 64 bits = 25600 Mbits/s = 25.6 GB/s, 因此，此内存的带宽是 25.6 GB/s。\n\n## 理论峰值带宽(compare with cpu)\n\n1. 和 cpu 比较\n\n## [内存性能测试](https://blog.csdn.net/pcokk/article/details/90733871)\n\n1. [Tools_Linux_Memory_Perf_Measure.md](https://github.com/LucaCanali/Miscellaneous/blob/master/Spark_Notes/Tools_Linux_Memory_Perf_Measure.md)\n1. [各平台各性能指标计算方法](https://github.com/RRZE-HPC/likwid/tree/master/groups)\n1. 因为 cache 比较小，需要频繁交换数据，读写大块数据几乎每次都要从 ddr 读数；例如：模型推理，每次推理都要从 ddr 重新读权重, 并不是将权重一直放在 cache 中。\n   - 从磁盘到 ddr 可能只需要加载一次\n1. [rust net bandwidth](https://github.com/imsnif/bandwhich)\n\n1. `mbw 32 -b 4096`\n1. `sysbench memory run`\n1. `lmbench`\n1. `Memtest86+`\n\n### perf\n\n1. `perf list and perf stat -e <memory_access>`获取 memory access, 根据时间，位宽算带宽\n   - `sudo perf record -F 99 -e armv8_pmuv3/mem_access/ -ag -- sleep 1`\n   - `sudo perf list -n` 还能看到带宽占用比例\n   - 可以画火焰图\n   - bandwidth = 位宽 \\* count / second; 可以与 bandwidth 对比\n\n```sh\ntimeout=2\nwhile true\ndo\n  perf record -e mem_access -ag -- sleep $timeout > /dev/null 2>&1\n  db=$(perf report | grep \"Event\" | awk '{print $NF}' | head -n 1)\n  result=$(( 8 * ${db} / ${timeout}  / 1000000 ))\n  echo \"$result MB/s\"\ndone\n```\n\n1. [arm55 pmu 手册](https://developer.arm.com/documentation/100442/0100/debug-descriptions/pmu/pmu-events?lang=en)\n1. `likwid-perfctr -e` 列出所有 PMC\n1. `likwid-perfctr -e | grep MEM`列出所有内存相关 PMC, `perf stat -e r013,r066,r067` r + mask + eventsel 监控对应事件\n\n```sh\nnvidia@miivii-tegra:~$ likwid-perfctr -e | grep MEM\nMEM_ACCESS, 0x13, 0x0, PMC\nMEMORY_ERROR, 0x1A, 0x0, PMC\nMEM_ACCESS_LD, 0x66, 0x0, PMC\nMEM_ACCESS_ST, 0x67, 0x0, PMC\n\nnvidia@miivii-tegra:~$ perf stat -e r013,r066,r067 -- ls\nDesktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos\n\n Performance counter stats for 'ls':\n\n           156,045      r013:u\n           118,079      r066:u\n            37,966      r067:u\n\n       0.003111539 seconds time elapsed\n\n       0.003294000 seconds user\n       0.000000000 seconds sys\n```\n\n### [(good) bandwidth](https://zsmith.co/bandwidth.php#download)\n\n1. 可以抠出来源码，实时检测内存使用\n1. [不同处理器的带宽](https://zsmith.co/bw-table.php)\n1. 测试多核性能时，运行多个实例，相加结果。Is bandwidth actually showing the maximum bandwidth to and from main memory? There is an easy way to test this. We can run one instance of bandwidth on each core of a multi-core CPU (in my case, two instances, one for each core) and add up the access bandwidths to/from main memory for all instances to see whether they approach the published limits for our main memory system.\n1. 使用\n\n```sh\nwget -c https://zsmith.co/archives/bandwidth-1.12.3.tar.bz2\nsudo apt install nasm\nmake\n```\n\n1. 上图可以看出来在三个地方曲线有明显的转折。分别是 32k、256K、12MB。这分别是三级缓存的大小。就跟下图所示一样, 也就是说：当读写的 size 大小落在相应的 cache 里面的时候，吞吐量是最大的。当读写的大小的 size 超过这个 cache，而落入到下一个 cache 的时候，吞吐量就会降低。内存是最低的。[link](https://neuyilan.github.io/2017/03/07/bandwidth%E6%95%99%E7%A8%8B/)\n\n### likwid\n\n1. [测内存性能](https://github.com/RRZE-HPC/likwid/wiki/Tutorial%3A-Empirical-Roofline-Model)\n\n### [TheBandwidthBenchmark](https://github.com/RRZE-HPC/TheBandwidthBenchmark)\n\n## [内存压测](https://blog.51cto.com/u_14900374/2533353)\n\n1. memtester\n\n## 内存管理\n\n### malloc\n\n1. [memory-allocators-101-write-a-simple-memory](https://arjunsreedharan.org/post/148675821737/memory-allocators-101-write-a-simple-memory)\n1. malloc 缺点：\n   - 易内存泄漏\n   - 碎片化，影响性能\n\n## links\n\n1. [apache/arrow 内存分析工具](https://github.com/apache/arrow)\n1. [What Every Programmer Should Know About Memory](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf)\n1. [每个程序员都应该了解的内存知识](https://zhuanlan.zhihu.com/p/611133924)\n1. [meminfo](https://github.com/freelancer-leon/notes/blob/master/kernel/mm/meminfo.md)\n1. [memory-allocators-101-write-a-simple-memory](https://arjunsreedharan.org/post/148675821737/memory-allocators-101-write-a-simple-memory)\n","tags":["Rust","Memory","C++"],"categories":["Program","Basic"]},{"title":"Dangling pointer","url":"/2020/07/26/Dangling-pointer/","content":"\n## Sample1\n\n``` c++\nint main() {\n    auto Name = input();\n    cout << \"Hello \" << Name << '\\n';\n    return 0;\n}\n\nconst char* input() {\n    string Line;\n    getline(cin, Line);\n    return Line.c_str();  // Line is destroyed\n}\n\n```\n\n## Sample2\n\n``` c++\n#include <iostream>\nusing namespace std;\n\nvoid test() {\n    int* p = nullptr;\n    {\n        int x = 0;\n        p = &x;\n        cout << *p;\n    }  // x is destroyed\n\n    cout << *p;\n}\n```\n\n## Sample3\n\n``` c++\n#include <iostream>\nusing namespace std;\n\nstring_view {\n    size_t len;\n    const char* str;\n}\n\nvoid test() {\n    string_view s;\n    {\n        char a[100];\n        s = a;\n        cout << s[0];\n    }  // a is destroyed and a.str become a dangling pointer\n\n    cout << s[0];\n}\n\n```\n\n## Sample4\n\n``` c++\nvoid swap(Object* a, Object* b){\n    Object* tmp;\n    tmp = a;  //tmp point to a\n    a = b;\n    b = tmp;\n}  // tmp was destroyed and b will be a dangling pointer\n\n```\n\n## Sample5\n\n``` c++\nint* a = new int(100);\n\nfor (size_t i = 0; i < 100; i++) {\n    *(a++) = i;  // a has been changed and a not point array[0] now\n}\n\nstd::cout << a[0] << std::endl;\ndelete a;\n\n```\n\n## Links\n[zhihu example](https://zhuanlan.zhihu.com/p/85200304)\n","tags":["Cpp"],"categories":["Program","Cpp"]},{"title":"Zsh config","url":"/2020/07/22/Zsh-config/","content":"\n## NOTE\n\n1. scp not work\n\n```\n# remember to put this code to .bashrc before execute zsh\n# If not, scp can not work.\n[[ $- == *i* ]] || return\nzsh\n```\n\n2. 如果你使用的是 zsh，上面的通配符会失效，你可以切换到 bash 执行这些命令，或者使用 setopt no_nomatch 来关闭 zsh 对于通配符的拦截\n\n## oh my zsh\n\n```sh\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n## [microsoft/inshellisense](https://github.com/microsoft/inshellisense) [npm issue](https://stackoverflow.com/a/61404290)\n\n```sh\nnpm install -g @microsoft/inshellisense\ninshellisense bind\n```\n\n## autosuggestions\n\n```sh\ngit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/custom/plugins/zsh-autosuggestions\nsed -i \"s/fg=8/fg=cyan/\" .oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\nvi ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 文件，修改 ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=blue'\n# support colors: black, red, green; yellow; blue; magenta; cyan and white;\n```\n\n## zsh-syntax-highlighting\n\n```sh\ngit clone git://github.com/jimmijj/zsh-syntax-highlighting ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting\n```\n\n## .zshrc config\n\n```sh\nexport PROMPT=\"%n@%m:%1~%# \"\nplugins=(rust rustup cargo zsh-autosuggestions zsh-syntax-highlighting colored-man-pages tmux fd)\n```\n\n## Othe config\n\n```sh\ngit config oh-my-zsh.hide-status 1 --global #close git status\n```\n\n## Powlevel9k theme\n\n```\ngit clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k\n.zshrc：\nexport TERM=\"xterm-256color\"\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(user dir)\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(root_indicator background_jobs )\nPOWERLEVEL9K_MODE='awesome-fontconfig'\nZSH_THEME=\"powerlevel9k/powerlevel9k\"\n~/.oh-my-zsh/custom/themes/powerlevel9k/powerlevel9k.zsh-theme          修改  \"CONTENT\"             \"jia@61\" #\"$(whoami)\"\n```\n\n## awesome-terminal-fonts\n\n```sh\ngit clone https://github.com/gabrielelana/awesome-terminal-fonts\ncp -R build/* ~/.fonts/\nfc-cache -fv ~/.fonts\ncp config/10-symbols.conf ~/.config/fontconfig/conf.d\nsource ~/.fonts/*.sh\n```\n\n## autojump\n\n```sh\ngit clone git://github.com/joelthelion/autojump.git\ncd autojump\n./install.py\n```\n\n## powerline(非必须）\n\n```sh\nsudo apt-get install fonts-powerline\ngit clone https://github.com/powerline/fonts.git --depth=1\ncd fonts\n./install.sh\n```\n\n## Links\n\ninstall oh my zsh : sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\nzsh autosuggestions https://note.youdao.com/web/#/file/WEB35aa360d3643be282ab89890d39646cf/note/WEBa075b0a3e60cbde5f506563c3c14997a/\nsudo apt-get install autojump https://note.youdao.com/web/#/file/WEB35aa360d3643be282ab89890d39646cf/note/WEB1da9f35b71c3815439e1426116e7ecf9/\nPowlevel9k theme install https://note.youdao.com/web/#/file/WEB35aa360d3643be282ab89890d39646cf/note/WEBfd1ecc9886dfcf108ee9bae6b586cab6/\nPowerline https://note.youdao.com/web/#/file/WEB35aa360d3643be282ab89890d39646cf/note/WEBac4ed9c8ab78bb09940458cfb9b1a397/\nawesome-terminal-fonts http://www.cnblogs.com/weixuqin/p/7029177.html\nzsh-syntax-highlighting https://note.youdao.com/web/#/file/WEB35aa360d3643be282ab89890d39646cf/note/WEBef4ca4fdaf7d36950545241429e3daee/\n","tags":["Zsh"],"categories":["Tools","Zsh"]},{"title":"Why Rust","url":"/2020/07/10/Why-Rust/","content":"\n## Why Rust?\n### Performance\n1. It's **`fast`** and memory efficient: with no runtime or garbage collector.\n1. It can easily integrate with other languages.\n\n### Reliability\n1. It's rich type system and ownership model guarantee <font color='red'>**memory-safety**</font> and <font color='red'>**thread-safety**</font>.\n\n### Productivity\n1. Great documentation\n1. Friendly compiler, find most errors when compiling\n1. An integrated package manager\n1. Doc system: `cargo doc --open`\n\n## Rust features\n1. Zero-cost abstractions\n1. Modern conveniences\n1. Type system: Ownership and Borrowing\n1. Sense of craftsmanship\n\n## Why Name Rust?\n1. It's a pun on \"chrome\". Rust was written by the engineer company Mozilla(firefox). And chrome is a metal.\n\n## Rust 目的\n1. 创建这个新语言的目的是为了解决一个顽疾：软件的演进速度大大低于硬件的演进，软件在语言级别上无法真正利用多核计算带来的性能提升。Rust是针对多核体系提出的语言，并且吸收一些其他动态语言的重要特性，比如不需要管理内存，比如不会出现Null指针等\n\n## Why not C++\n1. 当然C++ 也很好，因为它教会了我怎么面向搜索引擎编程。\n\n## Rust类型系统借鉴Haskell特性\n1. 没有空指针\n1. 类型默认不可变\n1. 表达式\n1. 高阶函数\n1. 代数数据类型\n1. 模式匹配\n1. 泛型\n1. trait和关联类型\n1. 本地类型推导\n\n## Rust相比Haskell独有特点\n1. 仿射变换(Affine Type)\n1. 借用，生命周期\n","tags":["Rust"],"categories":["Program","Rust"]},{"title":"Rust start","url":"/2020/07/09/Rust-start/","content":"\n![Ferris](https://www.rust-lang.org/static/images/ferris.gif)\n\n## Install on linux\n\n1. `curl https://sh.rustup.rs -sSf | sh`\n1. [Install step](https://doc.rust-lang.org/book/ch01-01-installation.html)\n\n## Config\n\n1. [wcy's config](http://wcy123.github.io/2020-04-05-setup-rust-IDE-for-emacs.html)\n\n## Local doc\n\n1. `rustup doc`\n\n## Links\n\n1. [Officail website](https://www.rust-lang.org/)\n1. [Official resource](https://www.rust-lang.org/learn)\n1. [Awesome Rust](https://github.com/rust-unofficial/awesome-rust#readme)\n1. [Rust learning](https://github.com/ctjhoa/rust-learning)\n1. [Forum](https://users.rust-lang.org/)\n1. [Packages](https://crates.io/)\n1. [STD library](https://doc.rust-lang.org/std/index.html)\n1. [Rust book](https://doc.rust-lang.org/book/)\n1. [Rust book Chinese](http://120.78.128.153/rustbook/)\n1. [Cargo book](https://doc.rust-lang.org/cargo/)\n1. [Rust examples](https://doc.rust-lang.org/stable/rust-by-example/)\n1. [Rust online programming](https://play.rust-lang.org/)\n1. [Ferris pictures](https://rustacean.net/)\n1. [Rust gameboy](https://github.com/mohanson/gameboy)\n1. [Rust zhihu](https://www.zhihu.com/topic/19674381/intro)\n1. [Rust 张汉东](https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM)\n1. [未来的人工智能语言，是 Rust 还是 Mojo ？](https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA%3D%3D&mid=2247597850&idx=1&sn=679ccdcaf76e8b6ab97ca42687769da1)\n\n## repos\n\n1. [egui](https://github.com/emilk/egui)\n1. [rerun](https://github.com/rerun-io/rerun)\n","tags":["Rust"],"categories":["Program","Rust"]},{"title":"Clang-format-usage","url":"/2020/07/01/Clang-format-usage/","content":"\n## Notes\n\n1. 不同版本的 clang-format 输出格式可能不同，需要统一团队版本\n1. 文件中有编码错误的字符不能被 format\n\n## format check\n\n1. [run-clang-format](https://github.com/Sarcasm/run-clang-format/tree/master)\n   - `-r samples` 文件夹\n   - `-i` 修改\n1. [github clang-format-check](https://github.com/marketplace/actions/clang-format-check)\n1. [enforce-code-consistency-clang-format#enforce_the_new_coding_rules](https://developers.redhat.com/articles/2022/02/25/enforce-code-consistency-clang-format#enforce_the_new_coding_rules)\n1. `clang-format --Werror -n --verbose test.cpp` 可以检测是否符合 clang-format\n1. cpplint\n1. [gitlab check](https://stackoverflow.com/a/69362305)\n1. [pre-commit](https://gitlab.com/daverona/pre-commit/cpp)\n1. [git pre commit](https://blog.csdn.net/zmlovelx/article/details/105196415)\n\n## Install clang\n\n1. [Build clang from source](http://clang.llvm.org/get_started.html)\n1. [Clang format doc](http://clang.llvm.org/docs/ClangFormat.html)\n\n## format config\n\n1. [Clang format style](http://clang.llvm.org/docs/ClangFormatStyleOptions.html)\n1. [clang format config 试验](https://zed0.co.uk/clang-format-configurator/)\n1. `AllowShortFunctionsOnASingleLine: None` 函数不在一行\n1. `SortIncludes: false` 头文件不排序\n\n## Bash Command\n\n1. generate .clang-format\n   `clang-format -style=llvm -dump-config > .clang-format`\n1. Format one cpp file:\n   `clang-format --style=Google -i test.cpp`\n1. Format all cpp files:\n   `fd \".cpp$\" | xargs clang-format --style=Google -i`\n\n## git\n\n1. `git-clang-format-12 or git clang-format-12` format staged files\n1. `git-clang-format-12 --diff` 查看要 format 的变化\n\n## Vim Config\n\n1. Find clang-format.py in your system and copy the file path.\n\n```sh\n ~ : find /usr -iname \"clang-format.py\"\n/usr/local/share/clang/clang-format.py\n```\n\n2. Put the following config in your .vimrc. It will automaticly format the c++ file when the file is saved.\n\n```\nfunction! Formatonsave()\n  let l:lines = 'all'\n  let l:formatdiff = 1\n  let g:clang_format_fallback_style = 'Google'\n  \" Remember to repalce the path of clang-format.py\n  pyfile /usr/local/share/clang/clang-format.py\n  \" py3file /usr/local/share/clang/clang-format.py\nendfunction\nautocmd BufWritePre *.h,*.hpp,*.cc,*.cpp call Formatonsave()\n\n```\n\n## Emacs Config\n\n1. use package config\n\n```emacs-lisp\n(use-package clang-format\n  :after (cc-mode)\n  :config\n  (set-default 'clang-format-fallback-style \"Google\")\n  (add-hook 'c-mode-common-hook #'(lambda()\n                                    (add-hook 'before-save-hook\n                                              'clang-format-buffer t t))))\n```\n\n## Config\n\nClang-format understands also special comments that switch formatting in a delimited range. The code between a comment `// clang-format off or /* clang-format off */ `up to a comment `// clang-format on or /* clang-format on */ `will not be formatted. The comments themselves will be formatted (aligned) normally.\n\n```c++\nint formatted_code;\n// clang-format off\n    void    unformatted_code  ;\n// clang-format on\nvoid formatted_code_again;\n```\n","tags":["Emacs","Clang format","Vim"],"categories":["Tools","Clang"]},{"title":"write blog","url":"/2020/06/26/How-to-start-writing-blog/","content":"\n## Set up githubio\n\n1. Follow [github pages guide](https://guides.github.com/features/pages/) to apply a web.\n1. [configuring-a-publishing-source-for-your-github-pages-site](https://docs.github.com/cn/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site)\n\n## Use hexo (or JekyII)\n\n1. [ubuntu16.04 nodejs install](https://github.com/nodesource/distributions/blob/master/README.md)\n   - Need sudo to use npm install packages.\n   - [npm install error solve](https://www.jianshu.com/p/3fd7d90db01a)\n2. on Windows\n   - install node.js on windows and [set env](https://blog.csdn.net/chengyuweng7838/article/details/100996272)\n   - `npm install --force hexo-cli -g --registry=https://registry.npm.taobao.org`\n3. [hexo tutorial](https://hexo.io/zh-cn/)\n4. [hexo theme 3-hexo](https://github.com/yelog/hexo-theme-3-hexo)\n   - `_config.yml` theme: 3-hexo\n5. [3-hexo tutorial](https://yelog.org/2017/03/23/3-hexo-instruction/)\n\n## Write blog\n\n1. [markdown tutorial](https://guides.github.com/features/mastering-markdown/)\n\n## Push blog to githubio\n\n1. [hexo tutorial](https://hexo.io/zh-cn/docs/one-command-deployment)\n\n## Hexo basic comamnd\n\n1. Create a new post\n   `$ hexo new \"My New Post\"`\n1. Generate static files\n   `$ hexo generate`\n1. Run server(local site)\n   `$ hexo server`\n   `$ hexo server -p 5900`\n1. Deploy to remote sites\n   `$ hexo clean && hexo deploy`\n1. shortcuts\n   `alias hs='hexo clean && hexo g && hexo s'`\n   `alias hd='hexo clean && hexo g && hexo d && git add . && git commit -m \"update\" && git push -f'`\n\n## hexo plugins\n\n1. hexo-generator-searchdb\n1. hexo-symbols-count-time\n1. hexo-auto-excerp\n1. hexo-related-popular-posts\n1. hexo-filter-mermaid-diagrams\n1. hexo-generator-topindex\n\n## hexo config\n\n1. [theme-settings/posts](https://theme-next.js.org/docs/theme-settings/posts)\n1. [Hexo 博客 NexT 主题下如何添加分类、标签](https://cs-cshi.github.io/hexo-blog/Hexo-NexT%20%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E3%80%81%E6%A0%87%E7%AD%BE/) [对应的主题配置](https://github.com/cs-cshi/hexo-theme-next)\n1. [mermaid support](http://yelog.org/2019/11/12/3-hexo-support-mermaid/)\n1. [3-hexo theme nav settings](https://github.com/jiaxiyang/blog/commit/e293840421fb4510c5a3499ff4c828b2cca7f51a)\n1. [hexo-theme-next](https://github.com/iissnan/hexo-theme-next)\n1. [theme-next.org](https://theme-next.org/)\n1. [next sample1](https://plantegg.github.io/2021/05/16/CPU_Cache_Line%E5%92%8C%E6%80%A7%E8%83%BD/)\n1. [hexo sample2](https://neuyilan.github.io/)\n\n## next theme\n\n1.  [links 颜色设置](https://vonsdite.github.io/posts/13afd8d4.html)\n1.  `<!-- more -->` It's a common need to show some part of article in home page and then give a link to full article.\n1.  [live2d-widget](https://github.com/stevenjoezhang/live2d-widget)\n1.  [theme-next-docs 可以看各主题效果](https://github.com/next-theme/theme-next-docs)\n    - 参考如何配置\n1.  [good 参考](https://www.idefun.com/)\n1.  [如何添加 google analytics](https://justdong.net/wexin/weixin_03google-analytics)\n1.  [sitemap 让 google 和百度搜索到](https://www.gaotianyang.top/archives/20200814f023bd8e/)\n1.  [valine 评论系统](https://valine.js.org/quickstart.html)\n1.  [显示网站运行时间](https://blog.51cto.com/u_12877374/4977880)\n1.  [显示动画](https://github.com/theme-next/theme-next-three)\n1.  [pdf 支持](https://github.com/next-theme/theme-next-pdf)\n1.  [hexo-filter-mathjax 处理数学公式](https://github.com/next-theme/hexo-filter-mathjax)\n    - `npm install hexo-filter-mathjax`\n    - [mathjax live #demo](https://www.mathjax.org/#demo)\n1.  $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$\n    $$\n    i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi\n    $$\n1.  [(good)hexo-theme-beautify](https://eblog.gitee.io/posts/hexo/hexo-theme-beautify.html)\n1.  [mermaid 支持](https://theme-next.js.org/docs/tag-plugins/mermaid)\n    - `sudo npm install hexo-cli -g` 工程目录下升级 hexo\n1.  [高亮支持的语言](https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md)\n1.  [高亮预览](https://theme-next.js.org/highlight/)\n\n## [shareX](https://getsharex.com/)\n\n1. 使用 shareX 保存图像，链接到 blog 里, 一篇 blog 一个文件夹\n","tags":["Blog"],"categories":["Tools","Blog"]},{"title":"about","url":"/about/index-1.html"},{"title":"about","url":"/about/index.html","content":"\n## 个人简介\n贾夕阳\n毕业于北京理工大学，目前从事人工智能软件架构工作\n\n## 联系方式\n1. mail: jiaxiyangbit@126.com\n2. qq: 312567150\n"},{"title":"categories","url":"/categories/index.html"},{"title":"tags","url":"/tags/index.html"}]